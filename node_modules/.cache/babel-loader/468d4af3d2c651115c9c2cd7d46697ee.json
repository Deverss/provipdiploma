{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.treePostProcessFromProofNode = void 0;\n\nconst persistent_merkle_tree_1 = require(\"@chainsafe/persistent-merkle-tree\");\n/** Duplicated partial declaration to break circular dependency with CompositeType */\n\n\nfunction isCompositeType(type) {\n  return !type.isBasic;\n}\n/**\n * Navigates and mutates nodes to post process a tree created with `Tree.createFromProof`.\n * Tree returns regular a tree with only BranchNode and LeafNode instances. However, SSZ features\n * non-standard nodes that make proofs for those types to be un-usable. This include:\n * - BranchNodeStruct: Must contain complete data `tree_fromProofNode` transforms a BranchNode and\n *   all of its data into a single BranchNodeStruct instance.\n *\n * @param bitstring Bitstring without the leading \"1\", since it's only used to compute horizontal indexes.\n */\n\n\nfunction treePostProcessFromProofNode(node, type, bitstring = \"\", currentDepth = 0) {\n  // Must run tree_fromProofNode on the first received node (i.e. Validator object)\n  if (currentDepth === 0) {\n    const nodePost = type.tree_fromProofNode(node);\n\n    if (nodePost.done) {\n      return nodePost.node;\n    } else {\n      node = nodePost.node;\n    }\n  }\n\n  const atTypeDepth = type.depth === currentDepth;\n\n  if (node.isLeaf()) {\n    if (atTypeDepth) {\n      const jsonPathProp = type.getIndexProperty(bitstringToIndex(bitstring));\n\n      if (jsonPathProp === null) {\n        // bitstring is out of bounds, witness node\n        return node;\n      }\n\n      const childType = type.getPropertyType(jsonPathProp); // If this type merkleized fits in a single chunk then this LeafNode includes all data\n\n      if (childType.maxChunkCount === 1 && isCompositeType(childType)) {\n        return childType.tree_fromProofNode(node).node;\n      } // Witness node\n      else {\n          return node;\n        }\n    } // LeafNode not at type depth is a witness or a length / selector nodes\n    else {\n        return node;\n      }\n  } else {\n    if (atTypeDepth) {\n      const jsonPathProp = type.getIndexProperty(bitstringToIndex(bitstring));\n\n      if (jsonPathProp === null) {\n        // bitstring is out of bounds, witness node\n        return node;\n      }\n\n      const childType = type.getPropertyType(jsonPathProp);\n\n      if (!isCompositeType(childType)) {\n        throw Error(\"BranchNode does not map to CompositeType\");\n      }\n\n      const nodePost = childType.tree_fromProofNode(node); // If tree_fromProofNode is the identity function, keep going, otherwise stop navigating\n\n      if (nodePost.done) {\n        return nodePost.node;\n      } else {\n        return treePostProcessFromProofNode(nodePost.node, childType);\n      }\n    } // BranchNode at not type depth, keep navigating\n    else {\n        const leftNode = treePostProcessFromProofNode(node.left, type, bitstring + \"0\", currentDepth + 1);\n        const rightNode = treePostProcessFromProofNode(node.right, type, bitstring + \"1\", currentDepth + 1);\n\n        if (leftNode === node.left && rightNode === node.right) {\n          return node;\n        } else {\n          return new persistent_merkle_tree_1.BranchNode(leftNode, rightNode);\n        }\n      }\n  }\n}\n\nexports.treePostProcessFromProofNode = treePostProcessFromProofNode;\n/** Return the node horizontal index given a bitstring without the leading \"1\" */\n\nfunction bitstringToIndex(bitstring) {\n  if (bitstring === \"\") return 0;\n  return parseInt(bitstring, 2);\n}","map":{"version":3,"sources":["../../../src/util/proof/treePostProcessFromProofNode.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.treePostProcessFromProofNode = void 0;\nconst persistent_merkle_tree_1 = require(\"@chainsafe/persistent-merkle-tree\");\n/** Duplicated partial declaration to break circular dependency with CompositeType */\nfunction isCompositeType(type) {\n    return !type.isBasic;\n}\n/**\n * Navigates and mutates nodes to post process a tree created with `Tree.createFromProof`.\n * Tree returns regular a tree with only BranchNode and LeafNode instances. However, SSZ features\n * non-standard nodes that make proofs for those types to be un-usable. This include:\n * - BranchNodeStruct: Must contain complete data `tree_fromProofNode` transforms a BranchNode and\n *   all of its data into a single BranchNodeStruct instance.\n *\n * @param bitstring Bitstring without the leading \"1\", since it's only used to compute horizontal indexes.\n */\nfunction treePostProcessFromProofNode(node, type, bitstring = \"\", currentDepth = 0) {\n    // Must run tree_fromProofNode on the first received node (i.e. Validator object)\n    if (currentDepth === 0) {\n        const nodePost = type.tree_fromProofNode(node);\n        if (nodePost.done) {\n            return nodePost.node;\n        }\n        else {\n            node = nodePost.node;\n        }\n    }\n    const atTypeDepth = type.depth === currentDepth;\n    if (node.isLeaf()) {\n        if (atTypeDepth) {\n            const jsonPathProp = type.getIndexProperty(bitstringToIndex(bitstring));\n            if (jsonPathProp === null) {\n                // bitstring is out of bounds, witness node\n                return node;\n            }\n            const childType = type.getPropertyType(jsonPathProp);\n            // If this type merkleized fits in a single chunk then this LeafNode includes all data\n            if (childType.maxChunkCount === 1 && isCompositeType(childType)) {\n                return childType.tree_fromProofNode(node).node;\n            }\n            // Witness node\n            else {\n                return node;\n            }\n        }\n        // LeafNode not at type depth is a witness or a length / selector nodes\n        else {\n            return node;\n        }\n    }\n    else {\n        if (atTypeDepth) {\n            const jsonPathProp = type.getIndexProperty(bitstringToIndex(bitstring));\n            if (jsonPathProp === null) {\n                // bitstring is out of bounds, witness node\n                return node;\n            }\n            const childType = type.getPropertyType(jsonPathProp);\n            if (!isCompositeType(childType)) {\n                throw Error(\"BranchNode does not map to CompositeType\");\n            }\n            const nodePost = childType.tree_fromProofNode(node);\n            // If tree_fromProofNode is the identity function, keep going, otherwise stop navigating\n            if (nodePost.done) {\n                return nodePost.node;\n            }\n            else {\n                return treePostProcessFromProofNode(nodePost.node, childType);\n            }\n        }\n        // BranchNode at not type depth, keep navigating\n        else {\n            const leftNode = treePostProcessFromProofNode(node.left, type, bitstring + \"0\", currentDepth + 1);\n            const rightNode = treePostProcessFromProofNode(node.right, type, bitstring + \"1\", currentDepth + 1);\n            if (leftNode === node.left && rightNode === node.right) {\n                return node;\n            }\n            else {\n                return new persistent_merkle_tree_1.BranchNode(leftNode, rightNode);\n            }\n        }\n    }\n}\nexports.treePostProcessFromProofNode = treePostProcessFromProofNode;\n/** Return the node horizontal index given a bitstring without the leading \"1\" */\nfunction bitstringToIndex(bitstring) {\n    if (bitstring === \"\")\n        return 0;\n    return parseInt(bitstring, 2);\n}\n//# sourceMappingURL=treePostProcessFromProofNode.js.map"]},"metadata":{},"sourceType":"script"}