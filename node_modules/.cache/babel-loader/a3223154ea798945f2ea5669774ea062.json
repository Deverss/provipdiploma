{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.byteArrayEquals = exports.fromHexString = exports.toHexString = void 0; // Caching this info costs about ~1000 bytes and speeds up toHexString() by x6\n\nconst hexByByte = new Array(256);\n\nfunction toHexString(bytes) {\n  let hex = \"0x\";\n\n  for (const byte of bytes) {\n    if (!hexByByte[byte]) {\n      hexByByte[byte] = byte < 16 ? \"0\" + byte.toString(16) : byte.toString(16);\n    }\n\n    hex += hexByByte[byte];\n  }\n\n  return hex;\n}\n\nexports.toHexString = toHexString;\n\nfunction fromHexString(hex) {\n  if (typeof hex !== \"string\") {\n    throw new Error(`hex argument type ${typeof hex} must be of type string`);\n  }\n\n  if (hex.startsWith(\"0x\")) {\n    hex = hex.slice(2);\n  }\n\n  if (hex.length % 2 !== 0) {\n    throw new Error(`hex string length ${hex.length} must be multiple of 2`);\n  }\n\n  const byteLen = hex.length / 2;\n  const bytes = new Uint8Array(byteLen);\n\n  for (let i = 0; i < byteLen; i++) {\n    const byte = parseInt(hex.slice(i * 2, (i + 1) * 2), 16);\n    bytes[i] = byte;\n  }\n\n  return bytes;\n}\n\nexports.fromHexString = fromHexString;\n\nfunction byteArrayEquals(a, b) {\n  if (a.length !== b.length) {\n    return false;\n  }\n\n  for (let i = 0; i < a.length; i++) {\n    if (a[i] !== b[i]) return false;\n  }\n\n  return true;\n}\n\nexports.byteArrayEquals = byteArrayEquals;","map":{"version":3,"sources":["../../src/util/byteArray.ts"],"names":[],"mappings":";;;;;gFAEA;;AACA,MAAM,SAAS,GAAG,IAAI,KAAJ,CAAkB,GAAlB,CAAlB;;AAEA,SAAgB,WAAhB,CAA4B,KAA5B,EAA0D;AACxD,MAAI,GAAG,GAAG,IAAV;;AACA,OAAK,MAAM,IAAX,IAAmB,KAAnB,EAA0B;AACxB,QAAI,CAAC,SAAS,CAAC,IAAD,CAAd,EAAsB;AACpB,MAAA,SAAS,CAAC,IAAD,CAAT,GAAkB,IAAI,GAAG,EAAP,GAAY,MAAM,IAAI,CAAC,QAAL,CAAc,EAAd,CAAlB,GAAsC,IAAI,CAAC,QAAL,CAAc,EAAd,CAAxD;AACD;;AACD,IAAA,GAAG,IAAI,SAAS,CAAC,IAAD,CAAhB;AACD;;AACD,SAAO,GAAP;AACD;;AATD,OAAA,CAAA,WAAA,GAAA,WAAA;;AAWA,SAAgB,aAAhB,CAA8B,GAA9B,EAAyC;AACvC,MAAI,OAAO,GAAP,KAAe,QAAnB,EAA6B;AAC3B,UAAM,IAAI,KAAJ,CAAU,qBAAqB,OAAO,GAAG,yBAAzC,CAAN;AACD;;AAED,MAAI,GAAG,CAAC,UAAJ,CAAe,IAAf,CAAJ,EAA0B;AACxB,IAAA,GAAG,GAAG,GAAG,CAAC,KAAJ,CAAU,CAAV,CAAN;AACD;;AAED,MAAI,GAAG,CAAC,MAAJ,GAAa,CAAb,KAAmB,CAAvB,EAA0B;AACxB,UAAM,IAAI,KAAJ,CAAU,qBAAqB,GAAG,CAAC,MAAM,wBAAzC,CAAN;AACD;;AAED,QAAM,OAAO,GAAG,GAAG,CAAC,MAAJ,GAAa,CAA7B;AACA,QAAM,KAAK,GAAG,IAAI,UAAJ,CAAe,OAAf,CAAd;;AACA,OAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,OAApB,EAA6B,CAAC,EAA9B,EAAkC;AAChC,UAAM,IAAI,GAAG,QAAQ,CAAC,GAAG,CAAC,KAAJ,CAAU,CAAC,GAAG,CAAd,EAAiB,CAAC,CAAC,GAAG,CAAL,IAAU,CAA3B,CAAD,EAAgC,EAAhC,CAArB;AACA,IAAA,KAAK,CAAC,CAAD,CAAL,GAAW,IAAX;AACD;;AACD,SAAO,KAAP;AACD;;AApBD,OAAA,CAAA,aAAA,GAAA,aAAA;;AAsBA,SAAgB,eAAhB,CAAgC,CAAhC,EAA+C,CAA/C,EAA4D;AAC1D,MAAI,CAAC,CAAC,MAAF,KAAa,CAAC,CAAC,MAAnB,EAA2B;AACzB,WAAO,KAAP;AACD;;AACD,OAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,CAAC,CAAC,MAAtB,EAA8B,CAAC,EAA/B,EAAmC;AACjC,QAAI,CAAC,CAAC,CAAD,CAAD,KAAS,CAAC,CAAC,CAAD,CAAd,EAAmB,OAAO,KAAP;AACpB;;AACD,SAAO,IAAP;AACD;;AARD,OAAA,CAAA,eAAA,GAAA,eAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.byteArrayEquals = exports.fromHexString = exports.toHexString = void 0;\n// Caching this info costs about ~1000 bytes and speeds up toHexString() by x6\nconst hexByByte = new Array(256);\nfunction toHexString(bytes) {\n    let hex = \"0x\";\n    for (const byte of bytes) {\n        if (!hexByByte[byte]) {\n            hexByByte[byte] = byte < 16 ? \"0\" + byte.toString(16) : byte.toString(16);\n        }\n        hex += hexByByte[byte];\n    }\n    return hex;\n}\nexports.toHexString = toHexString;\nfunction fromHexString(hex) {\n    if (typeof hex !== \"string\") {\n        throw new Error(`hex argument type ${typeof hex} must be of type string`);\n    }\n    if (hex.startsWith(\"0x\")) {\n        hex = hex.slice(2);\n    }\n    if (hex.length % 2 !== 0) {\n        throw new Error(`hex string length ${hex.length} must be multiple of 2`);\n    }\n    const byteLen = hex.length / 2;\n    const bytes = new Uint8Array(byteLen);\n    for (let i = 0; i < byteLen; i++) {\n        const byte = parseInt(hex.slice(i * 2, (i + 1) * 2), 16);\n        bytes[i] = byte;\n    }\n    return bytes;\n}\nexports.fromHexString = fromHexString;\nfunction byteArrayEquals(a, b) {\n    if (a.length !== b.length) {\n        return false;\n    }\n    for (let i = 0; i < a.length; i++) {\n        if (a[i] !== b[i])\n            return false;\n    }\n    return true;\n}\nexports.byteArrayEquals = byteArrayEquals;\n//# sourceMappingURL=byteArray.js.map"]},"metadata":{},"sourceType":"script"}