{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.gindexChild = exports.gindexParent = exports.gindexSibling = exports.concatGindices = exports.getGindexBits = exports.gindexIterator = exports.getGindicesAtDepth = exports.iterateAtDepth = exports.countToDepth = exports.convertGindexToBitstring = exports.toGindexBitstring = exports.toGindex = exports.bitIndexBigInt = void 0;\n\nfunction bitIndexBigInt(v) {\n  return v.toString(2).length - 1;\n}\n\nexports.bitIndexBigInt = bitIndexBigInt;\n\nfunction toGindex(depth, index) {\n  const anchor = BigInt(1) << BigInt(depth);\n\n  if (index >= anchor) {\n    throw new Error(`index ${index} too large for depth ${depth}`);\n  }\n\n  return anchor | index;\n}\n\nexports.toGindex = toGindex;\n\nfunction toGindexBitstring(depth, index) {\n  const str = index ? Number(index).toString(2) : \"\";\n\n  if (str.length > depth) {\n    throw new Error(\"index too large for depth\");\n  } else {\n    return \"1\" + str.padStart(depth, \"0\");\n  }\n}\n\nexports.toGindexBitstring = toGindexBitstring;\n\nfunction convertGindexToBitstring(gindex) {\n  if (typeof gindex === \"string\") {\n    if (gindex.length === 0) {\n      throw new Error(ERR_INVALID_GINDEX);\n    }\n\n    return gindex;\n  } else {\n    if (gindex < 1) {\n      throw new Error(ERR_INVALID_GINDEX);\n    }\n\n    return gindex.toString(2);\n  }\n}\n\nexports.convertGindexToBitstring = convertGindexToBitstring; // Get the depth (root starting at 0) necessary to cover a subtree of `count` elements.\n// (in out): (0 0), (1 0), (2 1), (3 2), (4 2), (5 3), (6 3), (7 3), (8 3), (9 4)\n\nfunction countToDepth(count) {\n  if (count <= 1) {\n    return 0;\n  }\n\n  return (count - BigInt(1)).toString(2).length;\n}\n\nexports.countToDepth = countToDepth;\n/**\n * Iterate through Gindexes at a certain depth\n */\n\nfunction iterateAtDepth(depth, startIndex, count) {\n  const anchor = BigInt(1) << BigInt(depth);\n\n  if (startIndex + count > anchor) {\n    throw new Error(\"Too large for depth\");\n  }\n\n  let i = toGindex(depth, startIndex);\n  const last = i + count;\n  return {\n    [Symbol.iterator]() {\n      return {\n        next() {\n          if (i < last) {\n            const value = i;\n            i++;\n            return {\n              done: false,\n              value\n            };\n          } else {\n            return {\n              done: true,\n              value: undefined\n            };\n          }\n        }\n\n      };\n    }\n\n  };\n}\n\nexports.iterateAtDepth = iterateAtDepth;\n/**\n * Return Gindexes at a certain depth\n */\n\nfunction getGindicesAtDepth(depth, startIndex, count) {\n  const anchor = BigInt(1) << BigInt(depth);\n\n  if (startIndex + count > anchor) {\n    throw new Error(\"Too large for depth\");\n  }\n\n  let gindex = toGindex(depth, BigInt(startIndex));\n  const gindices = [];\n\n  for (let i = 0; i < count; i++) {\n    gindices.push(gindex++);\n  }\n\n  return gindices;\n}\n\nexports.getGindicesAtDepth = getGindicesAtDepth;\nconst ERR_INVALID_GINDEX = \"Invalid gindex\";\n\nfunction gindexIterator(gindex) {\n  let bitstring;\n\n  if (typeof gindex === \"string\") {\n    if (!gindex.length) {\n      throw new Error(ERR_INVALID_GINDEX);\n    }\n\n    bitstring = gindex;\n  } else {\n    if (gindex < 1) {\n      throw new Error(ERR_INVALID_GINDEX);\n    }\n\n    bitstring = gindex.toString(2);\n  }\n\n  let i = 1;\n\n  const next = () => {\n    if (i === bitstring.length) {\n      return {\n        done: true,\n        value: undefined\n      };\n    }\n\n    const bit = Number(bitstring[i]);\n    i++;\n    return {\n      done: false,\n      value: bit\n    };\n  };\n\n  return {\n    [Symbol.iterator]() {\n      return {\n        next\n      };\n    },\n\n    remainingBitLength() {\n      return bitstring.length - i;\n    }\n\n  };\n}\n\nexports.gindexIterator = gindexIterator;\n\nfunction getGindexBits(gindex) {\n  let bitstring;\n\n  if (typeof gindex === \"string\") {\n    if (!gindex.length) {\n      throw new Error(ERR_INVALID_GINDEX);\n    }\n\n    bitstring = gindex;\n  } else {\n    if (gindex < 1) {\n      throw new Error(ERR_INVALID_GINDEX);\n    }\n\n    bitstring = gindex.toString(2);\n  }\n\n  const bits = [];\n\n  for (let i = 1; i < bitstring.length; i++) {\n    bits.push(Number(bitstring[i]));\n  }\n\n  return bits;\n}\n\nexports.getGindexBits = getGindexBits;\n/**\n * Concatenate Generalized Indices\n * Given generalized indices i1 for A -> B, i2 for B -> C .... i_n for Y -> Z, returns\n * the generalized index for A -> Z.\n */\n\nfunction concatGindices(gindices) {\n  return BigInt(gindices.reduce((acc, gindex) => acc + gindex.toString(2).slice(1), \"0b1\"));\n}\n\nexports.concatGindices = concatGindices;\n\nfunction gindexSibling(gindex) {\n  return gindex ^ BigInt(1);\n}\n\nexports.gindexSibling = gindexSibling;\n\nfunction gindexParent(gindex) {\n  return gindex / BigInt(2);\n}\n\nexports.gindexParent = gindexParent;\n\nfunction gindexChild(gindex, rightChild) {\n  return gindex * BigInt(2) + BigInt(rightChild);\n}\n\nexports.gindexChild = gindexChild;","map":{"version":3,"sources":["/Users/dev3rs/provipdiploma/node_modules/@chainsafe/persistent-merkle-tree/lib/gindex.js"],"names":["Object","defineProperty","exports","value","gindexChild","gindexParent","gindexSibling","concatGindices","getGindexBits","gindexIterator","getGindicesAtDepth","iterateAtDepth","countToDepth","convertGindexToBitstring","toGindexBitstring","toGindex","bitIndexBigInt","v","toString","length","depth","index","anchor","BigInt","Error","str","Number","padStart","gindex","ERR_INVALID_GINDEX","count","startIndex","i","last","Symbol","iterator","next","done","undefined","gindices","push","bitstring","bit","remainingBitLength","bits","reduce","acc","slice","rightChild"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.gindexChild = exports.gindexParent = exports.gindexSibling = exports.concatGindices = exports.getGindexBits = exports.gindexIterator = exports.getGindicesAtDepth = exports.iterateAtDepth = exports.countToDepth = exports.convertGindexToBitstring = exports.toGindexBitstring = exports.toGindex = exports.bitIndexBigInt = void 0;\nfunction bitIndexBigInt(v) {\n    return v.toString(2).length - 1;\n}\nexports.bitIndexBigInt = bitIndexBigInt;\nfunction toGindex(depth, index) {\n    const anchor = BigInt(1) << BigInt(depth);\n    if (index >= anchor) {\n        throw new Error(`index ${index} too large for depth ${depth}`);\n    }\n    return anchor | index;\n}\nexports.toGindex = toGindex;\nfunction toGindexBitstring(depth, index) {\n    const str = index ? Number(index).toString(2) : \"\";\n    if (str.length > depth) {\n        throw new Error(\"index too large for depth\");\n    }\n    else {\n        return \"1\" + str.padStart(depth, \"0\");\n    }\n}\nexports.toGindexBitstring = toGindexBitstring;\nfunction convertGindexToBitstring(gindex) {\n    if (typeof gindex === \"string\") {\n        if (gindex.length === 0) {\n            throw new Error(ERR_INVALID_GINDEX);\n        }\n        return gindex;\n    }\n    else {\n        if (gindex < 1) {\n            throw new Error(ERR_INVALID_GINDEX);\n        }\n        return gindex.toString(2);\n    }\n}\nexports.convertGindexToBitstring = convertGindexToBitstring;\n// Get the depth (root starting at 0) necessary to cover a subtree of `count` elements.\n// (in out): (0 0), (1 0), (2 1), (3 2), (4 2), (5 3), (6 3), (7 3), (8 3), (9 4)\nfunction countToDepth(count) {\n    if (count <= 1) {\n        return 0;\n    }\n    return (count - BigInt(1)).toString(2).length;\n}\nexports.countToDepth = countToDepth;\n/**\n * Iterate through Gindexes at a certain depth\n */\nfunction iterateAtDepth(depth, startIndex, count) {\n    const anchor = BigInt(1) << BigInt(depth);\n    if (startIndex + count > anchor) {\n        throw new Error(\"Too large for depth\");\n    }\n    let i = toGindex(depth, startIndex);\n    const last = i + count;\n    return {\n        [Symbol.iterator]() {\n            return {\n                next() {\n                    if (i < last) {\n                        const value = i;\n                        i++;\n                        return { done: false, value };\n                    }\n                    else {\n                        return { done: true, value: undefined };\n                    }\n                },\n            };\n        },\n    };\n}\nexports.iterateAtDepth = iterateAtDepth;\n/**\n * Return Gindexes at a certain depth\n */\nfunction getGindicesAtDepth(depth, startIndex, count) {\n    const anchor = BigInt(1) << BigInt(depth);\n    if (startIndex + count > anchor) {\n        throw new Error(\"Too large for depth\");\n    }\n    let gindex = toGindex(depth, BigInt(startIndex));\n    const gindices = [];\n    for (let i = 0; i < count; i++) {\n        gindices.push(gindex++);\n    }\n    return gindices;\n}\nexports.getGindicesAtDepth = getGindicesAtDepth;\nconst ERR_INVALID_GINDEX = \"Invalid gindex\";\nfunction gindexIterator(gindex) {\n    let bitstring;\n    if (typeof gindex === \"string\") {\n        if (!gindex.length) {\n            throw new Error(ERR_INVALID_GINDEX);\n        }\n        bitstring = gindex;\n    }\n    else {\n        if (gindex < 1) {\n            throw new Error(ERR_INVALID_GINDEX);\n        }\n        bitstring = gindex.toString(2);\n    }\n    let i = 1;\n    const next = () => {\n        if (i === bitstring.length) {\n            return { done: true, value: undefined };\n        }\n        const bit = Number(bitstring[i]);\n        i++;\n        return { done: false, value: bit };\n    };\n    return {\n        [Symbol.iterator]() {\n            return { next };\n        },\n        remainingBitLength() {\n            return bitstring.length - i;\n        },\n    };\n}\nexports.gindexIterator = gindexIterator;\nfunction getGindexBits(gindex) {\n    let bitstring;\n    if (typeof gindex === \"string\") {\n        if (!gindex.length) {\n            throw new Error(ERR_INVALID_GINDEX);\n        }\n        bitstring = gindex;\n    }\n    else {\n        if (gindex < 1) {\n            throw new Error(ERR_INVALID_GINDEX);\n        }\n        bitstring = gindex.toString(2);\n    }\n    const bits = [];\n    for (let i = 1; i < bitstring.length; i++) {\n        bits.push(Number(bitstring[i]));\n    }\n    return bits;\n}\nexports.getGindexBits = getGindexBits;\n/**\n * Concatenate Generalized Indices\n * Given generalized indices i1 for A -> B, i2 for B -> C .... i_n for Y -> Z, returns\n * the generalized index for A -> Z.\n */\nfunction concatGindices(gindices) {\n    return BigInt(gindices.reduce((acc, gindex) => acc + gindex.toString(2).slice(1), \"0b1\"));\n}\nexports.concatGindices = concatGindices;\nfunction gindexSibling(gindex) {\n    return gindex ^ BigInt(1);\n}\nexports.gindexSibling = gindexSibling;\nfunction gindexParent(gindex) {\n    return gindex / BigInt(2);\n}\nexports.gindexParent = gindexParent;\nfunction gindexChild(gindex, rightChild) {\n    return gindex * BigInt(2) + BigInt(rightChild);\n}\nexports.gindexChild = gindexChild;\n"]},"metadata":{},"sourceType":"script"}