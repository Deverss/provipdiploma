{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ByteVectorType = void 0;\n\nconst persistent_merkle_tree_1 = require(\"@chainsafe/persistent-merkle-tree\");\n\nconst merkleize_1 = require(\"../util/merkleize\");\n\nconst named_1 = require(\"../util/named\");\n\nconst byteArray_1 = require(\"./byteArray\");\n/* eslint-disable @typescript-eslint/member-ordering */\n\n/**\n * ByteVector: Immutable alias of Vector[byte, N]\n * - Notation: `ByteVector[N]`\n * - Value: `Uint8Array`\n * - View: `Uint8Array`\n * - ViewDU: `Uint8Array`\n *\n * ByteVector is an immutable value which is represented by a Uint8Array for memory efficiency and performance.\n * Note: Consumers of this type MUST never mutate the `Uint8Array` representation of a ByteVector.\n *\n * For a `ByteVectorType` with mutability, use `VectorBasicType(byteType)`\n */\n\n\nclass ByteVectorType extends byteArray_1.ByteArrayType {\n  constructor(lengthBytes, opts) {\n    super();\n    this.lengthBytes = lengthBytes;\n    this.isList = false;\n    if (lengthBytes === 0) throw Error(\"Vector length must be > 0\");\n    this.typeName = (opts === null || opts === void 0 ? void 0 : opts.typeName) ?? `ByteVector[${lengthBytes}]`;\n    this.maxChunkCount = Math.ceil(this.lengthBytes / 32);\n    this.chunkDepth = merkleize_1.maxChunksToDepth(this.maxChunkCount);\n    this.depth = this.chunkDepth;\n    this.fixedSize = this.lengthBytes;\n    this.minSize = this.fixedSize;\n    this.maxSize = this.fixedSize;\n  }\n\n  static named(limitBits, opts) {\n    return new (named_1.namedClass(ByteVectorType, opts.typeName))(limitBits, opts);\n  } // Views: inherited from ByteArrayType\n  // Serialization + deserialization\n\n\n  value_serializedSize() {\n    return this.fixedSize;\n  } // value_* inherited from ByteArrayType\n\n\n  tree_serializedSize() {\n    return this.fixedSize;\n  }\n\n  tree_serializeToBytes(output, offset, node) {\n    const nodes = persistent_merkle_tree_1.getNodesAtDepth(node, this.chunkDepth, 0, this.maxChunkCount);\n    persistent_merkle_tree_1.packedNodeRootsToBytes(output.dataView, offset, this.fixedSize, nodes);\n    return offset + this.fixedSize;\n  }\n\n  tree_deserializeFromBytes(data, start, end) {\n    this.assertValidSize(end - start);\n    return persistent_merkle_tree_1.packedRootsBytesToNode(this.chunkDepth, data.dataView, start, end);\n  }\n\n  tree_getByteLen() {\n    return this.lengthBytes;\n  } // Merkleization: inherited from ByteArrayType\n  // Proofs: inherited from BitArrayType\n  // JSON: inherited from ByteArrayType\n\n\n  assertValidSize(size) {\n    if (size !== this.lengthBytes) {\n      throw Error(`ByteVector invalid size ${size} expected ${this.lengthBytes}`);\n    }\n  }\n\n}\n\nexports.ByteVectorType = ByteVectorType;","map":{"version":3,"sources":["../../src/type/byteVector.ts"],"names":[],"mappings":";;;;;;;AAAA,MAAA,wBAAA,GAAA,OAAA,CAAA,mCAAA,CAAA;;AACA,MAAA,WAAA,GAAA,OAAA,CAAA,mBAAA,CAAA;;AAEA,MAAA,OAAA,GAAA,OAAA,CAAA,eAAA,CAAA;;AAEA,MAAA,WAAA,GAAA,OAAA,CAAA,aAAA,CAAA;AAQA;;AAEA;;;;;;;;;;;AAWG;;;AACH,MAAa,cAAb,SAAoC,WAAA,CAAA,aAApC,CAAiD;AAW/C,EAAA,WAAA,CAAqB,WAArB,EAA0C,IAA1C,EAAkE;AAChE;AADmB,SAAA,WAAA,GAAA,WAAA;AAFZ,SAAA,MAAA,GAAS,KAAT;AAKP,QAAI,WAAW,KAAK,CAApB,EAAuB,MAAM,KAAK,CAAC,2BAAD,CAAX;AAEvB,SAAK,QAAL,GAAgB,CAAA,IAAI,SAAJ,IAAA,IAAI,WAAJ,YAAA,IAAI,CAAE,QAAN,KAAkB,cAAc,WAAW,GAA3D;AACA,SAAK,aAAL,GAAqB,IAAI,CAAC,IAAL,CAAU,KAAK,WAAL,GAAmB,EAA7B,CAArB;AACA,SAAK,UAAL,GAAkB,WAAA,CAAA,gBAAA,CAAiB,KAAK,aAAtB,CAAlB;AACA,SAAK,KAAL,GAAa,KAAK,UAAlB;AACA,SAAK,SAAL,GAAiB,KAAK,WAAtB;AACA,SAAK,OAAL,GAAe,KAAK,SAApB;AACA,SAAK,OAAL,GAAe,KAAK,SAApB;AACD;;AAEW,SAAL,KAAK,CAAC,SAAD,EAAoB,IAApB,EAAgE;AAC1E,WAAO,KAAK,OAAA,CAAA,UAAA,CAAW,cAAX,EAA2B,IAAI,CAAC,QAAhC,CAAL,EAAgD,SAAhD,EAA2D,IAA3D,CAAP;AACD,GA3B8C,CA6B/C;AAEA;;;AAEA,EAAA,oBAAoB,GAAA;AAClB,WAAO,KAAK,SAAZ;AACD,GAnC8C,CAqC/C;;;AAEA,EAAA,mBAAmB,GAAA;AACjB,WAAO,KAAK,SAAZ;AACD;;AAED,EAAA,qBAAqB,CAAC,MAAD,EAAoB,MAApB,EAAoC,IAApC,EAA8C;AACjE,UAAM,KAAK,GAAG,wBAAA,CAAA,eAAA,CAAgB,IAAhB,EAAsB,KAAK,UAA3B,EAAuC,CAAvC,EAA0C,KAAK,aAA/C,CAAd;AACA,IAAA,wBAAA,CAAA,sBAAA,CAAuB,MAAM,CAAC,QAA9B,EAAwC,MAAxC,EAAgD,KAAK,SAArD,EAAgE,KAAhE;AACA,WAAO,MAAM,GAAG,KAAK,SAArB;AACD;;AAED,EAAA,yBAAyB,CAAC,IAAD,EAAkB,KAAlB,EAAiC,GAAjC,EAA4C;AACnE,SAAK,eAAL,CAAqB,GAAG,GAAG,KAA3B;AACA,WAAO,wBAAA,CAAA,sBAAA,CAAuB,KAAK,UAA5B,EAAwC,IAAI,CAAC,QAA7C,EAAuD,KAAvD,EAA8D,GAA9D,CAAP;AACD;;AAED,EAAA,eAAe,GAAA;AACb,WAAO,KAAK,WAAZ;AACD,GAxD8C,CA0D/C;AAEA;AAEA;;;AAEU,EAAA,eAAe,CAAC,IAAD,EAAa;AACpC,QAAI,IAAI,KAAK,KAAK,WAAlB,EAA+B;AAC7B,YAAM,KAAK,CAAC,2BAA2B,IAAI,aAAa,KAAK,WAAW,EAA7D,CAAX;AACD;AACF;;AApE8C;;AAAjD,OAAA,CAAA,cAAA,GAAA,cAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ByteVectorType = void 0;\nconst persistent_merkle_tree_1 = require(\"@chainsafe/persistent-merkle-tree\");\nconst merkleize_1 = require(\"../util/merkleize\");\nconst named_1 = require(\"../util/named\");\nconst byteArray_1 = require(\"./byteArray\");\n/* eslint-disable @typescript-eslint/member-ordering */\n/**\n * ByteVector: Immutable alias of Vector[byte, N]\n * - Notation: `ByteVector[N]`\n * - Value: `Uint8Array`\n * - View: `Uint8Array`\n * - ViewDU: `Uint8Array`\n *\n * ByteVector is an immutable value which is represented by a Uint8Array for memory efficiency and performance.\n * Note: Consumers of this type MUST never mutate the `Uint8Array` representation of a ByteVector.\n *\n * For a `ByteVectorType` with mutability, use `VectorBasicType(byteType)`\n */\nclass ByteVectorType extends byteArray_1.ByteArrayType {\n    constructor(lengthBytes, opts) {\n        super();\n        this.lengthBytes = lengthBytes;\n        this.isList = false;\n        if (lengthBytes === 0)\n            throw Error(\"Vector length must be > 0\");\n        this.typeName = opts?.typeName ?? `ByteVector[${lengthBytes}]`;\n        this.maxChunkCount = Math.ceil(this.lengthBytes / 32);\n        this.chunkDepth = merkleize_1.maxChunksToDepth(this.maxChunkCount);\n        this.depth = this.chunkDepth;\n        this.fixedSize = this.lengthBytes;\n        this.minSize = this.fixedSize;\n        this.maxSize = this.fixedSize;\n    }\n    static named(limitBits, opts) {\n        return new (named_1.namedClass(ByteVectorType, opts.typeName))(limitBits, opts);\n    }\n    // Views: inherited from ByteArrayType\n    // Serialization + deserialization\n    value_serializedSize() {\n        return this.fixedSize;\n    }\n    // value_* inherited from ByteArrayType\n    tree_serializedSize() {\n        return this.fixedSize;\n    }\n    tree_serializeToBytes(output, offset, node) {\n        const nodes = persistent_merkle_tree_1.getNodesAtDepth(node, this.chunkDepth, 0, this.maxChunkCount);\n        persistent_merkle_tree_1.packedNodeRootsToBytes(output.dataView, offset, this.fixedSize, nodes);\n        return offset + this.fixedSize;\n    }\n    tree_deserializeFromBytes(data, start, end) {\n        this.assertValidSize(end - start);\n        return persistent_merkle_tree_1.packedRootsBytesToNode(this.chunkDepth, data.dataView, start, end);\n    }\n    tree_getByteLen() {\n        return this.lengthBytes;\n    }\n    // Merkleization: inherited from ByteArrayType\n    // Proofs: inherited from BitArrayType\n    // JSON: inherited from ByteArrayType\n    assertValidSize(size) {\n        if (size !== this.lengthBytes) {\n            throw Error(`ByteVector invalid size ${size} expected ${this.lengthBytes}`);\n        }\n    }\n}\nexports.ByteVectorType = ByteVectorType;\n//# sourceMappingURL=byteVector.js.map"]},"metadata":{},"sourceType":"script"}