{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.UnionType = void 0;\n\nconst persistent_merkle_tree_1 = require(\"@chainsafe/persistent-merkle-tree\");\n\nconst merkleize_1 = require(\"../util/merkleize\");\n\nconst named_1 = require(\"../util/named\");\n\nconst composite_1 = require(\"./composite\");\n\nconst arrayBasic_1 = require(\"./arrayBasic\");\n\nconst none_1 = require(\"./none\");\n\nconst VALUE_GINDEX = BigInt(2);\nconst SELECTOR_GINDEX = BigInt(3);\n/**\n * Union: union type containing one of the given subtypes\n * - Notation: Union[type_0, type_1, ...], e.g. union[None, uint64, uint32]\n */\n\nclass UnionType extends composite_1.CompositeType {\n  constructor(types, opts) {\n    super();\n    this.types = types;\n    this.depth = 1;\n    this.maxChunkCount = 1;\n    this.fixedSize = null;\n    this.isList = true;\n    this.isViewMutable = true;\n\n    if (types.length >= 128) {\n      throw Error(\"Must have less than 128 types\");\n    }\n\n    if (types.length === 0) {\n      throw Error(\"Must have at least 1 type option\");\n    }\n\n    if (types[0] instanceof none_1.NoneType && types.length < 2) {\n      throw Error(\"Must have at least 2 type options if the first is None\");\n    }\n\n    for (let i = 1; i < types.length; i++) {\n      if (types[i] instanceof none_1.NoneType) {\n        throw Error(\"None may only be the first option\");\n      }\n    }\n\n    this.typeName = (opts === null || opts === void 0 ? void 0 : opts.typeName) ?? `Union[${types.map(t => t.typeName).join(\",\")}]`;\n    const minLens = [];\n    const maxLens = [];\n\n    for (const _type of types) {\n      minLens.push(_type.minSize);\n      maxLens.push(_type.maxSize);\n    }\n\n    this.minSize = 1 + Math.min(...minLens);\n    this.maxSize = 1 + Math.max(...maxLens);\n    this.maxSelector = this.types.length - 1;\n  }\n\n  static named(types, opts) {\n    return new (named_1.namedClass(UnionType, opts.typeName))(types, opts);\n  }\n\n  defaultValue() {\n    return {\n      selector: 0,\n      value: this.types[0].defaultValue()\n    };\n  }\n\n  getView(tree) {\n    return this.tree_toValue(tree.rootNode);\n  }\n\n  getViewDU(node) {\n    return this.tree_toValue(node);\n  }\n\n  cacheOfViewDU() {\n    return;\n  }\n\n  commitView(view) {\n    return this.value_toTree(view);\n  }\n\n  commitViewDU(view) {\n    return this.value_toTree(view);\n  }\n\n  value_serializedSize(value) {\n    return 1 + this.types[value.selector].value_serializedSize(value.value);\n  }\n\n  value_serializeToBytes(output, offset, value) {\n    output.uint8Array[offset] = value.selector;\n    return this.types[value.selector].value_serializeToBytes(output, offset + 1, value.value);\n  }\n\n  value_deserializeFromBytes(data, start, end) {\n    const selector = data.uint8Array[start];\n\n    if (selector > this.maxSelector) {\n      throw Error(`Invalid selector ${selector}`);\n    }\n\n    return {\n      selector,\n      value: this.types[selector].value_deserializeFromBytes(data, start + 1, end)\n    };\n  }\n\n  tree_serializedSize(node) {\n    const selector = arrayBasic_1.getLengthFromRootNode(node);\n    const valueNode = node.left;\n    return 1 + this.types[selector].value_serializedSize(valueNode);\n  }\n\n  tree_serializeToBytes(output, offset, node) {\n    const selector = arrayBasic_1.getLengthFromRootNode(node);\n    const valueNode = node.left;\n    output.uint8Array[offset] = selector;\n    return this.types[selector].tree_serializeToBytes(output, offset + 1, valueNode);\n  }\n\n  tree_deserializeFromBytes(data, start, end) {\n    const selector = data.uint8Array[start];\n\n    if (selector > this.maxSelector) {\n      throw Error(`Invalid selector ${selector}`);\n    }\n\n    const valueNode = this.types[selector].tree_deserializeFromBytes(data, start + 1, end);\n    return arrayBasic_1.addLengthNode(valueNode, selector);\n  } // Merkleization\n\n\n  hashTreeRoot(value) {\n    return merkleize_1.mixInLength(super.hashTreeRoot(value), value.selector);\n  }\n\n  getRoots(value) {\n    const valueRoot = this.types[value.selector].hashTreeRoot(value.value);\n    return [valueRoot];\n  } // Proofs\n\n\n  getPropertyGindex(prop) {\n    switch (prop) {\n      case \"value\":\n        return VALUE_GINDEX;\n\n      case \"selector\":\n        return SELECTOR_GINDEX;\n\n      default:\n        throw new Error(`Invalid Union type property ${prop}`);\n    }\n  }\n\n  getPropertyType() {\n    // a Union has multiple types\n    throw new Error(\"Not applicable for Union type\");\n  }\n\n  getIndexProperty(index) {\n    if (index === 0) return \"value\";\n    if (index === 1) return \"selector\";\n    throw Error(\"Union index of out bounds\");\n  }\n\n  tree_getLeafGindices(rootGindex, rootNode) {\n    if (!rootNode) {\n      throw Error(\"rootNode required\");\n    }\n\n    const gindices = [persistent_merkle_tree_1.concatGindices([rootGindex, SELECTOR_GINDEX])];\n    const selector = arrayBasic_1.getLengthFromRootNode(rootNode);\n    const type = this.types[selector];\n    const extendedFieldGindex = persistent_merkle_tree_1.concatGindices([rootGindex, VALUE_GINDEX]);\n\n    if (composite_1.isCompositeType(type)) {\n      gindices.push(...type.tree_getLeafGindices(extendedFieldGindex, persistent_merkle_tree_1.getNode(rootNode, VALUE_GINDEX)));\n    } else {\n      gindices.push(extendedFieldGindex);\n    }\n\n    return gindices;\n  } // JSON\n\n\n  fromJson(json) {\n    if (typeof json !== \"object\") {\n      throw new Error(\"JSON must be of type object\");\n    }\n\n    const union = json;\n\n    if (typeof union.selector !== \"number\") {\n      throw new Error(\"Invalid JSON Union selector must be number\");\n    }\n\n    const type = this.types[union.selector];\n\n    if (!type) {\n      throw new Error(\"Invalid JSON Union selector out of range\");\n    }\n\n    return {\n      selector: union.selector,\n      value: type.toJson(union.value)\n    };\n  }\n\n  toJson(value) {\n    return {\n      selector: value.selector,\n      value: this.types[value.selector].toJson(value.value)\n    };\n  }\n\n  clone(value) {\n    return {\n      selector: value.selector,\n      value: this.types[value.selector].clone(value.value)\n    };\n  }\n\n  equals(a, b) {\n    if (a.selector !== b.selector) {\n      return false;\n    }\n\n    return this.types[a.selector].equals(a.value, b.value);\n  }\n\n}\n\nexports.UnionType = UnionType;","map":{"version":3,"sources":["../../src/type/union.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.UnionType = void 0;\nconst persistent_merkle_tree_1 = require(\"@chainsafe/persistent-merkle-tree\");\nconst merkleize_1 = require(\"../util/merkleize\");\nconst named_1 = require(\"../util/named\");\nconst composite_1 = require(\"./composite\");\nconst arrayBasic_1 = require(\"./arrayBasic\");\nconst none_1 = require(\"./none\");\nconst VALUE_GINDEX = BigInt(2);\nconst SELECTOR_GINDEX = BigInt(3);\n/**\n * Union: union type containing one of the given subtypes\n * - Notation: Union[type_0, type_1, ...], e.g. union[None, uint64, uint32]\n */\nclass UnionType extends composite_1.CompositeType {\n    constructor(types, opts) {\n        super();\n        this.types = types;\n        this.depth = 1;\n        this.maxChunkCount = 1;\n        this.fixedSize = null;\n        this.isList = true;\n        this.isViewMutable = true;\n        if (types.length >= 128) {\n            throw Error(\"Must have less than 128 types\");\n        }\n        if (types.length === 0) {\n            throw Error(\"Must have at least 1 type option\");\n        }\n        if (types[0] instanceof none_1.NoneType && types.length < 2) {\n            throw Error(\"Must have at least 2 type options if the first is None\");\n        }\n        for (let i = 1; i < types.length; i++) {\n            if (types[i] instanceof none_1.NoneType) {\n                throw Error(\"None may only be the first option\");\n            }\n        }\n        this.typeName = opts?.typeName ?? `Union[${types.map((t) => t.typeName).join(\",\")}]`;\n        const minLens = [];\n        const maxLens = [];\n        for (const _type of types) {\n            minLens.push(_type.minSize);\n            maxLens.push(_type.maxSize);\n        }\n        this.minSize = 1 + Math.min(...minLens);\n        this.maxSize = 1 + Math.max(...maxLens);\n        this.maxSelector = this.types.length - 1;\n    }\n    static named(types, opts) {\n        return new (named_1.namedClass(UnionType, opts.typeName))(types, opts);\n    }\n    defaultValue() {\n        return {\n            selector: 0,\n            value: this.types[0].defaultValue(),\n        };\n    }\n    getView(tree) {\n        return this.tree_toValue(tree.rootNode);\n    }\n    getViewDU(node) {\n        return this.tree_toValue(node);\n    }\n    cacheOfViewDU() {\n        return;\n    }\n    commitView(view) {\n        return this.value_toTree(view);\n    }\n    commitViewDU(view) {\n        return this.value_toTree(view);\n    }\n    value_serializedSize(value) {\n        return 1 + this.types[value.selector].value_serializedSize(value.value);\n    }\n    value_serializeToBytes(output, offset, value) {\n        output.uint8Array[offset] = value.selector;\n        return this.types[value.selector].value_serializeToBytes(output, offset + 1, value.value);\n    }\n    value_deserializeFromBytes(data, start, end) {\n        const selector = data.uint8Array[start];\n        if (selector > this.maxSelector) {\n            throw Error(`Invalid selector ${selector}`);\n        }\n        return {\n            selector,\n            value: this.types[selector].value_deserializeFromBytes(data, start + 1, end),\n        };\n    }\n    tree_serializedSize(node) {\n        const selector = arrayBasic_1.getLengthFromRootNode(node);\n        const valueNode = node.left;\n        return 1 + this.types[selector].value_serializedSize(valueNode);\n    }\n    tree_serializeToBytes(output, offset, node) {\n        const selector = arrayBasic_1.getLengthFromRootNode(node);\n        const valueNode = node.left;\n        output.uint8Array[offset] = selector;\n        return this.types[selector].tree_serializeToBytes(output, offset + 1, valueNode);\n    }\n    tree_deserializeFromBytes(data, start, end) {\n        const selector = data.uint8Array[start];\n        if (selector > this.maxSelector) {\n            throw Error(`Invalid selector ${selector}`);\n        }\n        const valueNode = this.types[selector].tree_deserializeFromBytes(data, start + 1, end);\n        return arrayBasic_1.addLengthNode(valueNode, selector);\n    }\n    // Merkleization\n    hashTreeRoot(value) {\n        return merkleize_1.mixInLength(super.hashTreeRoot(value), value.selector);\n    }\n    getRoots(value) {\n        const valueRoot = this.types[value.selector].hashTreeRoot(value.value);\n        return [valueRoot];\n    }\n    // Proofs\n    getPropertyGindex(prop) {\n        switch (prop) {\n            case \"value\":\n                return VALUE_GINDEX;\n            case \"selector\":\n                return SELECTOR_GINDEX;\n            default:\n                throw new Error(`Invalid Union type property ${prop}`);\n        }\n    }\n    getPropertyType() {\n        // a Union has multiple types\n        throw new Error(\"Not applicable for Union type\");\n    }\n    getIndexProperty(index) {\n        if (index === 0)\n            return \"value\";\n        if (index === 1)\n            return \"selector\";\n        throw Error(\"Union index of out bounds\");\n    }\n    tree_getLeafGindices(rootGindex, rootNode) {\n        if (!rootNode) {\n            throw Error(\"rootNode required\");\n        }\n        const gindices = [persistent_merkle_tree_1.concatGindices([rootGindex, SELECTOR_GINDEX])];\n        const selector = arrayBasic_1.getLengthFromRootNode(rootNode);\n        const type = this.types[selector];\n        const extendedFieldGindex = persistent_merkle_tree_1.concatGindices([rootGindex, VALUE_GINDEX]);\n        if (composite_1.isCompositeType(type)) {\n            gindices.push(...type.tree_getLeafGindices(extendedFieldGindex, persistent_merkle_tree_1.getNode(rootNode, VALUE_GINDEX)));\n        }\n        else {\n            gindices.push(extendedFieldGindex);\n        }\n        return gindices;\n    }\n    // JSON\n    fromJson(json) {\n        if (typeof json !== \"object\") {\n            throw new Error(\"JSON must be of type object\");\n        }\n        const union = json;\n        if (typeof union.selector !== \"number\") {\n            throw new Error(\"Invalid JSON Union selector must be number\");\n        }\n        const type = this.types[union.selector];\n        if (!type) {\n            throw new Error(\"Invalid JSON Union selector out of range\");\n        }\n        return {\n            selector: union.selector,\n            value: type.toJson(union.value),\n        };\n    }\n    toJson(value) {\n        return {\n            selector: value.selector,\n            value: this.types[value.selector].toJson(value.value),\n        };\n    }\n    clone(value) {\n        return {\n            selector: value.selector,\n            value: this.types[value.selector].clone(value.value),\n        };\n    }\n    equals(a, b) {\n        if (a.selector !== b.selector) {\n            return false;\n        }\n        return this.types[a.selector].equals(a.value, b.value);\n    }\n}\nexports.UnionType = UnionType;\n//# sourceMappingURL=union.js.map"]},"metadata":{},"sourceType":"script"}