{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.BooleanType = void 0;\n\nconst persistent_merkle_tree_1 = require(\"@chainsafe/persistent-merkle-tree\");\n\nconst named_1 = require(\"../util/named\");\n\nconst basic_1 = require(\"./basic\");\n/**\n * Boolean: True or False\n * - Notation: `boolean`\n */\n\n\nclass BooleanType extends basic_1.BasicType {\n  constructor(opts) {\n    super();\n    this.byteLength = 1;\n    this.itemsPerChunk = 32;\n    this.fixedSize = 1;\n    this.minSize = 1;\n    this.maxSize = 1;\n    this.typeName = (opts === null || opts === void 0 ? void 0 : opts.typeName) ?? \"boolean\";\n  }\n\n  static named(opts) {\n    return new (named_1.namedClass(BooleanType, opts.typeName))(opts);\n  }\n\n  defaultValue() {\n    return false;\n  } // Serialization + deserialization\n\n\n  value_serializeToBytes(output, offset, value) {\n    output.uint8Array[offset] = value ? 1 : 0;\n    return offset + 1;\n  }\n\n  value_deserializeFromBytes(data, start, end) {\n    this.assertValidSize(end - start);\n\n    switch (data.uint8Array[start]) {\n      case 1:\n        return true;\n\n      case 0:\n        return false;\n\n      default:\n        throw new Error(`Boolean: invalid value: ${data.uint8Array[start]}`);\n    }\n  }\n\n  tree_serializeToBytes(output, offset, node) {\n    // TODO: Assumes LeafNode has 4 byte uints are primary unit\n    output.uint8Array[offset] = node.getUint(4, 0);\n    return offset + 1;\n  }\n\n  tree_deserializeFromBytes(data, start, end) {\n    this.assertValidSize(end - start);\n    const value = data.uint8Array[start];\n\n    if (value > 1) {\n      throw Error(`Boolean: invalid value ${value}`);\n    }\n\n    return persistent_merkle_tree_1.LeafNode.fromUint32(value);\n  } // Fast tree opts\n\n\n  tree_getFromNode(leafNode) {\n    return leafNode.getUint(4, 0) === 1;\n  }\n\n  tree_setToNode(leafNode, value) {\n    leafNode.setUint(4, 0, value ? 1 : 0);\n  }\n\n  tree_getFromPackedNode(leafNode, index) {\n    const offsetBytes = index % this.itemsPerChunk;\n    return leafNode.getUint(1, offsetBytes) !== 0;\n  }\n\n  tree_setToPackedNode(leafNode, index, value) {\n    const offsetBytes = index % this.itemsPerChunk;\n    leafNode.setUint(1, offsetBytes, value ? 1 : 0);\n  } // JSON\n\n\n  fromJson(json) {\n    if (typeof json !== \"boolean\") {\n      throw Error(`JSON invalid type ${typeof json} expected boolean`);\n    }\n\n    return json;\n  }\n\n  toJson(value) {\n    return value;\n  }\n\n}\n\nexports.BooleanType = BooleanType;","map":{"version":3,"sources":["../../src/type/boolean.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BooleanType = void 0;\nconst persistent_merkle_tree_1 = require(\"@chainsafe/persistent-merkle-tree\");\nconst named_1 = require(\"../util/named\");\nconst basic_1 = require(\"./basic\");\n/**\n * Boolean: True or False\n * - Notation: `boolean`\n */\nclass BooleanType extends basic_1.BasicType {\n    constructor(opts) {\n        super();\n        this.byteLength = 1;\n        this.itemsPerChunk = 32;\n        this.fixedSize = 1;\n        this.minSize = 1;\n        this.maxSize = 1;\n        this.typeName = opts?.typeName ?? \"boolean\";\n    }\n    static named(opts) {\n        return new (named_1.namedClass(BooleanType, opts.typeName))(opts);\n    }\n    defaultValue() {\n        return false;\n    }\n    // Serialization + deserialization\n    value_serializeToBytes(output, offset, value) {\n        output.uint8Array[offset] = value ? 1 : 0;\n        return offset + 1;\n    }\n    value_deserializeFromBytes(data, start, end) {\n        this.assertValidSize(end - start);\n        switch (data.uint8Array[start]) {\n            case 1:\n                return true;\n            case 0:\n                return false;\n            default:\n                throw new Error(`Boolean: invalid value: ${data.uint8Array[start]}`);\n        }\n    }\n    tree_serializeToBytes(output, offset, node) {\n        // TODO: Assumes LeafNode has 4 byte uints are primary unit\n        output.uint8Array[offset] = node.getUint(4, 0);\n        return offset + 1;\n    }\n    tree_deserializeFromBytes(data, start, end) {\n        this.assertValidSize(end - start);\n        const value = data.uint8Array[start];\n        if (value > 1) {\n            throw Error(`Boolean: invalid value ${value}`);\n        }\n        return persistent_merkle_tree_1.LeafNode.fromUint32(value);\n    }\n    // Fast tree opts\n    tree_getFromNode(leafNode) {\n        return leafNode.getUint(4, 0) === 1;\n    }\n    tree_setToNode(leafNode, value) {\n        leafNode.setUint(4, 0, value ? 1 : 0);\n    }\n    tree_getFromPackedNode(leafNode, index) {\n        const offsetBytes = index % this.itemsPerChunk;\n        return leafNode.getUint(1, offsetBytes) !== 0;\n    }\n    tree_setToPackedNode(leafNode, index, value) {\n        const offsetBytes = index % this.itemsPerChunk;\n        leafNode.setUint(1, offsetBytes, value ? 1 : 0);\n    }\n    // JSON\n    fromJson(json) {\n        if (typeof json !== \"boolean\") {\n            throw Error(`JSON invalid type ${typeof json} expected boolean`);\n        }\n        return json;\n    }\n    toJson(value) {\n        return value;\n    }\n}\nexports.BooleanType = BooleanType;\n//# sourceMappingURL=boolean.js.map"]},"metadata":{},"sourceType":"script"}