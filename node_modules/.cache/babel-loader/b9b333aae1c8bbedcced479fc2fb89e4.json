{"ast":null,"code":"import OpenLogin, { OPENLOGIN_NETWORK, UX_MODE, getHashQueryParams, SUPPORTED_KEY_CURVES } from '@toruslabs/openlogin';\nimport _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport { BaseAdapter, WALLET_ADAPTERS, ADAPTER_NAMESPACES, ADAPTER_CATEGORY, ADAPTER_STATUS, CHAIN_NAMESPACES, WalletInitializationError, log, ADAPTER_EVENTS, WalletLoginError, Web3AuthError } from '@web3auth/base';\nimport { CommonPrivateKeyProvider } from '@web3auth/base-provider';\nimport merge from 'lodash.merge';\n\nconst getOpenloginDefaultOptions = () => {\n  return {\n    adapterSettings: {\n      network: OPENLOGIN_NETWORK.MAINNET,\n      clientId: \"\",\n      uxMode: UX_MODE.POPUP\n    },\n    loginSettings: {}\n  };\n};\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n}\n\nclass OpenloginAdapter extends BaseAdapter {\n  constructor() {\n    let params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super(params);\n\n    _defineProperty(this, \"name\", WALLET_ADAPTERS.OPENLOGIN);\n\n    _defineProperty(this, \"adapterNamespace\", ADAPTER_NAMESPACES.MULTICHAIN);\n\n    _defineProperty(this, \"type\", ADAPTER_CATEGORY.IN_APP);\n\n    _defineProperty(this, \"openloginInstance\", null);\n\n    _defineProperty(this, \"status\", ADAPTER_STATUS.NOT_READY);\n\n    _defineProperty(this, \"currentChainNamespace\", CHAIN_NAMESPACES.EIP155);\n\n    _defineProperty(this, \"openloginOptions\", void 0);\n\n    _defineProperty(this, \"loginSettings\", {\n      loginProvider: \"\"\n    });\n\n    _defineProperty(this, \"privKeyProvider\", null);\n\n    this.setAdapterSettings(_objectSpread(_objectSpread({}, params.adapterSettings), {}, {\n      chainConfig: params.chainConfig,\n      clientId: params.clientId || \"\",\n      sessionTime: params.sessionTime,\n      web3AuthNetwork: params.web3AuthNetwork,\n      useCoreKitKey: params.useCoreKitKey\n    }));\n    this.loginSettings = params.loginSettings || {\n      loginProvider: \"\"\n    };\n  }\n\n  get chainConfigProxy() {\n    return this.chainConfig ? _objectSpread({}, this.chainConfig) : null;\n  }\n\n  get provider() {\n    var _this$privKeyProvider;\n\n    return ((_this$privKeyProvider = this.privKeyProvider) === null || _this$privKeyProvider === void 0 ? void 0 : _this$privKeyProvider.provider) || null;\n  }\n\n  set provider(_) {\n    throw new Error(\"Not implemented\");\n  }\n\n  async init(options) {\n    super.checkInitializationRequirements();\n    if (!this.clientId) throw WalletInitializationError.invalidParams(\"clientId is required before openlogin's initialization\");\n    if (!this.openloginOptions) throw WalletInitializationError.invalidParams(\"openloginOptions is required before openlogin's initialization\");\n    let isRedirectResult = false;\n\n    if (this.openloginOptions.uxMode === UX_MODE.REDIRECT || this.openloginOptions.uxMode === UX_MODE.SESSIONLESS_REDIRECT) {\n      const redirectResult = getHashQueryParams();\n\n      if (Object.keys(redirectResult).length > 0 && redirectResult._pid) {\n        isRedirectResult = true;\n      }\n    }\n\n    this.openloginOptions = _objectSpread(_objectSpread({}, this.openloginOptions), {}, {\n      replaceUrlOnRedirect: isRedirectResult\n    });\n    this.openloginInstance = new OpenLogin(_objectSpread(_objectSpread({}, this.openloginOptions), {}, {\n      clientId: this.clientId,\n      network: this.openloginOptions.network || this.web3AuthNetwork || OPENLOGIN_NETWORK.MAINNET\n    }));\n    log.debug(\"initializing openlogin adapter init\");\n    await this.openloginInstance.init();\n    this.status = ADAPTER_STATUS.READY;\n    this.emit(ADAPTER_EVENTS.READY, WALLET_ADAPTERS.OPENLOGIN);\n\n    try {\n      log.debug(\"initializing openlogin adapter\");\n\n      const finalPrivKey = this._getFinalPrivKey(); // connect only if it is redirect result or if connect (adapter is cached/already connected in same session) is true\n\n\n      if (finalPrivKey && (options.autoConnect || isRedirectResult)) {\n        this.rehydrated = true;\n        await this.connect();\n      }\n    } catch (error) {\n      log.error(\"Failed to connect with cached openlogin provider\", error);\n      this.emit(\"ERRORED\", error);\n    }\n  }\n\n  async connect() {\n    let params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n      loginProvider: \"\"\n    };\n    super.checkConnectionRequirements();\n    this.status = ADAPTER_STATUS.CONNECTING;\n    this.emit(ADAPTER_EVENTS.CONNECTING, _objectSpread(_objectSpread({}, params), {}, {\n      adapter: WALLET_ADAPTERS.OPENLOGIN\n    }));\n\n    try {\n      await this.connectWithProvider(params);\n      return this.provider;\n    } catch (error) {\n      log.error(\"Failed to connect with openlogin provider\", error); // ready again to be connected\n\n      this.status = ADAPTER_STATUS.READY;\n      this.emit(ADAPTER_EVENTS.ERRORED, error);\n\n      if (error !== null && error !== void 0 && error.message.includes(\"user closed popup\")) {\n        throw WalletLoginError.popupClosed();\n      } else if (error instanceof Web3AuthError) {\n        throw error;\n      }\n\n      throw WalletLoginError.connectionError(\"Failed to login with openlogin\");\n    }\n  }\n\n  async disconnect() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n      cleanup: false\n    };\n    if (this.status !== ADAPTER_STATUS.CONNECTED) throw WalletLoginError.notConnectedError(\"Not connected with wallet\");\n    if (!this.openloginInstance) throw WalletInitializationError.notReady(\"openloginInstance is not ready\");\n    await this.openloginInstance.logout();\n\n    if (options.cleanup) {\n      this.status = ADAPTER_STATUS.NOT_READY;\n      this.openloginInstance = null;\n      this.privKeyProvider = null;\n    } else {\n      // ready to be connected again\n      this.status = ADAPTER_STATUS.READY;\n    }\n\n    this.rehydrated = false;\n    this.emit(ADAPTER_EVENTS.DISCONNECTED);\n  }\n\n  async authenticateUser() {\n    if (this.status !== ADAPTER_STATUS.CONNECTED) throw WalletLoginError.notConnectedError(\"Not connected with wallet, Please login/connect first\");\n    const userInfo = await this.getUserInfo();\n    return {\n      idToken: userInfo.idToken\n    };\n  }\n\n  async getUserInfo() {\n    if (this.status !== ADAPTER_STATUS.CONNECTED) throw WalletLoginError.notConnectedError(\"Not connected with wallet\");\n    if (!this.openloginInstance) throw WalletInitializationError.notReady(\"openloginInstance is not ready\");\n    const userInfo = await this.openloginInstance.getUserInfo();\n    return userInfo;\n  } // should be called only before initialization.\n\n\n  setAdapterSettings(adapterSettings) {\n    super.setAdapterSettings(adapterSettings);\n    const defaultOptions = getOpenloginDefaultOptions();\n    log.info(\"setting adapter settings\", adapterSettings);\n    this.openloginOptions = _objectSpread(_objectSpread(_objectSpread({}, defaultOptions.adapterSettings), this.openloginOptions), adapterSettings);\n\n    if (adapterSettings.web3AuthNetwork) {\n      this.openloginOptions.network = adapterSettings.web3AuthNetwork;\n    }\n\n    if (adapterSettings.useCoreKitKey !== undefined) {\n      this.openloginOptions.useCoreKitKey = adapterSettings.useCoreKitKey;\n    }\n  }\n\n  async addChain(chainConfig) {\n    var _this$privKeyProvider2;\n\n    let init = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    super.checkAddChainRequirements(init);\n    (_this$privKeyProvider2 = this.privKeyProvider) === null || _this$privKeyProvider2 === void 0 ? void 0 : _this$privKeyProvider2.addChain(chainConfig);\n    this.addChainConfig(chainConfig);\n  }\n\n  async switchChain(params) {\n    var _this$privKeyProvider3;\n\n    let init = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    super.checkSwitchChainRequirements(params, init);\n    await ((_this$privKeyProvider3 = this.privKeyProvider) === null || _this$privKeyProvider3 === void 0 ? void 0 : _this$privKeyProvider3.switchChain(params));\n    this.setAdapterSettings({\n      chainConfig: this.getChainConfig(params.chainId)\n    });\n  }\n\n  _getFinalPrivKey() {\n    var _this$openloginOption;\n\n    if (!this.openloginInstance) return \"\";\n    let finalPrivKey = this.openloginInstance.privKey; // coreKitKey is available only for custom verifiers by default\n\n    if ((_this$openloginOption = this.openloginOptions) !== null && _this$openloginOption !== void 0 && _this$openloginOption.useCoreKitKey) {\n      if (!this.openloginInstance.coreKitKey) {\n        throw WalletLoginError.coreKitKeyNotFound();\n      }\n\n      finalPrivKey = this.openloginInstance.coreKitKey;\n    }\n\n    return finalPrivKey;\n  }\n\n  async connectWithProvider() {\n    var _params$extraLoginOpt;\n\n    let params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n      loginProvider: \"\"\n    };\n    if (!this.chainConfig) throw WalletInitializationError.invalidParams(\"chainConfig is required before initialization\");\n    if (!this.openloginInstance) throw WalletInitializationError.notReady(\"openloginInstance is not ready\");\n\n    if (this.currentChainNamespace === CHAIN_NAMESPACES.SOLANA) {\n      const {\n        SolanaPrivateKeyProvider\n      } = await import('@web3auth/solana-provider');\n      this.privKeyProvider = new SolanaPrivateKeyProvider({\n        config: {\n          chainConfig: this.chainConfig\n        }\n      });\n    } else if (this.currentChainNamespace === CHAIN_NAMESPACES.EIP155) {\n      const {\n        EthereumPrivateKeyProvider\n      } = await import('@web3auth/ethereum-provider');\n      this.privKeyProvider = new EthereumPrivateKeyProvider({\n        config: {\n          chainConfig: this.chainConfig\n        }\n      });\n    } else if (this.currentChainNamespace === CHAIN_NAMESPACES.OTHER) {\n      this.privKeyProvider = new CommonPrivateKeyProvider();\n    } else {\n      throw new Error(`Invalid chainNamespace: ${this.currentChainNamespace} found while connecting to wallet`);\n    }\n\n    const keyAvailable = this._getFinalPrivKey(); // if not logged in then login\n\n\n    if (!keyAvailable || (_params$extraLoginOpt = params.extraLoginOptions) !== null && _params$extraLoginOpt !== void 0 && _params$extraLoginOpt.id_token) {\n      var _params$extraLoginOpt2;\n\n      if (!this.loginSettings.curve) {\n        this.loginSettings.curve = this.currentChainNamespace === CHAIN_NAMESPACES.SOLANA ? SUPPORTED_KEY_CURVES.ED25519 : SUPPORTED_KEY_CURVES.SECP256K1;\n      }\n\n      if (!params.loginProvider && !this.loginSettings.loginProvider) throw WalletInitializationError.invalidParams(\"loginProvider is required for login\");\n      await this.openloginInstance.login(merge(this.loginSettings, params, {\n        extraLoginOptions: _objectSpread(_objectSpread({}, params.extraLoginOptions || {}), {}, {\n          login_hint: params.login_hint || ((_params$extraLoginOpt2 = params.extraLoginOptions) === null || _params$extraLoginOpt2 === void 0 ? void 0 : _params$extraLoginOpt2.login_hint)\n        })\n      }));\n    }\n\n    let finalPrivKey = this._getFinalPrivKey();\n\n    if (finalPrivKey) {\n      if (this.currentChainNamespace === CHAIN_NAMESPACES.SOLANA) {\n        const {\n          getED25519Key\n        } = await import('@toruslabs/openlogin-ed25519');\n        finalPrivKey = getED25519Key(finalPrivKey).sk.toString(\"hex\");\n      }\n\n      await this.privKeyProvider.setupProvider(finalPrivKey);\n      this.status = ADAPTER_STATUS.CONNECTED;\n      this.emit(ADAPTER_EVENTS.CONNECTED, {\n        adapter: WALLET_ADAPTERS.OPENLOGIN,\n        reconnected: this.rehydrated\n      });\n    }\n  }\n\n}\n\nexport { OpenloginAdapter, getOpenloginDefaultOptions };","map":{"version":3,"sources":["../src/config.ts","../src/openloginAdapter.ts"],"names":["getOpenloginDefaultOptions","adapterSettings","network","OPENLOGIN_NETWORK","MAINNET","clientId","uxMode","UX_MODE","POPUP","loginSettings","OpenloginAdapter","BaseAdapter","WALLET_ADAPTERS","OPENLOGIN","_defineProperty","ADAPTER_NAMESPACES","MULTICHAIN","ADAPTER_CATEGORY","IN_APP","ADAPTER_STATUS","NOT_READY","CHAIN_NAMESPACES","EIP155","loginProvider","constructor","params","setAdapterSettings","chainConfig","sessionTime","web3AuthNetwork","useCoreKitKey","chainConfigProxy","provider","privKeyProvider","_","Error","init","options","checkInitializationRequirements","WalletInitializationError","invalidParams","openloginOptions","isRedirectResult","REDIRECT","SESSIONLESS_REDIRECT","redirectResult","getHashQueryParams","Object","keys","length","_pid","replaceUrlOnRedirect","openloginInstance","OpenLogin","log","debug","status","READY","emit","ADAPTER_EVENTS","finalPrivKey","_getFinalPrivKey","autoConnect","rehydrated","connect","error","checkConnectionRequirements","CONNECTING","adapter","connectWithProvider","ERRORED","message","includes","WalletLoginError","popupClosed","Web3AuthError","connectionError","disconnect","cleanup","CONNECTED","notConnectedError","notReady","logout","DISCONNECTED","authenticateUser","userInfo","getUserInfo","idToken","defaultOptions","info","undefined","addChain","checkAddChainRequirements","addChainConfig","switchChain","checkSwitchChainRequirements","getChainConfig","chainId","privKey","coreKitKey","coreKitKeyNotFound","currentChainNamespace","SOLANA","SolanaPrivateKeyProvider","config","EthereumPrivateKeyProvider","OTHER","CommonPrivateKeyProvider","keyAvailable","extraLoginOptions","id_token","curve","SUPPORTED_KEY_CURVES","ED25519","SECP256K1","login","merge","login_hint","getED25519Key","sk","toString","setupProvider","reconnected"],"mappings":";;;;;;AAIaA,MAAAA,0BAA0B,GAAGA,MAA8B;AACtE,SAAO;AACLC,IAAAA,eAAe,EAAE;AACfC,MAAAA,OAAO,EAAEC,iBAAiB,CAACC,OADZ;AAEfC,MAAAA,QAAQ,EAAE,EAFK;AAGfC,MAAAA,MAAM,EAAEC,OAAO,CAACC;AAHD,KADZ;AAMLC,IAAAA,aAAa,EAAE;AANV,GAAP;AAQF,CATaT;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACiCP,MAAOU,gBAAP,SAAgCC,WAAhC,CAAiE;AAmBrEa,EAAAA,WAAAA,GAAgD;AAAA,QAApCC,MAAAA,GAAAA,SAAAA,CAAAA,MAAAA,GAAAA,CAAAA,IAAAA,SAAAA,CAAAA,CAAAA,CAAAA,KAAAA,SAAAA,GAAAA,SAAAA,CAAAA,CAAAA,CAAAA,GAAkC,EAAE;AAC9C,UAAMA,MAAN;;AAAcX,IAAAA,eAAAA,CAAAA,IAAAA,EAAAA,MAAAA,EAnBQF,eAAe,CAACC,SAmBxBC,CAAAA;;AAnBiCA,IAAAA,eAAAA,CAAAA,IAAAA,EAAAA,kBAAAA,EAECC,kBAAkB,CAACC,UAFpBF,CAAAA;;AAE8BA,IAAAA,eAAAA,CAAAA,IAAAA,EAAAA,MAAAA,EAExCG,gBAAgB,CAACC,MAFuBJ,CAAAA;;AAEjBA,IAAAA,eAAAA,CAAAA,IAAAA,EAAAA,mBAAAA,EAEjB,IAFiBA,CAAAA;;AAEbA,IAAAA,eAAAA,CAAAA,IAAAA,EAAAA,QAAAA,EAEZK,cAAc,CAACC,SAFHN,CAAAA;;AAEYA,IAAAA,eAAAA,CAAAA,IAAAA,EAAAA,uBAAAA,EAEVO,gBAAgB,CAACC,MAFPR,CAAAA;;AAEaA,IAAAA,eAAAA,CAAAA,IAAAA,EAAAA,kBAAAA,EAAAA,KAAAA,CAAAA,CAAAA;;AAAAA,IAAAA,eAAAA,CAInC,IAJmCA,EAInC,eAJmCA,EAInC;AAAES,MAAAA,aAAa,EAAE;AAAjB,KAJmCT,CAAAA;;AAIdA,IAAAA,eAAAA,CAAAA,IAAAA,EAAAA,iBAAAA,EAEP,IAFOA,CAAAA;;AAM1D,SAAKY,kBAAL,CAAuB,aAAA,CAAA,aAAA,CAAA,EAAA,EAClBD,MAAM,CAACxB,eADW,CAAA,EACI,EADJ,EACI;AACzB0B,MAAAA,WAAW,EAAEF,MAAM,CAACE,WADK;AAEzBtB,MAAAA,QAAQ,EAAEoB,MAAM,CAACpB,QAAPoB,IAAmB,EAFJ;AAGzBG,MAAAA,WAAW,EAAEH,MAAM,CAACG,WAHK;AAIzBC,MAAAA,eAAe,EAAEJ,MAAM,CAACI,eAJC;AAKzBC,MAAAA,aAAa,EAAEL,MAAM,CAACK;AALG,KADJ,CAAvB;AAQA,SAAKrB,aAAL,GAAqBgB,MAAM,CAAChB,aAAPgB,IAAwB;AAAEF,MAAAA,aAAa,EAAE;AAAjB,KAA7C;AACF;;AAEoBQ,MAAhBA,gBAAgBA,GAAAA;AAClB,WAAO,KAAKJ,WAAL,GAAgB,aAAA,CAAA,EAAA,EAAQ,KAAKA,WAAb,CAAhB,GAA6C,IAApD;AACF;;AAEY,MAARK,QAAQ,GAAA;AAAA,QAAA,qBAAA;;AACV,WAAO,CAAA,CAAA,qBAAA,GAAI,KAACC,eAAL,MAAoB,IAApB,IAAoB,qBAAA,KAAA,KAAA,CAApB,GAAoB,KAAA,CAApB,GAAA,qBAAA,CAAsBD,QAAtB,KAAkC,IAAzC;AACF;;AAEYA,MAARA,QAAQA,CAACE,CAADF,EAAmC;AAC7C,UAAM,IAAIG,KAAJ,CAAU,iBAAV,CAAN;AACF;;AAEUC,QAAJA,IAAIA,CAACC,OAADD,EAA4B;AACpC,UAAME,+BAAN;AACA,QAAI,CAAC,KAAKjC,QAAV,EAAoB,MAAMkC,yBAAyB,CAACC,aAA1BD,CAAwC,wDAAxCA,CAAN;AACpB,QAAI,CAAC,KAAKE,gBAAV,EAA4B,MAAMF,yBAAyB,CAACC,aAA1BD,CAAwC,gEAAxCA,CAAN;AAC5B,QAAIG,gBAAgB,GAAG,KAAvB;;AAEA,QAAI,KAAKD,gBAAL,CAAsBnC,MAAtB,KAAiCC,OAAO,CAACoC,QAAzC,IAAqD,KAAKF,gBAAL,CAAsBnC,MAAtB,KAAiCC,OAAO,CAACqC,oBAAlG,EAAwH;AACtH,YAAMC,cAAc,GAAGC,kBAAkB,EAAzC;;AACA,UAAIC,MAAM,CAACC,IAAPD,CAAYF,cAAZE,EAA4BE,MAA5BF,GAAqC,CAArCA,IAA0CF,cAAc,CAACK,IAA7D,EAAmE;AACjER,QAAAA,gBAAgB,GAAG,IAAnBA;AACD;AACF;;AACD,SAAKD,gBAAL,GAAqB,aAAA,CAAA,aAAA,CAAA,EAAA,EAChB,KAAKA,gBADW,CAAA,EACK,EADL,EACK;AACxBU,MAAAA,oBAAoB,EAAET;AADE,KADL,CAArB;AAIA,SAAKU,iBAAL,GAAyB,IAAIC,SAAJ,CAAa,aAAA,CAAA,aAAA,CAAA,EAAA,EACjC,KAAKZ,gBAD4B,CAAA,EACZ,EADY,EACZ;AACxBpC,MAAAA,QAAQ,EAAE,KAAKA,QADS;AAExBH,MAAAA,OAAO,EAAE,KAAKuC,gBAAL,CAAsBvC,OAAtB,IAAiC,KAAK2B,eAAtC,IAAyD1B,iBAAiB,CAACC;AAF5D,KADY,CAAb,CAAzB;AAKAkD,IAAAA,GAAG,CAACC,KAAJD,CAAU,qCAAVA;AAEA,UAAM,KAAKF,iBAAL,CAAuBhB,IAAvB,EAAN;AAEA,SAAKoB,MAAL,GAAcrC,cAAc,CAACsC,KAA7B;AACA,SAAKC,IAAL,CAAUC,cAAc,CAACF,KAAzB,EAAgC7C,eAAe,CAACC,SAAhD;;AAEA,QAAI;AACFyC,MAAAA,GAAG,CAACC,KAAJD,CAAU,gCAAVA;;AAEA,YAAMM,YAAY,GAAG,KAAKC,gBAAL,EAArB,CAHE,CAIF;;;AACA,UAAID,YAAY,KAAKvB,OAAO,CAACyB,WAARzB,IAAuBK,gBAA5B,CAAhB,EAA+D;AAC7D,aAAKqB,UAAL,GAAkB,IAAlB;AACA,cAAM,KAAKC,OAAL,EAAN;AACD;AACF,KATD,CASE,OAAOC,KAAP,EAAc;AACdX,MAAAA,GAAG,CAACW,KAAJX,CAAU,kDAAVA,EAA8DW,KAA9DX;AACA,WAAKI,IAAL,CAAU,SAAV,EAAqBO,KAArB;AACD;AACH;;AAEaD,QAAPA,OAAOA,GAAqD;AAAA,QAApDvC,MAAAA,GAAAA,SAAAA,CAAAA,MAAAA,GAAAA,CAAAA,IAAAA,SAAAA,CAAAA,CAAAA,CAAAA,KAAAA,SAAAA,GAAAA,SAAAA,CAA+B,CAA/BA,CAAAA,GAA+B;AAAEF,MAAAA,aAAa,EAAE;AAAjB,KAAqB;AAChE,UAAM2C,2BAAN;AACA,SAAKV,MAAL,GAAcrC,cAAc,CAACgD,UAA7B;AACA,SAAKT,IAAL,CAAUC,cAAc,CAACQ,UAAzB,EAAmC,aAAA,CAAA,aAAA,CAAA,EAAA,EAAO1C,MAAP,CAAA,EAAa,EAAb,EAAa;AAAE2C,MAAAA,OAAO,EAAExD,eAAe,CAACC;AAA3B,KAAb,CAAnC;;AACA,QAAI;AACF,YAAM,KAAKwD,mBAAL,CAAyB5C,MAAzB,CAAN;AACA,aAAO,KAAKO,QAAZ;AACD,KAHD,CAGE,OAAOiC,KAAP,EAAuB;AACvBX,MAAAA,GAAG,CAACW,KAAJX,CAAU,2CAAVA,EAAuDW,KAAvDX,EADuB,CAEvB;;AACA,WAAKE,MAAL,GAAcrC,cAAc,CAACsC,KAA7B;AACA,WAAKC,IAAL,CAAUC,cAAc,CAACW,OAAzB,EAAkCL,KAAlC;;AACA,UAAKA,KAAe,KAAA,IAAfA,IAAAA,KAAe,KAAA,KAAA,CAAfA,IAAAA,KAAe,CAAEM,OAAjBN,CAAyBO,QAAzBP,CAAkC,mBAAlCA,CAAL,EAA6D;AAC3D,cAAMQ,gBAAgB,CAACC,WAAjBD,EAAN;AACD,OAFD,MAEO,IAAIR,KAAK,YAAYU,aAArB,EAAoC;AACzC,cAAMV,KAAN;AACD;;AACD,YAAMQ,gBAAgB,CAACG,eAAjBH,CAAiC,gCAAjCA,CAAN;AACD;AACH;;AAEgBI,QAAVA,UAAUA,GAAmD;AAAA,QAAlDxC,OAAAA,GAAAA,SAAAA,CAAAA,MAAAA,GAAAA,CAAAA,IAAAA,SAAAA,CAAAA,CAAAA,CAAAA,KAAAA,SAAAA,GAAAA,SAAAA,CAAgC,CAAhCA,CAAAA,GAAgC;AAAEyC,MAAAA,OAAO,EAAE;AAAX,KAAkB;AACjE,QAAI,KAAKtB,MAAL,KAAgBrC,cAAc,CAAC4D,SAAnC,EAA8C,MAAMN,gBAAgB,CAACO,iBAAjBP,CAAmC,2BAAnCA,CAAN;AAC9C,QAAI,CAAC,KAAKrB,iBAAV,EAA6B,MAAMb,yBAAyB,CAAC0C,QAA1B1C,CAAmC,gCAAnCA,CAAN;AAC7B,UAAM,KAAKa,iBAAL,CAAuB8B,MAAvB,EAAN;;AACA,QAAI7C,OAAO,CAACyC,OAAZ,EAAqB;AACnB,WAAKtB,MAAL,GAAcrC,cAAc,CAACC,SAA7B;AACA,WAAKgC,iBAAL,GAAyB,IAAzB;AACA,WAAKnB,eAAL,GAAuB,IAAvB;AACD,KAJD,MAIO;AACL;AACA,WAAKuB,MAAL,GAAcrC,cAAc,CAACsC,KAA7B;AACD;;AAED,SAAKM,UAAL,GAAkB,KAAlB;AACA,SAAKL,IAAL,CAAUC,cAAc,CAACwB,YAAzB;AACF;;AAEsBC,QAAhBA,gBAAgBA,GAAAA;AACpB,QAAI,KAAK5B,MAAL,KAAgBrC,cAAc,CAAC4D,SAAnC,EAA8C,MAAMN,gBAAgB,CAACO,iBAAjBP,CAAmC,uDAAnCA,CAAN;AAC9C,UAAMY,QAAQ,GAAG,MAAM,KAAKC,WAAL,EAAvB;AACA,WAAO;AACLC,MAAAA,OAAO,EAAEF,QAAQ,CAACE;AADb,KAAP;AAGF;;AAEiBD,QAAXA,WAAWA,GAAAA;AACf,QAAI,KAAK9B,MAAL,KAAgBrC,cAAc,CAAC4D,SAAnC,EAA8C,MAAMN,gBAAgB,CAACO,iBAAjBP,CAAmC,2BAAnCA,CAAN;AAC9C,QAAI,CAAC,KAAKrB,iBAAV,EAA6B,MAAMb,yBAAyB,CAAC0C,QAA1B1C,CAAmC,gCAAnCA,CAAN;AAC7B,UAAM8C,QAAQ,GAAG,MAAM,KAAKjC,iBAAL,CAAuBkC,WAAvB,EAAvB;AACA,WAAOD,QAAP;AACF,GA1IqE,CA4IrE;;;AACA3D,EAAAA,kBAAkBA,CAACzB,eAADyB,EAAiE;AACjF,UAAMA,kBAAN,CAAyBzB,eAAzB;AACA,UAAMuF,cAAc,GAAGxF,0BAA0B,EAAjD;AACAsD,IAAAA,GAAG,CAACmC,IAAJnC,CAAS,0BAATA,EAAqCrD,eAArCqD;AACA,SAAKb,gBAAL,GAAqB,aAAA,CAAA,aAAA,CAAA,aAAA,CAAA,EAAA,EAChB+C,cAAc,CAACvF,eADC,CAAA,EAEhB,KAAKwC,gBAFW,CAAA,EAGhBxC,eAHgB,CAArB;;AAKA,QAAIA,eAAe,CAAC4B,eAApB,EAAqC;AACnC,WAAKY,gBAAL,CAAsBvC,OAAtB,GAAgCD,eAAe,CAAC4B,eAAhD;AACD;;AACD,QAAI5B,eAAe,CAAC6B,aAAhB7B,KAAkCyF,SAAtC,EAAiD;AAC/C,WAAKjD,gBAAL,CAAsBX,aAAtB,GAAsC7B,eAAe,CAAC6B,aAAtD;AACD;AACH;;AAEqB6D,QAARA,QAAQA,CAAChE,WAADgE,EAA6C;AAAA,QAAA,sBAAA;;AAAA,QAAZvD,IAAI,GAAA,SAAA,CAAA,MAAA,GAAA,CAAA,IAAA,SAAA,CAAA,CAAA,CAAA,KAAA,SAAA,GAAA,SAAA,CAAA,CAAA,CAAA,GAAG,KAAK;AAChE,UAAMwD,yBAAN,CAAgCxD,IAAhC;AACA,KAAA,sBAAA,GAAA,KAAKH,eAAL,MAAoB,IAApB,IAAoB,sBAAA,KAApB,KAAA,CAAA,GAAA,KAAA,CAAA,GAAA,sBAAA,CAAsB0D,QAAtB,CAA+BhE,WAA/B,CAAA;AACA,SAAKkE,cAAL,CAAoBlE,WAApB;AACF;;AAEwBmE,QAAXA,WAAWA,CAACrE,MAADqE,EAA0C;AAAA,QAAA,sBAAA;;AAAA,QAAZ1D,IAAI,GAAA,SAAA,CAAA,MAAA,GAAA,CAAA,IAAA,SAAA,CAAA,CAAA,CAAA,KAAA,SAAA,GAAA,SAAA,CAAA,CAAA,CAAA,GAAG,KAAK;AAChE,UAAM2D,4BAAN,CAAmCtE,MAAnC,EAA2CW,IAA3C;AACA,WAAA,CAAA,sBAAA,GAAM,KAAKH,eAAX,MAA0B,IAA1B,IAA0B,sBAAA,KAAA,KAAA,CAA1B,GAA0B,KAAA,CAA1B,GAAM,sBAAA,CAAsB6D,WAAtB,CAAkCrE,MAAlC,CAAN;AACA,SAAKC,kBAAL,CAAwB;AAAEC,MAAAA,WAAW,EAAE,KAAKqE,cAAL,CAAoBvE,MAAM,CAACwE,OAA3B;AAAf,KAAxB;AACF;;AAEQpC,EAAAA,gBAAgB,GAAA;AAAA,QAAA,qBAAA;;AACtB,QAAI,CAAC,KAAKT,iBAAV,EAA6B,OAAO,EAAP;AAC7B,QAAIQ,YAAY,GAAG,KAAKR,iBAAL,CAAuB8C,OAA1C,CAFsB,CAGtB;;AACA,QAAA,CAAA,qBAAA,GAAI,KAAKzD,gBAAT,MAAyB,IAAzB,IAAyB,qBAAA,KAArB,KAAA,CAAJ,IAAI,qBAAA,CAAuBX,aAA3B,EAA0C;AACxC,UAAI,CAAC,KAAKsB,iBAAL,CAAuB+C,UAA5B,EAAwC;AACtC,cAAM1B,gBAAgB,CAAC2B,kBAAjB3B,EAAN;AACD;;AACDb,MAAAA,YAAY,GAAG,KAAKR,iBAAL,CAAuB+C,UAAtCvC;AACD;;AACD,WAAOA,YAAP;AACF;;AAEiCS,QAAnBA,mBAAmBA,GAAqD;AAAA,QAAA,qBAAA;;AAAA,QAApD5C,MAAAA,GAAAA,SAAAA,CAAAA,MAAAA,GAAAA,CAAAA,IAAAA,SAAAA,CAAAA,CAAAA,CAAAA,KAAAA,SAAAA,GAAAA,SAAAA,CAA+B,CAA/BA,CAAAA,GAA+B;AAAEF,MAAAA,aAAa,EAAE;AAAjB,KAAqB;AACpF,QAAI,CAAC,KAAKI,WAAV,EAAuB,MAAMY,yBAAyB,CAACC,aAA1BD,CAAwC,+CAAxCA,CAAN;AACvB,QAAI,CAAC,KAAKa,iBAAV,EAA6B,MAAMb,yBAAyB,CAAC0C,QAA1B1C,CAAmC,gCAAnCA,CAAN;;AAE7B,QAAI,KAAK8D,qBAAL,KAA+BhF,gBAAgB,CAACiF,MAApD,EAA4D;AAC1D,YAAM;AAAEC,QAAAA;AAAF,UAA+B,MAAM,OAAO,2BAAP,CAA3C;AACA,WAAKtE,eAAL,GAAuB,IAAIsE,wBAAJ,CAA6B;AAAEC,QAAAA,MAAM,EAAE;AAAE7E,UAAAA,WAAW,EAAE,KAAKA;AAApB;AAAV,OAA7B,CAAvB;AACD,KAHD,MAGO,IAAI,KAAK0E,qBAAL,KAA+BhF,gBAAgB,CAACC,MAApD,EAA4D;AACjE,YAAM;AAAEmF,QAAAA;AAAF,UAAiC,MAAM,OAAO,6BAAP,CAA7C;AACA,WAAKxE,eAAL,GAAuB,IAAIwE,0BAAJ,CAA+B;AAAED,QAAAA,MAAM,EAAE;AAAE7E,UAAAA,WAAW,EAAE,KAAKA;AAApB;AAAV,OAA/B,CAAvB;AACD,KAHM,MAGA,IAAI,KAAK0E,qBAAL,KAA+BhF,gBAAgB,CAACqF,KAApD,EAA2D;AAChE,WAAKzE,eAAL,GAAuB,IAAI0E,wBAAJ,EAAvB;AACD,KAFM,MAEA;AACL,YAAM,IAAIxE,KAAJ,CAAU,2BAA2B,KAAKkE,qBAAwD,mCAAlG,CAAN;AACD;;AACD,UAAMO,YAAY,GAAG,KAAK/C,gBAAL,EAArB,CAfoF,CAgBpF;;;AACA,QAAI,CAAC+C,YAAD,IAAa,CAAA,qBAAA,GAAInF,MAAM,CAACoF,iBAAX,MAA4B,IAA5B,IAA4B,qBAAA,KAAA,KAAA,CAA5B,IAAIpF,qBAAAA,CAA0BqF,QAA/C,EAAyD;AAAA,UAAA,sBAAA;;AACvD,UAAI,CAAC,KAAKrG,aAAL,CAAmBsG,KAAxB,EAA+B;AAC7B,aAAKtG,aAAL,CAAmBsG,KAAnB,GACE,KAAKV,qBAAL,KAA+BhF,gBAAgB,CAACiF,MAAhD,GAAyDU,oBAAoB,CAACC,OAA9E,GAAwFD,oBAAoB,CAACE,SAD/G;AAED;;AACD,UAAI,CAACzF,MAAM,CAACF,aAAR,IAAyB,CAAC,KAAKd,aAAL,CAAmBc,aAAjD,EACE,MAAMgB,yBAAyB,CAACC,aAA1BD,CAAwC,qCAAxCA,CAAN;AACF,YAAM,KAAKa,iBAAL,CAAuB+D,KAAvB,CACJC,KAAK,CAAC,KAAK3G,aAAN,EAAqBgB,MAArB,EAA6B;AAChCoF,QAAAA,iBAAiB,EAAA,aAAA,CAAA,aAAA,CAAA,EAAA,EAAQpF,MAAM,CAACoF,iBAAPpF,IAA4B,EAApC,CAAA,EAAsC,EAAtC,EAAsC;AAAG4F,UAAAA,UAAU,EAAE5F,MAAM,CAAC4F,UAAP5F,KAAiB,CAAA,sBAAA,GAAIA,MAAM,CAACoF,iBAAX,MAA4B,IAA5B,IAA4B,sBAAA,KAAxBpF,KAAAA,CAAJ,GAAIA,KAAAA,CAAJ,GAAIA,sBAAAA,CAA0B4F,UAA/C5F;AAAf,SAAtC;AADe,OAA7B,CADD,CAAN;AAKD;;AACD,QAAImC,YAAY,GAAG,KAAKC,gBAAL,EAAnB;;AACA,QAAID,YAAJ,EAAkB;AAChB,UAAI,KAAKyC,qBAAL,KAA+BhF,gBAAgB,CAACiF,MAApD,EAA4D;AAC1D,cAAM;AAAEgB,UAAAA;AAAF,YAAoB,MAAM,OAAO,8BAAP,CAAhC;AACA1D,QAAAA,YAAY,GAAG0D,aAAa,CAAC1D,YAAD,CAAb0D,CAA4BC,EAA5BD,CAA+BE,QAA/BF,CAAwC,KAAxCA,CAAf1D;AACD;;AACD,YAAM,KAAK3B,eAAL,CAAqBwF,aAArB,CAAmC7D,YAAnC,CAAN;AACA,WAAKJ,MAAL,GAAcrC,cAAc,CAAC4D,SAA7B;AACA,WAAKrB,IAAL,CAAUC,cAAc,CAACoB,SAAzB,EAAoC;AAAEX,QAAAA,OAAO,EAAExD,eAAe,CAACC,SAA3B;AAAsC6G,QAAAA,WAAW,EAAE,KAAK3D;AAAxD,OAApC;AACD;AACH;;AA/NqE","sourcesContent":["import OpenLogin, { OPENLOGIN_NETWORK, UX_MODE, getHashQueryParams, SUPPORTED_KEY_CURVES } from '@toruslabs/openlogin';\nimport _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport { BaseAdapter, WALLET_ADAPTERS, ADAPTER_NAMESPACES, ADAPTER_CATEGORY, ADAPTER_STATUS, CHAIN_NAMESPACES, WalletInitializationError, log, ADAPTER_EVENTS, WalletLoginError, Web3AuthError } from '@web3auth/base';\nimport { CommonPrivateKeyProvider } from '@web3auth/base-provider';\nimport merge from 'lodash.merge';\n\nconst getOpenloginDefaultOptions = () => {\n  return {\n    adapterSettings: {\n      network: OPENLOGIN_NETWORK.MAINNET,\n      clientId: \"\",\n      uxMode: UX_MODE.POPUP\n    },\n    loginSettings: {}\n  };\n};\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nclass OpenloginAdapter extends BaseAdapter {\n  constructor() {\n    let params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super(params);\n    _defineProperty(this, \"name\", WALLET_ADAPTERS.OPENLOGIN);\n    _defineProperty(this, \"adapterNamespace\", ADAPTER_NAMESPACES.MULTICHAIN);\n    _defineProperty(this, \"type\", ADAPTER_CATEGORY.IN_APP);\n    _defineProperty(this, \"openloginInstance\", null);\n    _defineProperty(this, \"status\", ADAPTER_STATUS.NOT_READY);\n    _defineProperty(this, \"currentChainNamespace\", CHAIN_NAMESPACES.EIP155);\n    _defineProperty(this, \"openloginOptions\", void 0);\n    _defineProperty(this, \"loginSettings\", {\n      loginProvider: \"\"\n    });\n    _defineProperty(this, \"privKeyProvider\", null);\n    this.setAdapterSettings(_objectSpread(_objectSpread({}, params.adapterSettings), {}, {\n      chainConfig: params.chainConfig,\n      clientId: params.clientId || \"\",\n      sessionTime: params.sessionTime,\n      web3AuthNetwork: params.web3AuthNetwork,\n      useCoreKitKey: params.useCoreKitKey\n    }));\n    this.loginSettings = params.loginSettings || {\n      loginProvider: \"\"\n    };\n  }\n  get chainConfigProxy() {\n    return this.chainConfig ? _objectSpread({}, this.chainConfig) : null;\n  }\n  get provider() {\n    var _this$privKeyProvider;\n    return ((_this$privKeyProvider = this.privKeyProvider) === null || _this$privKeyProvider === void 0 ? void 0 : _this$privKeyProvider.provider) || null;\n  }\n  set provider(_) {\n    throw new Error(\"Not implemented\");\n  }\n  async init(options) {\n    super.checkInitializationRequirements();\n    if (!this.clientId) throw WalletInitializationError.invalidParams(\"clientId is required before openlogin's initialization\");\n    if (!this.openloginOptions) throw WalletInitializationError.invalidParams(\"openloginOptions is required before openlogin's initialization\");\n    let isRedirectResult = false;\n    if (this.openloginOptions.uxMode === UX_MODE.REDIRECT || this.openloginOptions.uxMode === UX_MODE.SESSIONLESS_REDIRECT) {\n      const redirectResult = getHashQueryParams();\n      if (Object.keys(redirectResult).length > 0 && redirectResult._pid) {\n        isRedirectResult = true;\n      }\n    }\n    this.openloginOptions = _objectSpread(_objectSpread({}, this.openloginOptions), {}, {\n      replaceUrlOnRedirect: isRedirectResult\n    });\n    this.openloginInstance = new OpenLogin(_objectSpread(_objectSpread({}, this.openloginOptions), {}, {\n      clientId: this.clientId,\n      network: this.openloginOptions.network || this.web3AuthNetwork || OPENLOGIN_NETWORK.MAINNET\n    }));\n    log.debug(\"initializing openlogin adapter init\");\n    await this.openloginInstance.init();\n    this.status = ADAPTER_STATUS.READY;\n    this.emit(ADAPTER_EVENTS.READY, WALLET_ADAPTERS.OPENLOGIN);\n    try {\n      log.debug(\"initializing openlogin adapter\");\n      const finalPrivKey = this._getFinalPrivKey();\n      // connect only if it is redirect result or if connect (adapter is cached/already connected in same session) is true\n      if (finalPrivKey && (options.autoConnect || isRedirectResult)) {\n        this.rehydrated = true;\n        await this.connect();\n      }\n    } catch (error) {\n      log.error(\"Failed to connect with cached openlogin provider\", error);\n      this.emit(\"ERRORED\", error);\n    }\n  }\n  async connect() {\n    let params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n      loginProvider: \"\"\n    };\n    super.checkConnectionRequirements();\n    this.status = ADAPTER_STATUS.CONNECTING;\n    this.emit(ADAPTER_EVENTS.CONNECTING, _objectSpread(_objectSpread({}, params), {}, {\n      adapter: WALLET_ADAPTERS.OPENLOGIN\n    }));\n    try {\n      await this.connectWithProvider(params);\n      return this.provider;\n    } catch (error) {\n      log.error(\"Failed to connect with openlogin provider\", error);\n      // ready again to be connected\n      this.status = ADAPTER_STATUS.READY;\n      this.emit(ADAPTER_EVENTS.ERRORED, error);\n      if (error !== null && error !== void 0 && error.message.includes(\"user closed popup\")) {\n        throw WalletLoginError.popupClosed();\n      } else if (error instanceof Web3AuthError) {\n        throw error;\n      }\n      throw WalletLoginError.connectionError(\"Failed to login with openlogin\");\n    }\n  }\n  async disconnect() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n      cleanup: false\n    };\n    if (this.status !== ADAPTER_STATUS.CONNECTED) throw WalletLoginError.notConnectedError(\"Not connected with wallet\");\n    if (!this.openloginInstance) throw WalletInitializationError.notReady(\"openloginInstance is not ready\");\n    await this.openloginInstance.logout();\n    if (options.cleanup) {\n      this.status = ADAPTER_STATUS.NOT_READY;\n      this.openloginInstance = null;\n      this.privKeyProvider = null;\n    } else {\n      // ready to be connected again\n      this.status = ADAPTER_STATUS.READY;\n    }\n    this.rehydrated = false;\n    this.emit(ADAPTER_EVENTS.DISCONNECTED);\n  }\n  async authenticateUser() {\n    if (this.status !== ADAPTER_STATUS.CONNECTED) throw WalletLoginError.notConnectedError(\"Not connected with wallet, Please login/connect first\");\n    const userInfo = await this.getUserInfo();\n    return {\n      idToken: userInfo.idToken\n    };\n  }\n  async getUserInfo() {\n    if (this.status !== ADAPTER_STATUS.CONNECTED) throw WalletLoginError.notConnectedError(\"Not connected with wallet\");\n    if (!this.openloginInstance) throw WalletInitializationError.notReady(\"openloginInstance is not ready\");\n    const userInfo = await this.openloginInstance.getUserInfo();\n    return userInfo;\n  }\n  // should be called only before initialization.\n  setAdapterSettings(adapterSettings) {\n    super.setAdapterSettings(adapterSettings);\n    const defaultOptions = getOpenloginDefaultOptions();\n    log.info(\"setting adapter settings\", adapterSettings);\n    this.openloginOptions = _objectSpread(_objectSpread(_objectSpread({}, defaultOptions.adapterSettings), this.openloginOptions), adapterSettings);\n    if (adapterSettings.web3AuthNetwork) {\n      this.openloginOptions.network = adapterSettings.web3AuthNetwork;\n    }\n    if (adapterSettings.useCoreKitKey !== undefined) {\n      this.openloginOptions.useCoreKitKey = adapterSettings.useCoreKitKey;\n    }\n  }\n  async addChain(chainConfig) {\n    var _this$privKeyProvider2;\n    let init = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    super.checkAddChainRequirements(init);\n    (_this$privKeyProvider2 = this.privKeyProvider) === null || _this$privKeyProvider2 === void 0 ? void 0 : _this$privKeyProvider2.addChain(chainConfig);\n    this.addChainConfig(chainConfig);\n  }\n  async switchChain(params) {\n    var _this$privKeyProvider3;\n    let init = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    super.checkSwitchChainRequirements(params, init);\n    await ((_this$privKeyProvider3 = this.privKeyProvider) === null || _this$privKeyProvider3 === void 0 ? void 0 : _this$privKeyProvider3.switchChain(params));\n    this.setAdapterSettings({\n      chainConfig: this.getChainConfig(params.chainId)\n    });\n  }\n  _getFinalPrivKey() {\n    var _this$openloginOption;\n    if (!this.openloginInstance) return \"\";\n    let finalPrivKey = this.openloginInstance.privKey;\n    // coreKitKey is available only for custom verifiers by default\n    if ((_this$openloginOption = this.openloginOptions) !== null && _this$openloginOption !== void 0 && _this$openloginOption.useCoreKitKey) {\n      if (!this.openloginInstance.coreKitKey) {\n        throw WalletLoginError.coreKitKeyNotFound();\n      }\n      finalPrivKey = this.openloginInstance.coreKitKey;\n    }\n    return finalPrivKey;\n  }\n  async connectWithProvider() {\n    var _params$extraLoginOpt;\n    let params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n      loginProvider: \"\"\n    };\n    if (!this.chainConfig) throw WalletInitializationError.invalidParams(\"chainConfig is required before initialization\");\n    if (!this.openloginInstance) throw WalletInitializationError.notReady(\"openloginInstance is not ready\");\n    if (this.currentChainNamespace === CHAIN_NAMESPACES.SOLANA) {\n      const {\n        SolanaPrivateKeyProvider\n      } = await import('@web3auth/solana-provider');\n      this.privKeyProvider = new SolanaPrivateKeyProvider({\n        config: {\n          chainConfig: this.chainConfig\n        }\n      });\n    } else if (this.currentChainNamespace === CHAIN_NAMESPACES.EIP155) {\n      const {\n        EthereumPrivateKeyProvider\n      } = await import('@web3auth/ethereum-provider');\n      this.privKeyProvider = new EthereumPrivateKeyProvider({\n        config: {\n          chainConfig: this.chainConfig\n        }\n      });\n    } else if (this.currentChainNamespace === CHAIN_NAMESPACES.OTHER) {\n      this.privKeyProvider = new CommonPrivateKeyProvider();\n    } else {\n      throw new Error(`Invalid chainNamespace: ${this.currentChainNamespace} found while connecting to wallet`);\n    }\n    const keyAvailable = this._getFinalPrivKey();\n    // if not logged in then login\n    if (!keyAvailable || (_params$extraLoginOpt = params.extraLoginOptions) !== null && _params$extraLoginOpt !== void 0 && _params$extraLoginOpt.id_token) {\n      var _params$extraLoginOpt2;\n      if (!this.loginSettings.curve) {\n        this.loginSettings.curve = this.currentChainNamespace === CHAIN_NAMESPACES.SOLANA ? SUPPORTED_KEY_CURVES.ED25519 : SUPPORTED_KEY_CURVES.SECP256K1;\n      }\n      if (!params.loginProvider && !this.loginSettings.loginProvider) throw WalletInitializationError.invalidParams(\"loginProvider is required for login\");\n      await this.openloginInstance.login(merge(this.loginSettings, params, {\n        extraLoginOptions: _objectSpread(_objectSpread({}, params.extraLoginOptions || {}), {}, {\n          login_hint: params.login_hint || ((_params$extraLoginOpt2 = params.extraLoginOptions) === null || _params$extraLoginOpt2 === void 0 ? void 0 : _params$extraLoginOpt2.login_hint)\n        })\n      }));\n    }\n    let finalPrivKey = this._getFinalPrivKey();\n    if (finalPrivKey) {\n      if (this.currentChainNamespace === CHAIN_NAMESPACES.SOLANA) {\n        const {\n          getED25519Key\n        } = await import('@toruslabs/openlogin-ed25519');\n        finalPrivKey = getED25519Key(finalPrivKey).sk.toString(\"hex\");\n      }\n      await this.privKeyProvider.setupProvider(finalPrivKey);\n      this.status = ADAPTER_STATUS.CONNECTED;\n      this.emit(ADAPTER_EVENTS.CONNECTED, {\n        adapter: WALLET_ADAPTERS.OPENLOGIN,\n        reconnected: this.rehydrated\n      });\n    }\n  }\n}\n\nexport { OpenloginAdapter, getOpenloginDefaultOptions };\n//# sourceMappingURL=openloginAdapter.esm.js.map\n"]},"metadata":{},"sourceType":"module"}