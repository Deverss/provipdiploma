{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ByteListType = void 0;\n\nconst persistent_merkle_tree_1 = require(\"@chainsafe/persistent-merkle-tree\");\n\nconst merkleize_1 = require(\"../util/merkleize\");\n\nconst named_1 = require(\"../util/named\");\n\nconst arrayBasic_1 = require(\"./arrayBasic\");\n\nconst byteArray_1 = require(\"./byteArray\");\n/**\n * ByteList: Immutable alias of List[byte, N]\n * - Notation: `ByteList[N]`\n * - Value: `Uint8Array`\n * - View: `Uint8Array`\n * - ViewDU: `Uint8Array`\n *\n * ByteList is an immutable value which is represented by a Uint8Array for memory efficiency and performance.\n * Note: Consumers of this type MUST never mutate the `Uint8Array` representation of a ByteList.\n *\n * For a `ByteListType` with mutability, use `ListBasicType(byteType)`\n */\n\n\nclass ByteListType extends byteArray_1.ByteArrayType {\n  constructor(limitBytes, opts) {\n    super();\n    this.limitBytes = limitBytes;\n    this.fixedSize = null;\n    this.isList = true;\n    if (limitBytes === 0) throw Error(\"List limit must be > 0\");\n    this.typeName = (opts === null || opts === void 0 ? void 0 : opts.typeName) ?? `ByteList[${limitBytes}]`;\n    this.maxChunkCount = Math.ceil(this.limitBytes / 32);\n    this.chunkDepth = merkleize_1.maxChunksToDepth(this.maxChunkCount);\n    this.depth = 1 + this.chunkDepth;\n    this.minSize = 0;\n    this.maxSize = this.limitBytes;\n  }\n\n  static named(limitBits, opts) {\n    return new (named_1.namedClass(ByteListType, opts.typeName))(limitBits, opts);\n  } // Views: inherited from ByteArrayType\n  // Serialization + deserialization\n\n\n  value_serializedSize(value) {\n    return value.length;\n  } // value_* inherited from ByteArrayType\n\n\n  tree_serializedSize(node) {\n    return arrayBasic_1.getLengthFromRootNode(node);\n  }\n\n  tree_serializeToBytes(output, offset, node) {\n    const chunksNode = arrayBasic_1.getChunksNodeFromRootNode(node);\n    const byteLen = arrayBasic_1.getLengthFromRootNode(node);\n    const chunkLen = Math.ceil(byteLen / 32);\n    const nodes = persistent_merkle_tree_1.getNodesAtDepth(chunksNode, this.chunkDepth, 0, chunkLen);\n    persistent_merkle_tree_1.packedNodeRootsToBytes(output.dataView, offset, byteLen, nodes);\n    return offset + byteLen;\n  }\n\n  tree_deserializeFromBytes(data, start, end) {\n    this.assertValidSize(end - start);\n    const chunksNode = persistent_merkle_tree_1.packedRootsBytesToNode(this.chunkDepth, data.dataView, start, end);\n    return arrayBasic_1.addLengthNode(chunksNode, end - start);\n  }\n\n  tree_getByteLen(node) {\n    if (!node) throw new Error(\"ByteListType requires a node to get leaves\");\n    return arrayBasic_1.getLengthFromRootNode(node);\n  } // Merkleization: inherited from ByteArrayType\n\n\n  hashTreeRoot(value) {\n    return merkleize_1.mixInLength(super.hashTreeRoot(value), value.length);\n  } // Proofs: inherited from BitArrayType\n  // JSON: inherited from ByteArrayType\n\n\n  assertValidSize(size) {\n    if (size > this.limitBytes) {\n      throw Error(`ByteList invalid size ${size} limit ${this.limitBytes}`);\n    }\n  }\n\n}\n\nexports.ByteListType = ByteListType;","map":{"version":3,"sources":["../../src/type/byteList.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ByteListType = void 0;\nconst persistent_merkle_tree_1 = require(\"@chainsafe/persistent-merkle-tree\");\nconst merkleize_1 = require(\"../util/merkleize\");\nconst named_1 = require(\"../util/named\");\nconst arrayBasic_1 = require(\"./arrayBasic\");\nconst byteArray_1 = require(\"./byteArray\");\n/**\n * ByteList: Immutable alias of List[byte, N]\n * - Notation: `ByteList[N]`\n * - Value: `Uint8Array`\n * - View: `Uint8Array`\n * - ViewDU: `Uint8Array`\n *\n * ByteList is an immutable value which is represented by a Uint8Array for memory efficiency and performance.\n * Note: Consumers of this type MUST never mutate the `Uint8Array` representation of a ByteList.\n *\n * For a `ByteListType` with mutability, use `ListBasicType(byteType)`\n */\nclass ByteListType extends byteArray_1.ByteArrayType {\n    constructor(limitBytes, opts) {\n        super();\n        this.limitBytes = limitBytes;\n        this.fixedSize = null;\n        this.isList = true;\n        if (limitBytes === 0)\n            throw Error(\"List limit must be > 0\");\n        this.typeName = opts?.typeName ?? `ByteList[${limitBytes}]`;\n        this.maxChunkCount = Math.ceil(this.limitBytes / 32);\n        this.chunkDepth = merkleize_1.maxChunksToDepth(this.maxChunkCount);\n        this.depth = 1 + this.chunkDepth;\n        this.minSize = 0;\n        this.maxSize = this.limitBytes;\n    }\n    static named(limitBits, opts) {\n        return new (named_1.namedClass(ByteListType, opts.typeName))(limitBits, opts);\n    }\n    // Views: inherited from ByteArrayType\n    // Serialization + deserialization\n    value_serializedSize(value) {\n        return value.length;\n    }\n    // value_* inherited from ByteArrayType\n    tree_serializedSize(node) {\n        return arrayBasic_1.getLengthFromRootNode(node);\n    }\n    tree_serializeToBytes(output, offset, node) {\n        const chunksNode = arrayBasic_1.getChunksNodeFromRootNode(node);\n        const byteLen = arrayBasic_1.getLengthFromRootNode(node);\n        const chunkLen = Math.ceil(byteLen / 32);\n        const nodes = persistent_merkle_tree_1.getNodesAtDepth(chunksNode, this.chunkDepth, 0, chunkLen);\n        persistent_merkle_tree_1.packedNodeRootsToBytes(output.dataView, offset, byteLen, nodes);\n        return offset + byteLen;\n    }\n    tree_deserializeFromBytes(data, start, end) {\n        this.assertValidSize(end - start);\n        const chunksNode = persistent_merkle_tree_1.packedRootsBytesToNode(this.chunkDepth, data.dataView, start, end);\n        return arrayBasic_1.addLengthNode(chunksNode, end - start);\n    }\n    tree_getByteLen(node) {\n        if (!node)\n            throw new Error(\"ByteListType requires a node to get leaves\");\n        return arrayBasic_1.getLengthFromRootNode(node);\n    }\n    // Merkleization: inherited from ByteArrayType\n    hashTreeRoot(value) {\n        return merkleize_1.mixInLength(super.hashTreeRoot(value), value.length);\n    }\n    // Proofs: inherited from BitArrayType\n    // JSON: inherited from ByteArrayType\n    assertValidSize(size) {\n        if (size > this.limitBytes) {\n            throw Error(`ByteList invalid size ${size} limit ${this.limitBytes}`);\n        }\n    }\n}\nexports.ByteListType = ByteListType;\n//# sourceMappingURL=byteList.js.map"]},"metadata":{},"sourceType":"script"}