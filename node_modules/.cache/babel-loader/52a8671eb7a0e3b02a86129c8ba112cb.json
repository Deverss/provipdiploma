{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Withdrawal = void 0;\n\nconst address_1 = require(\"./address\");\n\nconst bytes_1 = require(\"./bytes\");\n\nconst types_1 = require(\"./types\");\n/**\n * Representation of EIP-4895 withdrawal data\n */\n\n\nclass Withdrawal {\n  /**\n   * This constructor assigns and validates the values.\n   * Use the static factory methods to assist in creating a Withdrawal object from varying data types.\n   * Its amount is in Gwei to match CL representation and for eventual ssz withdrawalsRoot\n   */\n  constructor(index, validatorIndex, address,\n  /**\n   * withdrawal amount in Gwei to match the CL repesentation and eventually ssz withdrawalsRoot\n   */\n  amount) {\n    this.index = index;\n    this.validatorIndex = validatorIndex;\n    this.address = address;\n    this.amount = amount;\n  }\n\n  static fromWithdrawalData(withdrawalData) {\n    const {\n      index: indexData,\n      validatorIndex: validatorIndexData,\n      address: addressData,\n      amount: amountData\n    } = withdrawalData;\n    const index = (0, types_1.toType)(indexData, types_1.TypeOutput.BigInt);\n    const validatorIndex = (0, types_1.toType)(validatorIndexData, types_1.TypeOutput.BigInt);\n    const address = new address_1.Address((0, types_1.toType)(addressData, types_1.TypeOutput.Buffer));\n    const amount = (0, types_1.toType)(amountData, types_1.TypeOutput.BigInt);\n    return new Withdrawal(index, validatorIndex, address, amount);\n  }\n\n  static fromValuesArray(withdrawalArray) {\n    if (withdrawalArray.length !== 4) {\n      throw Error(`Invalid withdrawalArray length expected=4 actual=${withdrawalArray.length}`);\n    }\n\n    const [index, validatorIndex, address, amount] = withdrawalArray;\n    return Withdrawal.fromWithdrawalData({\n      index,\n      validatorIndex,\n      address,\n      amount\n    });\n  }\n  /**\n   * Convert a withdrawal to a buffer array\n   * @param withdrawal the withdrawal to convert\n   * @returns buffer array of the withdrawal\n   */\n\n\n  static toBufferArray(withdrawal) {\n    const {\n      index,\n      validatorIndex,\n      address,\n      amount\n    } = withdrawal;\n    const indexBuffer = (0, types_1.toType)(index, types_1.TypeOutput.BigInt) === BigInt(0) ? Buffer.alloc(0) : (0, types_1.toType)(index, types_1.TypeOutput.Buffer);\n    const validatorIndexBuffer = (0, types_1.toType)(validatorIndex, types_1.TypeOutput.BigInt) === BigInt(0) ? Buffer.alloc(0) : (0, types_1.toType)(validatorIndex, types_1.TypeOutput.Buffer);\n    let addressBuffer;\n\n    if (address instanceof address_1.Address) {\n      addressBuffer = address.buf;\n    } else {\n      addressBuffer = (0, types_1.toType)(address, types_1.TypeOutput.Buffer);\n    }\n\n    const amountBuffer = (0, types_1.toType)(amount, types_1.TypeOutput.BigInt) === BigInt(0) ? Buffer.alloc(0) : (0, types_1.toType)(amount, types_1.TypeOutput.Buffer);\n    return [indexBuffer, validatorIndexBuffer, addressBuffer, amountBuffer];\n  }\n\n  raw() {\n    return Withdrawal.toBufferArray(this);\n  }\n\n  toValue() {\n    return {\n      index: this.index,\n      validatorIndex: this.validatorIndex,\n      address: this.address.buf,\n      amount: this.amount\n    };\n  }\n\n  toJSON() {\n    return {\n      index: (0, bytes_1.bigIntToHex)(this.index),\n      validatorIndex: (0, bytes_1.bigIntToHex)(this.validatorIndex),\n      address: '0x' + this.address.buf.toString('hex'),\n      amount: (0, bytes_1.bigIntToHex)(this.amount)\n    };\n  }\n\n}\n\nexports.Withdrawal = Withdrawal;","map":{"version":3,"sources":["../src/withdrawal.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Withdrawal = void 0;\nconst address_1 = require(\"./address\");\nconst bytes_1 = require(\"./bytes\");\nconst types_1 = require(\"./types\");\n/**\n * Representation of EIP-4895 withdrawal data\n */\nclass Withdrawal {\n    /**\n     * This constructor assigns and validates the values.\n     * Use the static factory methods to assist in creating a Withdrawal object from varying data types.\n     * Its amount is in Gwei to match CL representation and for eventual ssz withdrawalsRoot\n     */\n    constructor(index, validatorIndex, address, \n    /**\n     * withdrawal amount in Gwei to match the CL repesentation and eventually ssz withdrawalsRoot\n     */\n    amount) {\n        this.index = index;\n        this.validatorIndex = validatorIndex;\n        this.address = address;\n        this.amount = amount;\n    }\n    static fromWithdrawalData(withdrawalData) {\n        const { index: indexData, validatorIndex: validatorIndexData, address: addressData, amount: amountData, } = withdrawalData;\n        const index = (0, types_1.toType)(indexData, types_1.TypeOutput.BigInt);\n        const validatorIndex = (0, types_1.toType)(validatorIndexData, types_1.TypeOutput.BigInt);\n        const address = new address_1.Address((0, types_1.toType)(addressData, types_1.TypeOutput.Buffer));\n        const amount = (0, types_1.toType)(amountData, types_1.TypeOutput.BigInt);\n        return new Withdrawal(index, validatorIndex, address, amount);\n    }\n    static fromValuesArray(withdrawalArray) {\n        if (withdrawalArray.length !== 4) {\n            throw Error(`Invalid withdrawalArray length expected=4 actual=${withdrawalArray.length}`);\n        }\n        const [index, validatorIndex, address, amount] = withdrawalArray;\n        return Withdrawal.fromWithdrawalData({ index, validatorIndex, address, amount });\n    }\n    /**\n     * Convert a withdrawal to a buffer array\n     * @param withdrawal the withdrawal to convert\n     * @returns buffer array of the withdrawal\n     */\n    static toBufferArray(withdrawal) {\n        const { index, validatorIndex, address, amount } = withdrawal;\n        const indexBuffer = (0, types_1.toType)(index, types_1.TypeOutput.BigInt) === BigInt(0)\n            ? Buffer.alloc(0)\n            : (0, types_1.toType)(index, types_1.TypeOutput.Buffer);\n        const validatorIndexBuffer = (0, types_1.toType)(validatorIndex, types_1.TypeOutput.BigInt) === BigInt(0)\n            ? Buffer.alloc(0)\n            : (0, types_1.toType)(validatorIndex, types_1.TypeOutput.Buffer);\n        let addressBuffer;\n        if (address instanceof address_1.Address) {\n            addressBuffer = address.buf;\n        }\n        else {\n            addressBuffer = (0, types_1.toType)(address, types_1.TypeOutput.Buffer);\n        }\n        const amountBuffer = (0, types_1.toType)(amount, types_1.TypeOutput.BigInt) === BigInt(0)\n            ? Buffer.alloc(0)\n            : (0, types_1.toType)(amount, types_1.TypeOutput.Buffer);\n        return [indexBuffer, validatorIndexBuffer, addressBuffer, amountBuffer];\n    }\n    raw() {\n        return Withdrawal.toBufferArray(this);\n    }\n    toValue() {\n        return {\n            index: this.index,\n            validatorIndex: this.validatorIndex,\n            address: this.address.buf,\n            amount: this.amount,\n        };\n    }\n    toJSON() {\n        return {\n            index: (0, bytes_1.bigIntToHex)(this.index),\n            validatorIndex: (0, bytes_1.bigIntToHex)(this.validatorIndex),\n            address: '0x' + this.address.buf.toString('hex'),\n            amount: (0, bytes_1.bigIntToHex)(this.amount),\n        };\n    }\n}\nexports.Withdrawal = Withdrawal;\n//# sourceMappingURL=withdrawal.js.map"]},"metadata":{},"sourceType":"script"}