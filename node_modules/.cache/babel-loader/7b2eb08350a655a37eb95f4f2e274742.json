{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.commitmentsToVersionedHashes = exports.computeVersionedHash = exports.blobsToCommitments = exports.getBlobs = void 0;\n\nconst sha256_1 = require(\"ethereum-cryptography/sha256\");\n\nconst kzg_1 = require(\"../kzg/kzg\");\n/**\n * These utilities for constructing blobs are borrowed from https://github.com/Inphi/eip4844-interop.git\n */\n\n\nconst BYTES_PER_FIELD_ELEMENT = 32;\nconst FIELD_ELEMENTS_PER_BLOB = 4096;\nconst USEFUL_BYTES_PER_BLOB = 32 * FIELD_ELEMENTS_PER_BLOB;\nconst MAX_BLOBS_PER_TX = 2;\nconst MAX_USEFUL_BYTES_PER_TX = USEFUL_BYTES_PER_BLOB * MAX_BLOBS_PER_TX - 1;\nconst BLOB_SIZE = BYTES_PER_FIELD_ELEMENT * FIELD_ELEMENTS_PER_BLOB;\n\nfunction get_padded(data, blobs_len) {\n  const pdata = Buffer.alloc(blobs_len * USEFUL_BYTES_PER_BLOB);\n  const datalen = Buffer.byteLength(data);\n  pdata.fill(data, 0, datalen);\n  pdata[datalen] = 0x80;\n  return pdata;\n}\n\nfunction get_blob(data) {\n  const blob = Buffer.alloc(BLOB_SIZE, 'binary');\n\n  for (let i = 0; i < FIELD_ELEMENTS_PER_BLOB; i++) {\n    const chunk = Buffer.alloc(32, 'binary');\n    chunk.fill(data.subarray(i * 31, (i + 1) * 31), 0, 31);\n    blob.fill(chunk, i * 32, (i + 1) * 32);\n  }\n\n  return blob;\n}\n\nconst getBlobs = input => {\n  const data = Buffer.from(input, 'binary');\n  const len = Buffer.byteLength(data);\n\n  if (len === 0) {\n    throw Error('invalid blob data');\n  }\n\n  if (len > MAX_USEFUL_BYTES_PER_TX) {\n    throw Error('blob data is too large');\n  }\n\n  const blobs_len = Math.ceil(len / USEFUL_BYTES_PER_BLOB);\n  const pdata = get_padded(data, blobs_len);\n  const blobs = [];\n\n  for (let i = 0; i < blobs_len; i++) {\n    const chunk = pdata.subarray(i * USEFUL_BYTES_PER_BLOB, (i + 1) * USEFUL_BYTES_PER_BLOB);\n    const blob = get_blob(chunk);\n    blobs.push(blob);\n  }\n\n  return blobs;\n};\n\nexports.getBlobs = getBlobs;\n\nconst blobsToCommitments = blobs => {\n  const commitments = [];\n\n  for (const blob of blobs) {\n    commitments.push(Buffer.from(kzg_1.kzg.blobToKzgCommitment(blob)));\n  }\n\n  return commitments;\n};\n\nexports.blobsToCommitments = blobsToCommitments;\n/**\n * Converts a vector commitment for a given data blob to its versioned hash.  For 4844, this version\n * number will be 0x01 for KZG vector commitments but could be different if future vector commitment\n * types are introduced\n * @param commitment a vector commitment to a blob\n * @param blobCommitmentVersion the version number corresponding to the type of vector commitment\n * @returns a versioned hash corresponding to a given blob vector commitment\n */\n\nconst computeVersionedHash = (commitment, blobCommitmentVersion) => {\n  const computedVersionedHash = new Uint8Array(32);\n  computedVersionedHash.set([blobCommitmentVersion], 0);\n  computedVersionedHash.set((0, sha256_1.sha256)(commitment).slice(1), 1);\n  return computedVersionedHash;\n};\n\nexports.computeVersionedHash = computeVersionedHash;\n/**\n * Generate an array of versioned hashes from corresponding kzg commitments\n * @param commitments array of kzg commitments\n * @returns array of versioned hashes\n * Note: assumes KZG commitments (version 1 version hashes)\n */\n\nconst commitmentsToVersionedHashes = commitments => {\n  const hashes = [];\n\n  for (const commitment of commitments) {\n    hashes.push(Buffer.from((0, exports.computeVersionedHash)(commitment, 0x01)));\n  }\n\n  return hashes;\n};\n\nexports.commitmentsToVersionedHashes = commitmentsToVersionedHashes;","map":{"version":3,"sources":["../../src/utils/blobHelpers.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.commitmentsToVersionedHashes = exports.computeVersionedHash = exports.blobsToCommitments = exports.getBlobs = void 0;\nconst sha256_1 = require(\"ethereum-cryptography/sha256\");\nconst kzg_1 = require(\"../kzg/kzg\");\n/**\n * These utilities for constructing blobs are borrowed from https://github.com/Inphi/eip4844-interop.git\n */\nconst BYTES_PER_FIELD_ELEMENT = 32;\nconst FIELD_ELEMENTS_PER_BLOB = 4096;\nconst USEFUL_BYTES_PER_BLOB = 32 * FIELD_ELEMENTS_PER_BLOB;\nconst MAX_BLOBS_PER_TX = 2;\nconst MAX_USEFUL_BYTES_PER_TX = USEFUL_BYTES_PER_BLOB * MAX_BLOBS_PER_TX - 1;\nconst BLOB_SIZE = BYTES_PER_FIELD_ELEMENT * FIELD_ELEMENTS_PER_BLOB;\nfunction get_padded(data, blobs_len) {\n    const pdata = Buffer.alloc(blobs_len * USEFUL_BYTES_PER_BLOB);\n    const datalen = Buffer.byteLength(data);\n    pdata.fill(data, 0, datalen);\n    pdata[datalen] = 0x80;\n    return pdata;\n}\nfunction get_blob(data) {\n    const blob = Buffer.alloc(BLOB_SIZE, 'binary');\n    for (let i = 0; i < FIELD_ELEMENTS_PER_BLOB; i++) {\n        const chunk = Buffer.alloc(32, 'binary');\n        chunk.fill(data.subarray(i * 31, (i + 1) * 31), 0, 31);\n        blob.fill(chunk, i * 32, (i + 1) * 32);\n    }\n    return blob;\n}\nconst getBlobs = (input) => {\n    const data = Buffer.from(input, 'binary');\n    const len = Buffer.byteLength(data);\n    if (len === 0) {\n        throw Error('invalid blob data');\n    }\n    if (len > MAX_USEFUL_BYTES_PER_TX) {\n        throw Error('blob data is too large');\n    }\n    const blobs_len = Math.ceil(len / USEFUL_BYTES_PER_BLOB);\n    const pdata = get_padded(data, blobs_len);\n    const blobs = [];\n    for (let i = 0; i < blobs_len; i++) {\n        const chunk = pdata.subarray(i * USEFUL_BYTES_PER_BLOB, (i + 1) * USEFUL_BYTES_PER_BLOB);\n        const blob = get_blob(chunk);\n        blobs.push(blob);\n    }\n    return blobs;\n};\nexports.getBlobs = getBlobs;\nconst blobsToCommitments = (blobs) => {\n    const commitments = [];\n    for (const blob of blobs) {\n        commitments.push(Buffer.from(kzg_1.kzg.blobToKzgCommitment(blob)));\n    }\n    return commitments;\n};\nexports.blobsToCommitments = blobsToCommitments;\n/**\n * Converts a vector commitment for a given data blob to its versioned hash.  For 4844, this version\n * number will be 0x01 for KZG vector commitments but could be different if future vector commitment\n * types are introduced\n * @param commitment a vector commitment to a blob\n * @param blobCommitmentVersion the version number corresponding to the type of vector commitment\n * @returns a versioned hash corresponding to a given blob vector commitment\n */\nconst computeVersionedHash = (commitment, blobCommitmentVersion) => {\n    const computedVersionedHash = new Uint8Array(32);\n    computedVersionedHash.set([blobCommitmentVersion], 0);\n    computedVersionedHash.set((0, sha256_1.sha256)(commitment).slice(1), 1);\n    return computedVersionedHash;\n};\nexports.computeVersionedHash = computeVersionedHash;\n/**\n * Generate an array of versioned hashes from corresponding kzg commitments\n * @param commitments array of kzg commitments\n * @returns array of versioned hashes\n * Note: assumes KZG commitments (version 1 version hashes)\n */\nconst commitmentsToVersionedHashes = (commitments) => {\n    const hashes = [];\n    for (const commitment of commitments) {\n        hashes.push(Buffer.from((0, exports.computeVersionedHash)(commitment, 0x01)));\n    }\n    return hashes;\n};\nexports.commitmentsToVersionedHashes = commitmentsToVersionedHashes;\n//# sourceMappingURL=blobHelpers.js.map"]},"metadata":{},"sourceType":"script"}