{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getUint8ByteToBitBooleanArray = exports.BitArray = void 0;\n/** Globally cache this information. @see getUint8ByteToBitBooleanArray */\n\nconst uint8ByteToBitBooleanArrays = new Array(256);\n/**\n * BitArray may be represented as an array of bits or compressed into an array of bytes.\n *\n * **Array of bits**:\n * Require 8.87 bytes per bit, so for 512 bits = 4500 bytes.\n * Are 'faster' to iterate with native tooling but are as fast as array of bytes with precomputed caches.\n *\n * **Array of bytes**:\n * Require an average cost of Uint8Array in JS = 220 bytes for 32 bytes, so for 512 bits = 220 bytes.\n * With precomputed boolean arrays per bytes value are as fast to iterate as an array of bits above.\n *\n * This BitArray implementation will represent data as a Uint8Array since it's very cheap to deserialize and can be as\n * fast to iterate as a native array of booleans, precomputing boolean arrays (total memory cost of 16000 bytes).\n */\n\nclass BitArray {\n  constructor(\n  /** Underlying BitArray Uint8Array data */\n  uint8Array,\n  /** Immutable bitLen of this BitArray */\n  bitLen) {\n    this.uint8Array = uint8Array;\n    this.bitLen = bitLen;\n\n    if (uint8Array.length !== Math.ceil(bitLen / 8)) {\n      throw Error(\"BitArray uint8Array length does not match bitLen\");\n    }\n  }\n  /** Returns a zero'ed BitArray of `bitLen` */\n\n\n  static fromBitLen(bitLen) {\n    return new BitArray(new Uint8Array(Math.ceil(bitLen / 8)), bitLen);\n  }\n  /** Returns a BitArray of `bitLen` with a single bit set to true at position `bitIndex` */\n\n\n  static fromSingleBit(bitLen, bitIndex) {\n    const bitArray = BitArray.fromBitLen(bitLen);\n    bitArray.set(bitIndex, true);\n    return bitArray;\n  }\n  /** Returns a BitArray from an array of booleans representation */\n\n\n  static fromBoolArray(bitBoolArr) {\n    const bitArray = BitArray.fromBitLen(bitBoolArr.length);\n\n    for (let i = 0; i < bitBoolArr.length; i++) {\n      if (bitBoolArr[i] === true) {\n        bitArray.set(i, true);\n      }\n    }\n\n    return bitArray;\n  }\n\n  clone() {\n    // TODO: Benchmark if Uint8Array.slice(0) is the fastest way to copy data here\n    // Buffer.prototype.slice does not copy memory, Enforce Uint8Array usage https://github.com/nodejs/node/issues/28087\n    return new BitArray(Uint8Array.prototype.slice.call(this.uint8Array, 0), this.bitLen);\n  }\n  /**\n   * Get bit value at index `bitIndex`\n   */\n\n\n  get(bitIndex) {\n    const byteIdx = Math.floor(bitIndex / 8);\n    const bitInBit = bitIndex % 8;\n    const mask = 1 << bitInBit;\n    return (this.uint8Array[byteIdx] & mask) === mask;\n  }\n  /**\n   * Set bit value at index `bitIndex`\n   */\n\n\n  set(bitIndex, bit) {\n    if (bitIndex >= this.bitLen) {\n      throw Error(`BitArray set bitIndex ${bitIndex} beyond bitLen ${this.bitLen}`);\n    }\n\n    const byteIdx = Math.floor(bitIndex / 8);\n    const bitInBit = bitIndex % 8;\n    const mask = 1 << bitInBit;\n    let byte = this.uint8Array[byteIdx];\n\n    if (bit) {\n      // For bit in byte, 1,0 OR 1 = 1\n      // byte 100110\n      // mask 010000\n      // res  110110\n      byte |= mask;\n      this.uint8Array[byteIdx] = byte;\n    } else {\n      // For bit in byte, 1,0 OR 1 = 0\n      if ((byte & mask) === mask) {\n        // byte 110110\n        // mask 010000\n        // res  100110\n        byte ^= mask;\n        this.uint8Array[byteIdx] = byte;\n      } else {// Ok, bit is already 0\n      }\n    }\n  }\n  /** Merge two BitArray bitfields with OR. Must have the same bitLen */\n\n\n  mergeOrWith(bitArray2) {\n    if (bitArray2.bitLen !== this.bitLen) {\n      throw Error(\"Must merge BitArrays of same bitLen\");\n    } // Merge bitFields\n\n\n    for (let i = 0; i < this.uint8Array.length; i++) {\n      this.uint8Array[i] = this.uint8Array[i] | bitArray2.uint8Array[i];\n    }\n  }\n  /**\n   * Returns an array with the indexes which have a bit set to true\n   */\n\n\n  intersectValues(values) {\n    const yes = [];\n\n    if (values.length !== this.bitLen) {\n      throw Error(`Must not intersect values of length ${values.length} != bitLen ${this.bitLen}`);\n    }\n\n    const fullByteLen = Math.floor(this.bitLen / 8);\n    const remainderBits = this.bitLen % 8; // Iterate over each byte of bits\n\n    const bytes = this.uint8Array;\n\n    for (let iByte = 0; iByte < fullByteLen; iByte++) {\n      // Get the precomputed boolean array for this byte\n      const booleansInByte = getUint8ByteToBitBooleanArray(bytes[iByte]); // For each bit in the byte check participation and add to indexesSelected array\n\n      for (let iBit = 0; iBit < 8; iBit++) {\n        if (booleansInByte[iBit]) {\n          yes.push(values[iByte * 8 + iBit]);\n        }\n      }\n    }\n\n    if (remainderBits > 0) {\n      // Get the precomputed boolean array for this byte\n      const booleansInByte = getUint8ByteToBitBooleanArray(bytes[fullByteLen]); // For each bit in the byte check participation and add to indexesSelected array\n\n      for (let iBit = 0; iBit < remainderBits; iBit++) {\n        if (booleansInByte[iBit]) {\n          yes.push(values[fullByteLen * 8 + iBit]);\n        }\n      }\n    }\n\n    return yes;\n  }\n  /**\n   * Returns the positions of all bits that are set to true\n   */\n\n\n  getTrueBitIndexes() {\n    const indexes = []; // Iterate over each byte of bits\n\n    const bytes = this.uint8Array;\n\n    for (let iByte = 0, byteLen = bytes.length; iByte < byteLen; iByte++) {\n      // Get the precomputed boolean array for this byte\n      const booleansInByte = getUint8ByteToBitBooleanArray(bytes[iByte]); // For each bit in the byte check participation and add to indexesSelected array\n\n      for (let iBit = 0; iBit < 8; iBit++) {\n        if (booleansInByte[iBit]) {\n          indexes.push(iByte * 8 + iBit);\n        }\n      }\n    }\n\n    return indexes;\n  }\n  /**\n   * Return the position of a single bit set. If no bit set or more than 1 bit set, throws.\n   * @returns\n   *  - number: if there's a single bit set, the number it the single bit set position\n   *  - null: if ERROR_MORE_THAN_ONE_BIT_SET or ERROR_NO_BIT_SET\n   * @throws\n   *  - ERROR_MORE_THAN_ONE_BIT_SET\n   *  - ERROR_NO_BIT_SET\n   */\n\n\n  getSingleTrueBit() {\n    let index = null;\n    const bytes = this.uint8Array; // Iterate over each byte of bits\n\n    for (let iByte = 0, byteLen = bytes.length; iByte < byteLen; iByte++) {\n      // If it's exactly zero, there won't be any indexes, continue early\n      if (bytes[iByte] === 0) {\n        continue;\n      } // Get the precomputed boolean array for this byte\n\n\n      const booleansInByte = getUint8ByteToBitBooleanArray(bytes[iByte]); // For each bit in the byte check participation and add to indexesSelected array\n\n      for (let iBit = 0; iBit < 8; iBit++) {\n        if (booleansInByte[iBit] === true) {\n          if (index !== null) {\n            // ERROR_MORE_THAN_ONE_BIT_SET\n            return null;\n          }\n\n          index = iByte * 8 + iBit;\n        }\n      }\n    }\n\n    if (index === null) {\n      // ERROR_NO_BIT_SET\n      return null;\n    } else {\n      return index;\n    }\n  }\n\n  toBoolArray() {\n    const bitBoolArr = new Array(this.bitLen);\n\n    for (let i = 0; i < this.bitLen; i++) {\n      bitBoolArr[i] = this.get(i);\n    }\n\n    return bitBoolArr;\n  }\n\n}\n\nexports.BitArray = BitArray;\n/**\n * Given a byte (0 -> 255), return a Array of boolean with length = 8, big endian.\n * Ex: 1 => [true false false false false false false false]\n *     5 => [true false true false false fase false false]\n */\n\nfunction getUint8ByteToBitBooleanArray(byte) {\n  if (!uint8ByteToBitBooleanArrays[byte]) {\n    uint8ByteToBitBooleanArrays[byte] = computeUint8ByteToBitBooleanArray(byte);\n  }\n\n  return uint8ByteToBitBooleanArrays[byte];\n}\n\nexports.getUint8ByteToBitBooleanArray = getUint8ByteToBitBooleanArray;\n/** @see getUint8ByteToBitBooleanArray */\n\nfunction computeUint8ByteToBitBooleanArray(byte) {\n  // this returns little endian\n  const binaryStr = byte.toString(2);\n  const binaryLength = binaryStr.length;\n  const bits = new Array(8);\n\n  for (let i = 0; i < 8; i++) {\n    bits[i] = i < binaryLength ? //\n    binaryStr[binaryLength - i - 1] === \"1\" : false;\n  }\n\n  return bits;\n}","map":{"version":3,"sources":["../../src/value/bitArray.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getUint8ByteToBitBooleanArray = exports.BitArray = void 0;\n/** Globally cache this information. @see getUint8ByteToBitBooleanArray */\nconst uint8ByteToBitBooleanArrays = new Array(256);\n/**\n * BitArray may be represented as an array of bits or compressed into an array of bytes.\n *\n * **Array of bits**:\n * Require 8.87 bytes per bit, so for 512 bits = 4500 bytes.\n * Are 'faster' to iterate with native tooling but are as fast as array of bytes with precomputed caches.\n *\n * **Array of bytes**:\n * Require an average cost of Uint8Array in JS = 220 bytes for 32 bytes, so for 512 bits = 220 bytes.\n * With precomputed boolean arrays per bytes value are as fast to iterate as an array of bits above.\n *\n * This BitArray implementation will represent data as a Uint8Array since it's very cheap to deserialize and can be as\n * fast to iterate as a native array of booleans, precomputing boolean arrays (total memory cost of 16000 bytes).\n */\nclass BitArray {\n    constructor(\n    /** Underlying BitArray Uint8Array data */\n    uint8Array, \n    /** Immutable bitLen of this BitArray */\n    bitLen) {\n        this.uint8Array = uint8Array;\n        this.bitLen = bitLen;\n        if (uint8Array.length !== Math.ceil(bitLen / 8)) {\n            throw Error(\"BitArray uint8Array length does not match bitLen\");\n        }\n    }\n    /** Returns a zero'ed BitArray of `bitLen` */\n    static fromBitLen(bitLen) {\n        return new BitArray(new Uint8Array(Math.ceil(bitLen / 8)), bitLen);\n    }\n    /** Returns a BitArray of `bitLen` with a single bit set to true at position `bitIndex` */\n    static fromSingleBit(bitLen, bitIndex) {\n        const bitArray = BitArray.fromBitLen(bitLen);\n        bitArray.set(bitIndex, true);\n        return bitArray;\n    }\n    /** Returns a BitArray from an array of booleans representation */\n    static fromBoolArray(bitBoolArr) {\n        const bitArray = BitArray.fromBitLen(bitBoolArr.length);\n        for (let i = 0; i < bitBoolArr.length; i++) {\n            if (bitBoolArr[i] === true) {\n                bitArray.set(i, true);\n            }\n        }\n        return bitArray;\n    }\n    clone() {\n        // TODO: Benchmark if Uint8Array.slice(0) is the fastest way to copy data here\n        // Buffer.prototype.slice does not copy memory, Enforce Uint8Array usage https://github.com/nodejs/node/issues/28087\n        return new BitArray(Uint8Array.prototype.slice.call(this.uint8Array, 0), this.bitLen);\n    }\n    /**\n     * Get bit value at index `bitIndex`\n     */\n    get(bitIndex) {\n        const byteIdx = Math.floor(bitIndex / 8);\n        const bitInBit = bitIndex % 8;\n        const mask = 1 << bitInBit;\n        return (this.uint8Array[byteIdx] & mask) === mask;\n    }\n    /**\n     * Set bit value at index `bitIndex`\n     */\n    set(bitIndex, bit) {\n        if (bitIndex >= this.bitLen) {\n            throw Error(`BitArray set bitIndex ${bitIndex} beyond bitLen ${this.bitLen}`);\n        }\n        const byteIdx = Math.floor(bitIndex / 8);\n        const bitInBit = bitIndex % 8;\n        const mask = 1 << bitInBit;\n        let byte = this.uint8Array[byteIdx];\n        if (bit) {\n            // For bit in byte, 1,0 OR 1 = 1\n            // byte 100110\n            // mask 010000\n            // res  110110\n            byte |= mask;\n            this.uint8Array[byteIdx] = byte;\n        }\n        else {\n            // For bit in byte, 1,0 OR 1 = 0\n            if ((byte & mask) === mask) {\n                // byte 110110\n                // mask 010000\n                // res  100110\n                byte ^= mask;\n                this.uint8Array[byteIdx] = byte;\n            }\n            else {\n                // Ok, bit is already 0\n            }\n        }\n    }\n    /** Merge two BitArray bitfields with OR. Must have the same bitLen */\n    mergeOrWith(bitArray2) {\n        if (bitArray2.bitLen !== this.bitLen) {\n            throw Error(\"Must merge BitArrays of same bitLen\");\n        }\n        // Merge bitFields\n        for (let i = 0; i < this.uint8Array.length; i++) {\n            this.uint8Array[i] = this.uint8Array[i] | bitArray2.uint8Array[i];\n        }\n    }\n    /**\n     * Returns an array with the indexes which have a bit set to true\n     */\n    intersectValues(values) {\n        const yes = [];\n        if (values.length !== this.bitLen) {\n            throw Error(`Must not intersect values of length ${values.length} != bitLen ${this.bitLen}`);\n        }\n        const fullByteLen = Math.floor(this.bitLen / 8);\n        const remainderBits = this.bitLen % 8;\n        // Iterate over each byte of bits\n        const bytes = this.uint8Array;\n        for (let iByte = 0; iByte < fullByteLen; iByte++) {\n            // Get the precomputed boolean array for this byte\n            const booleansInByte = getUint8ByteToBitBooleanArray(bytes[iByte]);\n            // For each bit in the byte check participation and add to indexesSelected array\n            for (let iBit = 0; iBit < 8; iBit++) {\n                if (booleansInByte[iBit]) {\n                    yes.push(values[iByte * 8 + iBit]);\n                }\n            }\n        }\n        if (remainderBits > 0) {\n            // Get the precomputed boolean array for this byte\n            const booleansInByte = getUint8ByteToBitBooleanArray(bytes[fullByteLen]);\n            // For each bit in the byte check participation and add to indexesSelected array\n            for (let iBit = 0; iBit < remainderBits; iBit++) {\n                if (booleansInByte[iBit]) {\n                    yes.push(values[fullByteLen * 8 + iBit]);\n                }\n            }\n        }\n        return yes;\n    }\n    /**\n     * Returns the positions of all bits that are set to true\n     */\n    getTrueBitIndexes() {\n        const indexes = [];\n        // Iterate over each byte of bits\n        const bytes = this.uint8Array;\n        for (let iByte = 0, byteLen = bytes.length; iByte < byteLen; iByte++) {\n            // Get the precomputed boolean array for this byte\n            const booleansInByte = getUint8ByteToBitBooleanArray(bytes[iByte]);\n            // For each bit in the byte check participation and add to indexesSelected array\n            for (let iBit = 0; iBit < 8; iBit++) {\n                if (booleansInByte[iBit]) {\n                    indexes.push(iByte * 8 + iBit);\n                }\n            }\n        }\n        return indexes;\n    }\n    /**\n     * Return the position of a single bit set. If no bit set or more than 1 bit set, throws.\n     * @returns\n     *  - number: if there's a single bit set, the number it the single bit set position\n     *  - null: if ERROR_MORE_THAN_ONE_BIT_SET or ERROR_NO_BIT_SET\n     * @throws\n     *  - ERROR_MORE_THAN_ONE_BIT_SET\n     *  - ERROR_NO_BIT_SET\n     */\n    getSingleTrueBit() {\n        let index = null;\n        const bytes = this.uint8Array;\n        // Iterate over each byte of bits\n        for (let iByte = 0, byteLen = bytes.length; iByte < byteLen; iByte++) {\n            // If it's exactly zero, there won't be any indexes, continue early\n            if (bytes[iByte] === 0) {\n                continue;\n            }\n            // Get the precomputed boolean array for this byte\n            const booleansInByte = getUint8ByteToBitBooleanArray(bytes[iByte]);\n            // For each bit in the byte check participation and add to indexesSelected array\n            for (let iBit = 0; iBit < 8; iBit++) {\n                if (booleansInByte[iBit] === true) {\n                    if (index !== null) {\n                        // ERROR_MORE_THAN_ONE_BIT_SET\n                        return null;\n                    }\n                    index = iByte * 8 + iBit;\n                }\n            }\n        }\n        if (index === null) {\n            // ERROR_NO_BIT_SET\n            return null;\n        }\n        else {\n            return index;\n        }\n    }\n    toBoolArray() {\n        const bitBoolArr = new Array(this.bitLen);\n        for (let i = 0; i < this.bitLen; i++) {\n            bitBoolArr[i] = this.get(i);\n        }\n        return bitBoolArr;\n    }\n}\nexports.BitArray = BitArray;\n/**\n * Given a byte (0 -> 255), return a Array of boolean with length = 8, big endian.\n * Ex: 1 => [true false false false false false false false]\n *     5 => [true false true false false fase false false]\n */\nfunction getUint8ByteToBitBooleanArray(byte) {\n    if (!uint8ByteToBitBooleanArrays[byte]) {\n        uint8ByteToBitBooleanArrays[byte] = computeUint8ByteToBitBooleanArray(byte);\n    }\n    return uint8ByteToBitBooleanArrays[byte];\n}\nexports.getUint8ByteToBitBooleanArray = getUint8ByteToBitBooleanArray;\n/** @see getUint8ByteToBitBooleanArray */\nfunction computeUint8ByteToBitBooleanArray(byte) {\n    // this returns little endian\n    const binaryStr = byte.toString(2);\n    const binaryLength = binaryStr.length;\n    const bits = new Array(8);\n    for (let i = 0; i < 8; i++) {\n        bits[i] =\n            i < binaryLength\n                ? //\n                    binaryStr[binaryLength - i - 1] === \"1\"\n                : false;\n    }\n    return bits;\n}\n//# sourceMappingURL=bitArray.js.map"]},"metadata":{},"sourceType":"script"}