{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.packedNodeRootsToBytes = exports.packedRootsBytesToLeafNodes = exports.packedRootsBytesToNode = void 0;\n\nconst subtree_1 = require(\"./subtree\");\n\nconst node_1 = require(\"./node\");\n\nfunction packedRootsBytesToNode(depth, dataView, start, end) {\n  const leafNodes = packedRootsBytesToLeafNodes(dataView, start, end);\n  return subtree_1.subtreeFillToContents(leafNodes, depth);\n}\n\nexports.packedRootsBytesToNode = packedRootsBytesToNode;\n/**\n * Optimized deserialization of linear bytes to consecutive leaf nodes\n */\n\nfunction packedRootsBytesToLeafNodes(dataView, start, end) {\n  const size = end - start; // If the offset in data is not a multiple of 4, Uint32Array can't be used\n  // > start offset of Uint32Array should be a multiple of 4\n  // NOTE: Performance tests show that using a DataView is as fast as Uint32Array\n\n  const fullNodeCount = Math.floor(size / 32);\n  const leafNodes = new Array(Math.ceil(size / 32)); // Efficiently construct the tree writing to hashObjects directly\n  // TODO: Optimize, with this approach each h property is written twice\n\n  for (let i = 0; i < fullNodeCount; i++) {\n    const offset = start + i * 32;\n    leafNodes[i] = new node_1.LeafNode(dataView.getInt32(offset + 0, true), dataView.getInt32(offset + 4, true), dataView.getInt32(offset + 8, true), dataView.getInt32(offset + 12, true), dataView.getInt32(offset + 16, true), dataView.getInt32(offset + 20, true), dataView.getInt32(offset + 24, true), dataView.getInt32(offset + 28, true));\n  } // Consider that the last node may only include partial data\n\n\n  const remainderBytes = size % 32; // Last node\n\n  if (remainderBytes > 0) {\n    const node = new node_1.LeafNode(0, 0, 0, 0, 0, 0, 0, 0);\n    leafNodes[fullNodeCount] = node; // Loop to dynamically copy the full h values\n\n    const fullHCount = Math.floor(remainderBytes / 4);\n\n    for (let h = 0; h < fullHCount; h++) {\n      node_1.setNodeH(node, h, dataView.getInt32(start + fullNodeCount * 32 + h * 4, true));\n    }\n\n    const remainderUint32 = size % 4;\n\n    if (remainderUint32 > 0) {\n      let h = 0;\n\n      for (let i = 0; i < remainderUint32; i++) {\n        h |= dataView.getUint8(start + size - remainderUint32 + i) << i * 8;\n      }\n\n      node_1.setNodeH(node, fullHCount, h);\n    }\n  }\n\n  return leafNodes;\n}\n\nexports.packedRootsBytesToLeafNodes = packedRootsBytesToLeafNodes;\n/**\n * Optimized serialization of consecutive leave nodes to linear bytes\n */\n\nfunction packedNodeRootsToBytes(dataView, start, size, nodes) {\n  // If the offset in data is not a multiple of 4, Uint32Array can't be used\n  // > start offset of Uint32Array should be a multiple of 4\n  // NOTE: Performance tests show that using a DataView is as fast as Uint32Array\n  // Consider that the last node may only include partial data\n  const remainderBytes = size % 32; // Full nodes\n  // Efficiently get hashObjects data into data\n\n  const fullNodeCount = Math.floor(size / 32);\n\n  for (let i = 0; i < fullNodeCount; i++) {\n    const node = nodes[i];\n    const offset = start + i * 32;\n    dataView.setInt32(offset + 0, node.h0, true);\n    dataView.setInt32(offset + 4, node.h1, true);\n    dataView.setInt32(offset + 8, node.h2, true);\n    dataView.setInt32(offset + 12, node.h3, true);\n    dataView.setInt32(offset + 16, node.h4, true);\n    dataView.setInt32(offset + 20, node.h5, true);\n    dataView.setInt32(offset + 24, node.h6, true);\n    dataView.setInt32(offset + 28, node.h7, true);\n  } // Last node\n\n\n  if (remainderBytes > 0) {\n    const node = nodes[fullNodeCount]; // Loop to dynamically copy the full h values\n\n    const fullHCount = Math.floor(remainderBytes / 4);\n\n    for (let h = 0; h < fullHCount; h++) {\n      dataView.setInt32(start + fullNodeCount * 32 + h * 4, node_1.getNodeH(node, h), true);\n    }\n\n    const remainderUint32 = size % 4;\n\n    if (remainderUint32 > 0) {\n      const h = node_1.getNodeH(node, fullHCount);\n\n      for (let i = 0; i < remainderUint32; i++) {\n        dataView.setUint8(start + size - remainderUint32 + i, h >> i * 8 & 0xff);\n      }\n    }\n  }\n}\n\nexports.packedNodeRootsToBytes = packedNodeRootsToBytes;","map":{"version":3,"sources":["/Users/dev3rs/provipdiploma/node_modules/@chainsafe/persistent-merkle-tree/lib/packedNode.js"],"names":["Object","defineProperty","exports","value","packedNodeRootsToBytes","packedRootsBytesToLeafNodes","packedRootsBytesToNode","subtree_1","require","node_1","depth","dataView","start","end","leafNodes","subtreeFillToContents","size","fullNodeCount","Math","floor","Array","ceil","i","offset","LeafNode","getInt32","remainderBytes","node","fullHCount","h","setNodeH","remainderUint32","getUint8","nodes","setInt32","h0","h1","h2","h3","h4","h5","h6","h7","getNodeH","setUint8"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.packedNodeRootsToBytes = exports.packedRootsBytesToLeafNodes = exports.packedRootsBytesToNode = void 0;\nconst subtree_1 = require(\"./subtree\");\nconst node_1 = require(\"./node\");\nfunction packedRootsBytesToNode(depth, dataView, start, end) {\n    const leafNodes = packedRootsBytesToLeafNodes(dataView, start, end);\n    return subtree_1.subtreeFillToContents(leafNodes, depth);\n}\nexports.packedRootsBytesToNode = packedRootsBytesToNode;\n/**\n * Optimized deserialization of linear bytes to consecutive leaf nodes\n */\nfunction packedRootsBytesToLeafNodes(dataView, start, end) {\n    const size = end - start;\n    // If the offset in data is not a multiple of 4, Uint32Array can't be used\n    // > start offset of Uint32Array should be a multiple of 4\n    // NOTE: Performance tests show that using a DataView is as fast as Uint32Array\n    const fullNodeCount = Math.floor(size / 32);\n    const leafNodes = new Array(Math.ceil(size / 32));\n    // Efficiently construct the tree writing to hashObjects directly\n    // TODO: Optimize, with this approach each h property is written twice\n    for (let i = 0; i < fullNodeCount; i++) {\n        const offset = start + i * 32;\n        leafNodes[i] = new node_1.LeafNode(dataView.getInt32(offset + 0, true), dataView.getInt32(offset + 4, true), dataView.getInt32(offset + 8, true), dataView.getInt32(offset + 12, true), dataView.getInt32(offset + 16, true), dataView.getInt32(offset + 20, true), dataView.getInt32(offset + 24, true), dataView.getInt32(offset + 28, true));\n    }\n    // Consider that the last node may only include partial data\n    const remainderBytes = size % 32;\n    // Last node\n    if (remainderBytes > 0) {\n        const node = new node_1.LeafNode(0, 0, 0, 0, 0, 0, 0, 0);\n        leafNodes[fullNodeCount] = node;\n        // Loop to dynamically copy the full h values\n        const fullHCount = Math.floor(remainderBytes / 4);\n        for (let h = 0; h < fullHCount; h++) {\n            node_1.setNodeH(node, h, dataView.getInt32(start + fullNodeCount * 32 + h * 4, true));\n        }\n        const remainderUint32 = size % 4;\n        if (remainderUint32 > 0) {\n            let h = 0;\n            for (let i = 0; i < remainderUint32; i++) {\n                h |= dataView.getUint8(start + size - remainderUint32 + i) << (i * 8);\n            }\n            node_1.setNodeH(node, fullHCount, h);\n        }\n    }\n    return leafNodes;\n}\nexports.packedRootsBytesToLeafNodes = packedRootsBytesToLeafNodes;\n/**\n * Optimized serialization of consecutive leave nodes to linear bytes\n */\nfunction packedNodeRootsToBytes(dataView, start, size, nodes) {\n    // If the offset in data is not a multiple of 4, Uint32Array can't be used\n    // > start offset of Uint32Array should be a multiple of 4\n    // NOTE: Performance tests show that using a DataView is as fast as Uint32Array\n    // Consider that the last node may only include partial data\n    const remainderBytes = size % 32;\n    // Full nodes\n    // Efficiently get hashObjects data into data\n    const fullNodeCount = Math.floor(size / 32);\n    for (let i = 0; i < fullNodeCount; i++) {\n        const node = nodes[i];\n        const offset = start + i * 32;\n        dataView.setInt32(offset + 0, node.h0, true);\n        dataView.setInt32(offset + 4, node.h1, true);\n        dataView.setInt32(offset + 8, node.h2, true);\n        dataView.setInt32(offset + 12, node.h3, true);\n        dataView.setInt32(offset + 16, node.h4, true);\n        dataView.setInt32(offset + 20, node.h5, true);\n        dataView.setInt32(offset + 24, node.h6, true);\n        dataView.setInt32(offset + 28, node.h7, true);\n    }\n    // Last node\n    if (remainderBytes > 0) {\n        const node = nodes[fullNodeCount];\n        // Loop to dynamically copy the full h values\n        const fullHCount = Math.floor(remainderBytes / 4);\n        for (let h = 0; h < fullHCount; h++) {\n            dataView.setInt32(start + fullNodeCount * 32 + h * 4, node_1.getNodeH(node, h), true);\n        }\n        const remainderUint32 = size % 4;\n        if (remainderUint32 > 0) {\n            const h = node_1.getNodeH(node, fullHCount);\n            for (let i = 0; i < remainderUint32; i++) {\n                dataView.setUint8(start + size - remainderUint32 + i, (h >> (i * 8)) & 0xff);\n            }\n        }\n    }\n}\nexports.packedNodeRootsToBytes = packedNodeRootsToBytes;\n"]},"metadata":{},"sourceType":"script"}