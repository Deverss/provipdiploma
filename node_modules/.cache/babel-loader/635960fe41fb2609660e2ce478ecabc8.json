{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TransactionFactory = void 0;\n\nconst util_1 = require(\"@ethereumjs/util\");\n\nconst providers_1 = require(\"@ethersproject/providers\");\n\nconst eip1559Transaction_1 = require(\"./eip1559Transaction\");\n\nconst eip2930Transaction_1 = require(\"./eip2930Transaction\");\n\nconst eip4844Transaction_1 = require(\"./eip4844Transaction\");\n\nconst fromRpc_1 = require(\"./fromRpc\");\n\nconst legacyTransaction_1 = require(\"./legacyTransaction\");\n\nclass TransactionFactory {\n  // It is not possible to instantiate a TransactionFactory object.\n  constructor() {}\n  /**\n   * Create a transaction from a `txData` object\n   *\n   * @param txData - The transaction data. The `type` field will determine which transaction type is returned (if undefined, creates a legacy transaction)\n   * @param txOptions - Options to pass on to the constructor of the transaction\n   */\n\n\n  static fromTxData(txData, txOptions = {}) {\n    if (!('type' in txData) || txData.type === undefined) {\n      // Assume legacy transaction\n      return legacyTransaction_1.Transaction.fromTxData(txData, txOptions);\n    } else {\n      const txType = Number((0, util_1.bufferToBigInt)((0, util_1.toBuffer)(txData.type)));\n\n      if (txType === 0) {\n        return legacyTransaction_1.Transaction.fromTxData(txData, txOptions);\n      } else if (txType === 1) {\n        return eip2930Transaction_1.AccessListEIP2930Transaction.fromTxData(txData, txOptions);\n      } else if (txType === 2) {\n        return eip1559Transaction_1.FeeMarketEIP1559Transaction.fromTxData(txData, txOptions);\n      } else if (txType === 5) {\n        return eip4844Transaction_1.BlobEIP4844Transaction.fromTxData(txData, txOptions);\n      } else {\n        throw new Error(`Tx instantiation with type ${txType} not supported`);\n      }\n    }\n  }\n  /**\n   * This method tries to decode serialized data.\n   *\n   * @param data - The data Buffer\n   * @param txOptions - The transaction options\n   */\n\n\n  static fromSerializedData(data, txOptions = {}) {\n    if (data[0] <= 0x7f) {\n      // Determine the type.\n      switch (data[0]) {\n        case 1:\n          return eip2930Transaction_1.AccessListEIP2930Transaction.fromSerializedTx(data, txOptions);\n\n        case 2:\n          return eip1559Transaction_1.FeeMarketEIP1559Transaction.fromSerializedTx(data, txOptions);\n\n        case 5:\n          return eip4844Transaction_1.BlobEIP4844Transaction.fromSerializedTx(data, txOptions);\n\n        default:\n          throw new Error(`TypedTransaction with ID ${data[0]} unknown`);\n      }\n    } else {\n      return legacyTransaction_1.Transaction.fromSerializedTx(data, txOptions);\n    }\n  }\n  /**\n   * When decoding a BlockBody, in the transactions field, a field is either:\n   * A Buffer (a TypedTransaction - encoded as TransactionType || rlp(TransactionPayload))\n   * A Buffer[] (Legacy Transaction)\n   * This method returns the right transaction.\n   *\n   * @param data - A Buffer or Buffer[]\n   * @param txOptions - The transaction options\n   */\n\n\n  static fromBlockBodyData(data, txOptions = {}) {\n    if (Buffer.isBuffer(data)) {\n      return this.fromSerializedData(data, txOptions);\n    } else if (Array.isArray(data)) {\n      // It is a legacy transaction\n      return legacyTransaction_1.Transaction.fromValuesArray(data, txOptions);\n    } else {\n      throw new Error('Cannot decode transaction: unknown type input');\n    }\n  }\n  /**\n   *  Method to retrieve a transaction from the provider\n   * @param provider - An Ethers JsonRPCProvider\n   * @param txHash - Transaction hash\n   * @param txOptions - The transaction options\n   * @returns the transaction specified by `txHash`\n   */\n\n\n  static async fromEthersProvider(provider, txHash, txOptions) {\n    const prov = typeof provider === 'string' ? new providers_1.JsonRpcProvider(provider) : provider;\n    const txData = await prov.send('eth_getTransactionByHash', [txHash]);\n    const normedTx = (0, fromRpc_1.normalizeTxParams)(txData);\n    return TransactionFactory.fromTxData(normedTx, txOptions);\n  }\n\n}\n\nexports.TransactionFactory = TransactionFactory;","map":{"version":3,"sources":["../src/transactionFactory.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TransactionFactory = void 0;\nconst util_1 = require(\"@ethereumjs/util\");\nconst providers_1 = require(\"@ethersproject/providers\");\nconst eip1559Transaction_1 = require(\"./eip1559Transaction\");\nconst eip2930Transaction_1 = require(\"./eip2930Transaction\");\nconst eip4844Transaction_1 = require(\"./eip4844Transaction\");\nconst fromRpc_1 = require(\"./fromRpc\");\nconst legacyTransaction_1 = require(\"./legacyTransaction\");\nclass TransactionFactory {\n    // It is not possible to instantiate a TransactionFactory object.\n    constructor() { }\n    /**\n     * Create a transaction from a `txData` object\n     *\n     * @param txData - The transaction data. The `type` field will determine which transaction type is returned (if undefined, creates a legacy transaction)\n     * @param txOptions - Options to pass on to the constructor of the transaction\n     */\n    static fromTxData(txData, txOptions = {}) {\n        if (!('type' in txData) || txData.type === undefined) {\n            // Assume legacy transaction\n            return legacyTransaction_1.Transaction.fromTxData(txData, txOptions);\n        }\n        else {\n            const txType = Number((0, util_1.bufferToBigInt)((0, util_1.toBuffer)(txData.type)));\n            if (txType === 0) {\n                return legacyTransaction_1.Transaction.fromTxData(txData, txOptions);\n            }\n            else if (txType === 1) {\n                return eip2930Transaction_1.AccessListEIP2930Transaction.fromTxData(txData, txOptions);\n            }\n            else if (txType === 2) {\n                return eip1559Transaction_1.FeeMarketEIP1559Transaction.fromTxData(txData, txOptions);\n            }\n            else if (txType === 5) {\n                return eip4844Transaction_1.BlobEIP4844Transaction.fromTxData(txData, txOptions);\n            }\n            else {\n                throw new Error(`Tx instantiation with type ${txType} not supported`);\n            }\n        }\n    }\n    /**\n     * This method tries to decode serialized data.\n     *\n     * @param data - The data Buffer\n     * @param txOptions - The transaction options\n     */\n    static fromSerializedData(data, txOptions = {}) {\n        if (data[0] <= 0x7f) {\n            // Determine the type.\n            switch (data[0]) {\n                case 1:\n                    return eip2930Transaction_1.AccessListEIP2930Transaction.fromSerializedTx(data, txOptions);\n                case 2:\n                    return eip1559Transaction_1.FeeMarketEIP1559Transaction.fromSerializedTx(data, txOptions);\n                case 5:\n                    return eip4844Transaction_1.BlobEIP4844Transaction.fromSerializedTx(data, txOptions);\n                default:\n                    throw new Error(`TypedTransaction with ID ${data[0]} unknown`);\n            }\n        }\n        else {\n            return legacyTransaction_1.Transaction.fromSerializedTx(data, txOptions);\n        }\n    }\n    /**\n     * When decoding a BlockBody, in the transactions field, a field is either:\n     * A Buffer (a TypedTransaction - encoded as TransactionType || rlp(TransactionPayload))\n     * A Buffer[] (Legacy Transaction)\n     * This method returns the right transaction.\n     *\n     * @param data - A Buffer or Buffer[]\n     * @param txOptions - The transaction options\n     */\n    static fromBlockBodyData(data, txOptions = {}) {\n        if (Buffer.isBuffer(data)) {\n            return this.fromSerializedData(data, txOptions);\n        }\n        else if (Array.isArray(data)) {\n            // It is a legacy transaction\n            return legacyTransaction_1.Transaction.fromValuesArray(data, txOptions);\n        }\n        else {\n            throw new Error('Cannot decode transaction: unknown type input');\n        }\n    }\n    /**\n     *  Method to retrieve a transaction from the provider\n     * @param provider - An Ethers JsonRPCProvider\n     * @param txHash - Transaction hash\n     * @param txOptions - The transaction options\n     * @returns the transaction specified by `txHash`\n     */\n    static async fromEthersProvider(provider, txHash, txOptions) {\n        const prov = typeof provider === 'string' ? new providers_1.JsonRpcProvider(provider) : provider;\n        const txData = await prov.send('eth_getTransactionByHash', [txHash]);\n        const normedTx = (0, fromRpc_1.normalizeTxParams)(txData);\n        return TransactionFactory.fromTxData(normedTx, txOptions);\n    }\n}\nexports.TransactionFactory = TransactionFactory;\n//# sourceMappingURL=transactionFactory.js.map"]},"metadata":{},"sourceType":"script"}