{"ast":null,"code":"import _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport { SafeEventEmitter } from '@toruslabs/openlogin-jrpc';\nimport { ADAPTER_STATUS, WalletInitializationError, log, CHAIN_NAMESPACES, storageAvailable, getChainConfig, ADAPTER_NAMESPACES, WALLET_ADAPTERS, WalletLoginError, ADAPTER_EVENTS } from '@web3auth/base';\nimport { PLUGIN_NAMESPACES } from '@web3auth/base-plugin';\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n}\n\nconst ADAPTER_CACHE_KEY = \"Web3Auth-cachedAdapter\";\n\nclass Web3AuthNoModal extends SafeEventEmitter {\n  constructor(options) {\n    var _options$chainConfig, _options$chainConfig2, _options$chainConfig3, _options$chainConfig4;\n\n    super();\n\n    _defineProperty(this, \"coreOptions\", void 0);\n\n    _defineProperty(this, \"connectedAdapterName\", null);\n\n    _defineProperty(this, \"status\", ADAPTER_STATUS.NOT_READY);\n\n    _defineProperty(this, \"cachedAdapter\", null);\n\n    _defineProperty(this, \"walletAdapters\", {});\n\n    _defineProperty(this, \"plugins\", {});\n\n    _defineProperty(this, \"storage\", \"localStorage\");\n\n    if (!options.clientId) throw WalletInitializationError.invalidParams(\"Please provide a valid clientId in constructor\");\n    if (options.enableLogging) log.enableAll();else log.disableAll();\n    if (!((_options$chainConfig = options.chainConfig) !== null && _options$chainConfig !== void 0 && _options$chainConfig.chainNamespace) || !Object.values(CHAIN_NAMESPACES).includes((_options$chainConfig2 = options.chainConfig) === null || _options$chainConfig2 === void 0 ? void 0 : _options$chainConfig2.chainNamespace)) throw WalletInitializationError.invalidParams(\"Please provide a valid chainNamespace in chainConfig\");\n    if (options.storageKey === \"session\") this.storage = \"sessionStorage\";\n    this.cachedAdapter = storageAvailable(this.storage) ? window[this.storage].getItem(ADAPTER_CACHE_KEY) : null;\n    this.coreOptions = _objectSpread(_objectSpread({}, options), {}, {\n      chainConfig: _objectSpread(_objectSpread({}, getChainConfig((_options$chainConfig3 = options.chainConfig) === null || _options$chainConfig3 === void 0 ? void 0 : _options$chainConfig3.chainNamespace, (_options$chainConfig4 = options.chainConfig) === null || _options$chainConfig4 === void 0 ? void 0 : _options$chainConfig4.chainId) || {}), options.chainConfig)\n    });\n    this.subscribeToAdapterEvents = this.subscribeToAdapterEvents.bind(this);\n  }\n\n  get provider() {\n    if (this.status === ADAPTER_STATUS.CONNECTED && this.connectedAdapterName) {\n      const adapter = this.walletAdapters[this.connectedAdapterName];\n      return adapter.provider;\n    }\n\n    return null;\n  }\n\n  set provider(_) {\n    throw new Error(\"Not implemented\");\n  }\n\n  async init() {\n    const initPromises = Object.keys(this.walletAdapters).map(adapterName => {\n      this.subscribeToAdapterEvents(this.walletAdapters[adapterName]); // if adapter doesn't have any chain config yet thn set it based on provided namespace and chainId.\n      // if no chainNamespace or chainId is being provided, it will connect with mainnet.\n\n      if (!this.walletAdapters[adapterName].chainConfigProxy) {\n        const providedChainConfig = this.coreOptions.chainConfig;\n        if (!providedChainConfig.chainNamespace) throw WalletInitializationError.invalidParams(\"Please provide chainNamespace in chainConfig\");\n        this.walletAdapters[adapterName].setAdapterSettings({\n          chainConfig: providedChainConfig,\n          sessionTime: this.coreOptions.sessionTime,\n          clientId: this.coreOptions.clientId,\n          web3AuthNetwork: this.coreOptions.web3AuthNetwork,\n          useCoreKitKey: this.coreOptions.useCoreKitKey\n        });\n      } else {\n        this.walletAdapters[adapterName].setAdapterSettings({\n          sessionTime: this.coreOptions.sessionTime,\n          clientId: this.coreOptions.clientId,\n          web3AuthNetwork: this.coreOptions.web3AuthNetwork,\n          useCoreKitKey: this.coreOptions.useCoreKitKey\n        });\n      }\n\n      return this.walletAdapters[adapterName].init({\n        autoConnect: this.cachedAdapter === adapterName\n      }).catch(e => log.error(e));\n    });\n    this.status = ADAPTER_STATUS.READY;\n    await Promise.all(initPromises);\n  }\n\n  configureAdapter(adapter) {\n    this.checkInitRequirements();\n    const providedChainConfig = this.coreOptions.chainConfig;\n    if (!providedChainConfig.chainNamespace) throw WalletInitializationError.invalidParams(\"Please provide chainNamespace in chainConfig\");\n    const adapterAlreadyExists = this.walletAdapters[adapter.name];\n    if (adapterAlreadyExists) throw WalletInitializationError.duplicateAdapterError(`Wallet adapter for ${adapter.name} already exists`);\n    if (adapter.adapterNamespace !== ADAPTER_NAMESPACES.MULTICHAIN && adapter.adapterNamespace !== providedChainConfig.chainNamespace) throw WalletInitializationError.incompatibleChainNameSpace(`This wallet adapter belongs to ${adapter.adapterNamespace} which is incompatible with currently used namespace: ${providedChainConfig.chainNamespace}`);\n\n    if (adapter.name === WALLET_ADAPTERS.WALLET_CONNECT_V2 && this.walletAdapters[WALLET_ADAPTERS.WALLET_CONNECT_V1]) {\n      throw WalletInitializationError.invalidParams(\"Either one of wallet connect v2 or wallet connect v1 can be used, wallet connect v1 is already added to adapter lists.\");\n    }\n\n    if (adapter.name === WALLET_ADAPTERS.WALLET_CONNECT_V1 && this.walletAdapters[WALLET_ADAPTERS.WALLET_CONNECT_V2]) {\n      throw WalletInitializationError.invalidParams(\"Either one of wallet connect v2 or wallet connect v1 can be used, wallet connect v2 is already added to adapter lists.\");\n    }\n\n    if (adapter.adapterNamespace === ADAPTER_NAMESPACES.MULTICHAIN && adapter.currentChainNamespace && providedChainConfig.chainNamespace !== adapter.currentChainNamespace) {\n      // chainConfig checks are already validated in constructor so using typecast is safe here.\n      adapter.setAdapterSettings({\n        chainConfig: providedChainConfig\n      });\n    }\n\n    this.walletAdapters[adapter.name] = adapter;\n    return this;\n  }\n\n  clearCache() {\n    if (!storageAvailable(this.storage)) return;\n    window[this.storage].removeItem(ADAPTER_CACHE_KEY);\n    this.cachedAdapter = null;\n  }\n\n  async addChain(chainConfig) {\n    if (this.status !== ADAPTER_STATUS.CONNECTED || !this.connectedAdapterName) throw WalletLoginError.notConnectedError(`No wallet is connected`);\n    return this.walletAdapters[this.connectedAdapterName].addChain(chainConfig);\n  }\n\n  async switchChain(params) {\n    if (this.status !== ADAPTER_STATUS.CONNECTED || !this.connectedAdapterName) throw WalletLoginError.notConnectedError(`No wallet is connected`);\n    return this.walletAdapters[this.connectedAdapterName].switchChain(params);\n  }\n  /**\n   * Connect to a specific wallet adapter\n   * @param walletName - Key of the walletAdapter to use.\n   */\n\n\n  async connectTo(walletName, loginParams) {\n    if (!this.walletAdapters[walletName]) throw WalletInitializationError.notFound(`Please add wallet adapter for ${walletName} wallet, before connecting`);\n    const provider = await this.walletAdapters[walletName].connect(loginParams);\n    return provider;\n  }\n\n  async logout() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n      cleanup: false\n    };\n    if (this.status !== ADAPTER_STATUS.CONNECTED || !this.connectedAdapterName) throw WalletLoginError.notConnectedError(`No wallet is connected`);\n    await this.walletAdapters[this.connectedAdapterName].disconnect(options);\n  }\n\n  async getUserInfo() {\n    log.debug(\"Getting user info\", this.status, this.connectedAdapterName);\n    if (this.status !== ADAPTER_STATUS.CONNECTED || !this.connectedAdapterName) throw WalletLoginError.notConnectedError(`No wallet is connected`);\n    return this.walletAdapters[this.connectedAdapterName].getUserInfo();\n  }\n\n  async authenticateUser() {\n    if (this.status !== ADAPTER_STATUS.CONNECTED || !this.connectedAdapterName) throw WalletLoginError.notConnectedError(`No wallet is connected`);\n    return this.walletAdapters[this.connectedAdapterName].authenticateUser();\n  }\n\n  async addPlugin(plugin) {\n    if (this.plugins[plugin.name]) throw new Error(`Plugin ${plugin.name} already exist`);\n    if (plugin.pluginNamespace !== PLUGIN_NAMESPACES.MULTICHAIN && plugin.pluginNamespace !== this.coreOptions.chainConfig.chainNamespace) throw new Error(`This plugin belongs to ${plugin.pluginNamespace} namespace which is incompatible with currently used namespace: ${this.coreOptions.chainConfig.chainNamespace}`);\n    this.plugins[plugin.name] = plugin;\n    return this;\n  }\n\n  subscribeToAdapterEvents(walletAdapter) {\n    walletAdapter.on(ADAPTER_EVENTS.CONNECTED, async data => {\n      this.status = ADAPTER_STATUS.CONNECTED;\n      this.connectedAdapterName = data.adapter;\n      this.cacheWallet(data.adapter);\n      log.debug(\"connected\", this.status, this.connectedAdapterName);\n      Object.values(this.plugins).map(async plugin => {\n        try {\n          if (!plugin.SUPPORTED_ADAPTERS.includes(data.adapter)) {\n            return;\n          }\n\n          await plugin.initWithWeb3Auth(this);\n          await plugin.connect();\n        } catch (error) {\n          // swallow error if connector adapter doesn't supports this plugin.\n          if (error.code === 5211) {\n            return;\n          }\n\n          log.error(error);\n        }\n      });\n      this.emit(ADAPTER_EVENTS.CONNECTED, _objectSpread({}, data));\n    });\n    walletAdapter.on(ADAPTER_EVENTS.DISCONNECTED, async data => {\n      // get back to ready state for rehydrating.\n      this.status = ADAPTER_STATUS.READY;\n\n      if (storageAvailable(this.storage)) {\n        const cachedAdapter = window[this.storage].getItem(ADAPTER_CACHE_KEY);\n\n        if (this.connectedAdapterName === cachedAdapter) {\n          this.clearCache();\n        }\n      }\n\n      log.debug(\"disconnected\", this.status, this.connectedAdapterName);\n      await Promise.all(Object.values(this.plugins).map(plugin => {\n        return plugin.disconnect().catch(error => {\n          // swallow error if adapter doesn't supports this plugin.\n          if (error.code === 5211) {\n            return;\n          } // throw error;\n\n\n          log.error(error);\n        });\n      }));\n      this.connectedAdapterName = null;\n      this.emit(ADAPTER_EVENTS.DISCONNECTED, data);\n    });\n    walletAdapter.on(ADAPTER_EVENTS.CONNECTING, data => {\n      this.status = ADAPTER_STATUS.CONNECTING;\n      this.emit(ADAPTER_EVENTS.CONNECTING, data);\n      log.debug(\"connecting\", this.status, this.connectedAdapterName);\n    });\n    walletAdapter.on(ADAPTER_EVENTS.ERRORED, data => {\n      this.status = ADAPTER_STATUS.ERRORED;\n      this.clearCache();\n      this.emit(ADAPTER_EVENTS.ERRORED, data);\n      log.debug(\"errored\", this.status, this.connectedAdapterName);\n    });\n    walletAdapter.on(ADAPTER_EVENTS.ADAPTER_DATA_UPDATED, data => {\n      log.debug(\"adapter data updated\", data);\n      this.emit(ADAPTER_EVENTS.ADAPTER_DATA_UPDATED, data);\n    });\n    walletAdapter.on(ADAPTER_EVENTS.CACHE_CLEAR, data => {\n      log.debug(\"adapter cache clear\", data);\n\n      if (storageAvailable(this.storage)) {\n        this.clearCache();\n      }\n    });\n  }\n\n  checkInitRequirements() {\n    if (this.status === ADAPTER_STATUS.CONNECTING) throw WalletInitializationError.notReady(\"Already pending connection\");\n    if (this.status === ADAPTER_STATUS.CONNECTED) throw WalletInitializationError.notReady(\"Already connected\");\n    if (this.status === ADAPTER_STATUS.READY) throw WalletInitializationError.notReady(\"Adapter is already initialized\");\n  }\n\n  cacheWallet(walletName) {\n    if (!storageAvailable(this.storage)) return;\n    window[this.storage].setItem(ADAPTER_CACHE_KEY, walletName);\n    this.cachedAdapter = walletName;\n  }\n\n}\n\nexport { Web3AuthNoModal };","map":{"version":3,"sources":["../src/noModal.ts"],"names":["ADAPTER_CACHE_KEY","Web3AuthNoModal","SafeEventEmitter","_defineProperty","ADAPTER_STATUS","NOT_READY","constructor","options","clientId","WalletInitializationError","invalidParams","enableLogging","log","enableAll","disableAll","chainConfig","chainNamespace","Object","values","CHAIN_NAMESPACES","includes","storageKey","storage","cachedAdapter","storageAvailable","window","getItem","coreOptions","getChainConfig","chainId","subscribeToAdapterEvents","bind","provider","status","CONNECTED","connectedAdapterName","adapter","walletAdapters","_","Error","init","initPromises","keys","map","adapterName","chainConfigProxy","providedChainConfig","setAdapterSettings","sessionTime","web3AuthNetwork","useCoreKitKey","autoConnect","catch","e","error","READY","Promise","all","configureAdapter","checkInitRequirements","adapterAlreadyExists","name","duplicateAdapterError","adapterNamespace","ADAPTER_NAMESPACES","MULTICHAIN","incompatibleChainNameSpace","WALLET_ADAPTERS","WALLET_CONNECT_V2","WALLET_CONNECT_V1","currentChainNamespace","clearCache","removeItem","addChain","WalletLoginError","notConnectedError","switchChain","params","connectTo","walletName","loginParams","notFound","connect","logout","cleanup","disconnect","getUserInfo","debug","authenticateUser","addPlugin","plugin","plugins","pluginNamespace","PLUGIN_NAMESPACES","walletAdapter","on","ADAPTER_EVENTS","data","cacheWallet","SUPPORTED_ADAPTERS","initWithWeb3Auth","code","emit","DISCONNECTED","CONNECTING","ERRORED","ADAPTER_DATA_UPDATED","CACHE_CLEAR","notReady","setItem"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAyEA,MAAMA,iBAAiB,GAAG,wBAA1B;;AACM,MAAOC,eAAP,SAA+BC,gBAA/B,CAA+C;AAenDI,EAAAA,WAAAA,CAAYC,OAAZD,EAA2C;AAAA,QAAA,oBAAA,EAAA,qBAAA,EAAA,qBAAA,EAAA,qBAAA;;AACzC;;AAAQH,IAAAA,eAAAA,CAAAA,IAAAA,EAAAA,aAAAA,EAAAA,KAAAA,CAAAA,CAAAA;;AAAAA,IAAAA,eAAAA,CAAAA,IAAAA,EAAAA,sBAAAA,EAbgD,IAahDA,CAAAA;;AAboDA,IAAAA,eAAAA,CAAAA,IAAAA,EAAAA,QAAAA,EAEzBC,cAAc,CAACC,SAFUF,CAAAA;;AAEDA,IAAAA,eAAAA,CAAAA,IAAAA,EAAAA,eAAAA,EAEvB,IAFuBA,CAAAA;;AAEnBA,IAAAA,eAAAA,CAAAA,IAAAA,EAAAA,gBAAAA,EAEoB,EAFpBA,CAAAA;;AAEsBA,IAAAA,eAAAA,CAAAA,IAAAA,EAAAA,SAAAA,EAErB,EAFqBA,CAAAA;;AAEnBA,IAAAA,eAAAA,CAAAA,IAAAA,EAAAA,SAAAA,EAEQ,cAFRA,CAAAA;;AAM3C,QAAI,CAACI,OAAO,CAACC,QAAb,EAAuB,MAAMC,yBAAyB,CAACC,aAA1BD,CAAwC,gDAAxCA,CAAN;AACvB,QAAIF,OAAO,CAACI,aAAZ,EAA2BC,GAAG,CAACC,SAAJD,GAA3B,KACKA,GAAG,CAACE,UAAJF;AACL,QAAI,EAAA,CAAA,oBAAA,GAACL,OAAO,CAACQ,WAAT,MAAoB,IAApB,IAAoB,oBAAA,KAAA,KAAA,CAApB,IAACR,oBAAAA,CAAqBS,cAAtB,KAAwC,CAACC,MAAM,CAACC,MAAPD,CAAcE,gBAAdF,EAAgCG,QAAhCH,CAAwC,CAAA,qBAAA,GAACV,OAAO,CAACQ,WAAT,MAAoB,IAApB,IAAoB,qBAAA,KAAnBR,KAAAA,CAAD,GAACA,KAAAA,CAAD,GAACA,qBAAAA,CAAqBS,cAA9DC,CAA7C,EACE,MAAMR,yBAAyB,CAACC,aAA1BD,CAAwC,sDAAxCA,CAAN;AACF,QAAIF,OAAO,CAACc,UAARd,KAAuB,SAA3B,EAAsC,KAAKe,OAAL,GAAe,gBAAf;AACtC,SAAKC,aAAL,GAAqBC,gBAAgB,CAAC,KAAKF,OAAN,CAAhBE,GAAiCC,MAAM,CAAC,KAAKH,OAAN,CAANG,CAAqBC,OAArBD,CAA6BzB,iBAA7ByB,CAAjCD,GAAmF,IAAxG;AAEA,SAAKG,WAAL,GAAgB,aAAA,CAAA,aAAA,CAAA,EAAA,EACXpB,OADW,CAAA,EACJ,EADI,EACJ;AACVQ,MAAAA,WAAW,EAAA,aAAA,CAAA,aAAA,CAAA,EAAA,EACLa,cAAc,CAAA,CAAA,qBAAA,GAACrB,OAAO,CAACQ,WAAT,MAAoB,IAApB,IAAoB,qBAAA,KAAA,KAAA,CAApB,GAAoB,KAAA,CAApB,GAACR,qBAAAA,CAAqBS,cAAtB,EAAoC,CAAA,qBAAA,GAAET,OAAO,CAACQ,WAAV,MAAqB,IAArB,IAAqB,qBAAA,KAAnBR,KAAAA,CAAF,GAAEA,KAAAA,CAAF,GAAEA,qBAAAA,CAAqBsB,OAA3D,CAAdD,IAAqF,EADhF,CAAA,EAENrB,OAAO,CAACQ,WAFF;AADD,KADI,CAAhB;AAOA,SAAKe,wBAAL,GAAgC,KAAKA,wBAAL,CAA8BC,IAA9B,CAAmC,IAAnC,CAAhC;AACF;;AAEYC,MAARA,QAAQA,GAAAA;AACV,QAAI,KAAKC,MAAL,KAAgB7B,cAAc,CAAC8B,SAA/B,IAA4C,KAAKC,oBAArD,EAA2E;AACzE,YAAMC,OAAO,GAAG,KAAKC,cAAL,CAAoB,KAAKF,oBAAzB,CAAhB;AACA,aAAOC,OAAO,CAACJ,QAAf;AACD;;AACD,WAAO,IAAP;AACF;;AAEYA,MAARA,QAAQA,CAACM,CAADN,EAAmC;AAC7C,UAAM,IAAIO,KAAJ,CAAU,iBAAV,CAAN;AACF;;AAEiBC,QAAJA,IAAIA,GAAAA;AACf,UAAMC,YAAY,GAAGxB,MAAM,CAACyB,IAAPzB,CAAY,KAAKoB,cAAjBpB,EAAiC0B,GAAjC1B,CAAsC2B,WAAW,IAAI;AACxE,WAAKd,wBAAL,CAA8B,KAAKO,cAAL,CAAoBO,WAApB,CAA9B,EADwE,CAExE;AACA;;AACA,UAAI,CAAC,KAAKP,cAAL,CAAoBO,WAApB,EAAiCC,gBAAtC,EAAwD;AACtD,cAAMC,mBAAmB,GAAG,KAAKnB,WAAL,CAAiBZ,WAA7C;AACA,YAAI,CAAC+B,mBAAmB,CAAC9B,cAAzB,EAAyC,MAAMP,yBAAyB,CAACC,aAA1BD,CAAwC,8CAAxCA,CAAN;AACzC,aAAK4B,cAAL,CAAoBO,WAApB,EAAiCG,kBAAjC,CAAoD;AAClDhC,UAAAA,WAAW,EAAE+B,mBADqC;AAElDE,UAAAA,WAAW,EAAE,KAAKrB,WAAL,CAAiBqB,WAFoB;AAGlDxC,UAAAA,QAAQ,EAAE,KAAKmB,WAAL,CAAiBnB,QAHuB;AAIlDyC,UAAAA,eAAe,EAAE,KAAKtB,WAAL,CAAiBsB,eAJgB;AAKlDC,UAAAA,aAAa,EAAE,KAAKvB,WAAL,CAAiBuB;AALkB,SAApD;AAOD,OAVD,MAUO;AACL,aAAKb,cAAL,CAAoBO,WAApB,EAAiCG,kBAAjC,CAAoD;AAClDC,UAAAA,WAAW,EAAE,KAAKrB,WAAL,CAAiBqB,WADoB;AAElDxC,UAAAA,QAAQ,EAAE,KAAKmB,WAAL,CAAiBnB,QAFuB;AAGlDyC,UAAAA,eAAe,EAAE,KAAKtB,WAAL,CAAiBsB,eAHgB;AAIlDC,UAAAA,aAAa,EAAE,KAAKvB,WAAL,CAAiBuB;AAJkB,SAApD;AAMD;;AAED,aAAO,KAAKb,cAAL,CAAoBO,WAApB,EAAiCJ,IAAjC,CAAsC;AAAEW,QAAAA,WAAW,EAAE,KAAK5B,aAAL,KAAuBqB;AAAtC,OAAtC,EAA2FQ,KAA3F,CAAkGC,CAAC,IAAKzC,GAAG,CAAC0C,KAAJ1C,CAAUyC,CAAVzC,CAAxG,CAAP;AACD,KAxBoBK,CAArB;AAyBA,SAAKgB,MAAL,GAAc7B,cAAc,CAACmD,KAA7B;AACA,UAAMC,OAAO,CAACC,GAARD,CAAYf,YAAZe,CAAN;AACF;;AAEOE,EAAAA,gBAAgBA,CAACtB,OAADsB,EAA2B;AAChD,SAAKC,qBAAL;AACA,UAAMb,mBAAmB,GAAG,KAAKnB,WAAL,CAAiBZ,WAA7C;AAEA,QAAI,CAAC+B,mBAAmB,CAAC9B,cAAzB,EAAyC,MAAMP,yBAAyB,CAACC,aAA1BD,CAAwC,8CAAxCA,CAAN;AAEzC,UAAMmD,oBAAoB,GAAG,KAAKvB,cAAL,CAAoBD,OAAO,CAACyB,IAA5B,CAA7B;AACA,QAAID,oBAAJ,EAA0B,MAAMnD,yBAAyB,CAACqD,qBAA1BrD,CAAgD,sBAAsB2B,OAAO,CAACyB,IAAqB,iBAAnGpD,CAAN;AAC1B,QAAI2B,OAAO,CAAC2B,gBAAR3B,KAA6B4B,kBAAkB,CAACC,UAAhD7B,IAA8DA,OAAO,CAAC2B,gBAAR3B,KAA6BU,mBAAmB,CAAC9B,cAAnH,EACE,MAAMP,yBAAyB,CAACyD,0BAA1BzD,CAC8B2B,kCAAAA,OAAO,CAAC2B,gBAAyEjB,yDAAAA,mBAAmB,CAAC9B,cAAc,EADjJP,CAAN;;AAIF,QAAI2B,OAAO,CAACyB,IAARzB,KAAiB+B,eAAe,CAACC,iBAAjChC,IAAsD,KAAKC,cAAL,CAAoB8B,eAAe,CAACE,iBAApC,CAA1D,EAAkH;AAChH,YAAM5D,yBAAyB,CAACC,aAA1BD,CACJ,wHADIA,CAAN;AAGD;;AACD,QAAI2B,OAAO,CAACyB,IAARzB,KAAiB+B,eAAe,CAACE,iBAAjCjC,IAAsD,KAAKC,cAAL,CAAoB8B,eAAe,CAACC,iBAApC,CAA1D,EAAkH;AAChH,YAAM3D,yBAAyB,CAACC,aAA1BD,CACJ,wHADIA,CAAN;AAGD;;AAED,QACE2B,OAAO,CAAC2B,gBAAR3B,KAA6B4B,kBAAkB,CAACC,UAAhD7B,IACAA,OAAO,CAACkC,qBADRlC,IAEAU,mBAAmB,CAAC9B,cAApB8B,KAAuCV,OAAO,CAACkC,qBAHjD,EAIE;AACA;AACAlC,MAAAA,OAAO,CAACW,kBAARX,CAA2B;AAAErB,QAAAA,WAAW,EAAE+B;AAAf,OAA3BV;AACD;;AAED,SAAKC,cAAL,CAAoBD,OAAO,CAACyB,IAA5B,IAAoCzB,OAApC;AACA,WAAO,IAAP;AACF;;AAEOmC,EAAAA,UAAUA,GAAAA;AACf,QAAI,CAAC/C,gBAAgB,CAAC,KAAKF,OAAN,CAArB,EAAqC;AACrCG,IAAAA,MAAM,CAAC,KAAKH,OAAN,CAANG,CAAqB+C,UAArB/C,CAAgCzB,iBAAhCyB;AACA,SAAKF,aAAL,GAAqB,IAArB;AACF;;AAEqBkD,QAARA,QAAQA,CAAC1D,WAAD0D,EAA+B;AAClD,QAAI,KAAKxC,MAAL,KAAgB7B,cAAc,CAAC8B,SAA/B,IAA4C,CAAC,KAAKC,oBAAtD,EAA4E,MAAMuC,gBAAgB,CAACC,iBAAjBD,CAAmC,wBAAnCA,CAAN;AAC5E,WAAO,KAAKrC,cAAL,CAAoB,KAAKF,oBAAzB,EAA+CsC,QAA/C,CAAwD1D,WAAxD,CAAP;AACF;;AAEwB6D,QAAXA,WAAWA,CAACC,MAADD,EAA4B;AAClD,QAAI,KAAK3C,MAAL,KAAgB7B,cAAc,CAAC8B,SAA/B,IAA4C,CAAC,KAAKC,oBAAtD,EAA4E,MAAMuC,gBAAgB,CAACC,iBAAjBD,CAAmC,wBAAnCA,CAAN;AAC5E,WAAO,KAAKrC,cAAL,CAAoB,KAAKF,oBAAzB,EAA+CyC,WAA/C,CAA2DC,MAA3D,CAAP;AACF;AAEA;;;AAGG;;;AACYC,QAATA,SAASA,CAAIC,UAAJD,EAAqCE,WAArCF,EAAoD;AACjE,QAAI,CAAC,KAAKzC,cAAL,CAAoB0C,UAApB,CAAL,EACE,MAAMtE,yBAAyB,CAACwE,QAA1BxE,CAAoEsE,iCAAAA,UAAU,4BAA9EtE,CAAN;AACF,UAAMuB,QAAQ,GAAG,MAAM,KAAKK,cAAL,CAAoB0C,UAApB,EAAgCG,OAAhC,CAAwCF,WAAxC,CAAvB;AACA,WAAOhD,QAAP;AACF;;AAEYmD,QAANA,MAAMA,GAAmD;AAAA,QAAlD5E,OAAAA,GAAAA,SAAAA,CAAAA,MAAAA,GAAAA,CAAAA,IAAAA,SAAAA,CAAAA,CAAAA,CAAAA,KAAAA,SAAAA,GAAAA,SAAAA,CAAgC,CAAhCA,CAAAA,GAAgC;AAAE6E,MAAAA,OAAO,EAAE;AAAX,KAAkB;AAC7D,QAAI,KAAKnD,MAAL,KAAgB7B,cAAc,CAAC8B,SAA/B,IAA4C,CAAC,KAAKC,oBAAtD,EAA4E,MAAMuC,gBAAgB,CAACC,iBAAjBD,CAAmC,wBAAnCA,CAAN;AAC5E,UAAM,KAAKrC,cAAL,CAAoB,KAAKF,oBAAzB,EAA+CkD,UAA/C,CAA0D9E,OAA1D,CAAN;AACF;;AAEiB+E,QAAXA,WAAWA,GAAAA;AACf1E,IAAAA,GAAG,CAAC2E,KAAJ3E,CAAU,mBAAVA,EAA+B,KAAKqB,MAApCrB,EAA4C,KAAKuB,oBAAjDvB;AACA,QAAI,KAAKqB,MAAL,KAAgB7B,cAAc,CAAC8B,SAA/B,IAA4C,CAAC,KAAKC,oBAAtD,EAA4E,MAAMuC,gBAAgB,CAACC,iBAAjBD,CAAmC,wBAAnCA,CAAN;AAC5E,WAAO,KAAKrC,cAAL,CAAoB,KAAKF,oBAAzB,EAA+CmD,WAA/C,EAAP;AACF;;AAEsBE,QAAhBA,gBAAgBA,GAAAA;AACpB,QAAI,KAAKvD,MAAL,KAAgB7B,cAAc,CAAC8B,SAA/B,IAA4C,CAAC,KAAKC,oBAAtD,EAA4E,MAAMuC,gBAAgB,CAACC,iBAAjBD,CAAmC,wBAAnCA,CAAN;AAC5E,WAAO,KAAKrC,cAAL,CAAoB,KAAKF,oBAAzB,EAA+CqD,gBAA/C,EAAP;AACF;;AAEsBC,QAATA,SAASA,CAACC,MAADD,EAAgB;AACpC,QAAI,KAAKE,OAAL,CAAaD,MAAM,CAAC7B,IAApB,CAAJ,EAA+B,MAAM,IAAItB,KAAJ,CAAU,UAAUmD,MAAM,CAAC7B,IAAoB,gBAA/C,CAAN;AAC/B,QAAI6B,MAAM,CAACE,eAAPF,KAA2BG,iBAAiB,CAAC5B,UAA7CyB,IAA2DA,MAAM,CAACE,eAAPF,KAA2B,KAAK/D,WAAL,CAAiBZ,WAAjB,CAA6BC,cAAvH,EACE,MAAM,IAAIuB,KAAJ,CACsB,0BAAA,MAAM,CAACqD,eAAkF,mEAAA,KAAKjE,WAAL,CAAiBZ,WAAjB,CAA6BC,cAAc,EAD1J,CAAN;AAIF,SAAK2E,OAAL,CAAaD,MAAM,CAAC7B,IAApB,IAA4B6B,MAA5B;AACA,WAAO,IAAP;AACF;;AAEU5D,EAAAA,wBAAwBA,CAACgE,aAADhE,EAAiC;AACjEgE,IAAAA,aAAa,CAACC,EAAdD,CAAiBE,cAAc,CAAC9D,SAAhC4D,EAA2C,MAAOG,IAAP,IAAqC;AAC9E,WAAKhE,MAAL,GAAc7B,cAAc,CAAC8B,SAA7B;AACA,WAAKC,oBAAL,GAA4B8D,IAAI,CAAC7D,OAAjC;AACA,WAAK8D,WAAL,CAAiBD,IAAI,CAAC7D,OAAtB;AACAxB,MAAAA,GAAG,CAAC2E,KAAJ3E,CAAU,WAAVA,EAAuB,KAAKqB,MAA5BrB,EAAoC,KAAKuB,oBAAzCvB;AAEAK,MAAAA,MAAM,CAACC,MAAPD,CAAc,KAAK0E,OAAnB1E,EAA4B0B,GAA5B1B,CAAgC,MAAOyE,MAAP,IAAiB;AAC/C,YAAI;AACF,cAAI,CAACA,MAAM,CAACS,kBAAPT,CAA0BtE,QAA1BsE,CAAmCO,IAAI,CAAC7D,OAAxCsD,CAAL,EAAuD;AACrD;AACD;;AACD,gBAAMA,MAAM,CAACU,gBAAPV,CAAwB,IAAxBA,CAAN;AACA,gBAAMA,MAAM,CAACR,OAAPQ,EAAN;AACD,SAND,CAME,OAAOpC,KAAP,EAAuB;AACvB;AACA,cAAKA,KAAuB,CAAC+C,IAAxB/C,KAAiC,IAAtC,EAA4C;AAC1C;AACD;;AACD1C,UAAAA,GAAG,CAAC0C,KAAJ1C,CAAU0C,KAAV1C;AACD;AACF,OAdDK;AAgBA,WAAKqF,IAAL,CAAUN,cAAc,CAAC9D,SAAzB,EAAkC,aAAA,CAAO+D,EAAP,EAAOA,IAAP,CAAlC;AACD,KAvBDH;AAyBAA,IAAAA,aAAa,CAACC,EAAdD,CAAiBE,cAAc,CAACO,YAAhCT,EAA8C,MAAOG,IAAP,IAAe;AAC3D;AACA,WAAKhE,MAAL,GAAc7B,cAAc,CAACmD,KAA7B;;AACA,UAAI/B,gBAAgB,CAAC,KAAKF,OAAN,CAApB,EAAoC;AAClC,cAAMC,aAAa,GAAGE,MAAM,CAAC,KAAKH,OAAN,CAANG,CAAqBC,OAArBD,CAA6BzB,iBAA7ByB,CAAtB;;AACA,YAAI,KAAKU,oBAAL,KAA8BZ,aAAlC,EAAiD;AAC/C,eAAKgD,UAAL;AACD;AACF;;AAED3D,MAAAA,GAAG,CAAC2E,KAAJ3E,CAAU,cAAVA,EAA0B,KAAKqB,MAA/BrB,EAAuC,KAAKuB,oBAA5CvB;AACA,YAAM4C,OAAO,CAACC,GAARD,CACJvC,MAAM,CAACC,MAAPD,CAAc,KAAK0E,OAAnB1E,EAA4B0B,GAA5B1B,CAAiCyE,MAAM,IAAI;AACzC,eAAOA,MAAM,CAACL,UAAPK,GAAoBtC,KAApBsC,CAA2BpC,KAAoB,IAAI;AACxD;AACA,cAAIA,KAAK,CAAC+C,IAAN/C,KAAe,IAAnB,EAAyB;AACvB;AACD,WAJuD,CAKxD;;;AACA1C,UAAAA,GAAG,CAAC0C,KAAJ1C,CAAU0C,KAAV1C;AACD,SAPM8E,CAAP;AAQD,OATDzE,CADIuC,CAAN;AAYA,WAAKrB,oBAAL,GAA4B,IAA5B;AACA,WAAKmE,IAAL,CAAUN,cAAc,CAACO,YAAzB,EAAuCN,IAAvC;AACD,KAzBDH;AA0BAA,IAAAA,aAAa,CAACC,EAAdD,CAAiBE,cAAc,CAACQ,UAAhCV,EAA6CG,IAAI,IAAI;AACnD,WAAKhE,MAAL,GAAc7B,cAAc,CAACoG,UAA7B;AACA,WAAKF,IAAL,CAAUN,cAAc,CAACQ,UAAzB,EAAqCP,IAArC;AACArF,MAAAA,GAAG,CAAC2E,KAAJ3E,CAAU,YAAVA,EAAwB,KAAKqB,MAA7BrB,EAAqC,KAAKuB,oBAA1CvB;AACD,KAJDkF;AAKAA,IAAAA,aAAa,CAACC,EAAdD,CAAiBE,cAAc,CAACS,OAAhCX,EAA0CG,IAAI,IAAI;AAChD,WAAKhE,MAAL,GAAc7B,cAAc,CAACqG,OAA7B;AACA,WAAKlC,UAAL;AACA,WAAK+B,IAAL,CAAUN,cAAc,CAACS,OAAzB,EAAkCR,IAAlC;AACArF,MAAAA,GAAG,CAAC2E,KAAJ3E,CAAU,SAAVA,EAAqB,KAAKqB,MAA1BrB,EAAkC,KAAKuB,oBAAvCvB;AACD,KALDkF;AAOAA,IAAAA,aAAa,CAACC,EAAdD,CAAiBE,cAAc,CAACU,oBAAhCZ,EAAuDG,IAAI,IAAI;AAC7DrF,MAAAA,GAAG,CAAC2E,KAAJ3E,CAAU,sBAAVA,EAAkCqF,IAAlCrF;AACA,WAAK0F,IAAL,CAAUN,cAAc,CAACU,oBAAzB,EAA+CT,IAA/C;AACD,KAHDH;AAKAA,IAAAA,aAAa,CAACC,EAAdD,CAAiBE,cAAc,CAACW,WAAhCb,EAA8CG,IAAI,IAAI;AACpDrF,MAAAA,GAAG,CAAC2E,KAAJ3E,CAAU,qBAAVA,EAAiCqF,IAAjCrF;;AACA,UAAIY,gBAAgB,CAAC,KAAKF,OAAN,CAApB,EAAoC;AAClC,aAAKiD,UAAL;AACD;AACF,KALDuB;AAMF;;AAEUnC,EAAAA,qBAAqBA,GAAAA;AAC7B,QAAI,KAAK1B,MAAL,KAAgB7B,cAAc,CAACoG,UAAnC,EAA+C,MAAM/F,yBAAyB,CAACmG,QAA1BnG,CAAmC,4BAAnCA,CAAN;AAC/C,QAAI,KAAKwB,MAAL,KAAgB7B,cAAc,CAAC8B,SAAnC,EAA8C,MAAMzB,yBAAyB,CAACmG,QAA1BnG,CAAmC,mBAAnCA,CAAN;AAC9C,QAAI,KAAKwB,MAAL,KAAgB7B,cAAc,CAACmD,KAAnC,EAA0C,MAAM9C,yBAAyB,CAACmG,QAA1BnG,CAAmC,gCAAnCA,CAAN;AAC5C;;AAEQyF,EAAAA,WAAWA,CAACnB,UAADmB,EAAmB;AACpC,QAAI,CAAC1E,gBAAgB,CAAC,KAAKF,OAAN,CAArB,EAAqC;AACrCG,IAAAA,MAAM,CAAC,KAAKH,OAAN,CAANG,CAAqBoF,OAArBpF,CAA6BzB,iBAA7ByB,EAAgDsD,UAAhDtD;AACA,SAAKF,aAAL,GAAqBwD,UAArB;AACF;;AA/PmD","sourcesContent":["import _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport { SafeEventEmitter } from '@toruslabs/openlogin-jrpc';\nimport { ADAPTER_STATUS, WalletInitializationError, log, CHAIN_NAMESPACES, storageAvailable, getChainConfig, ADAPTER_NAMESPACES, WALLET_ADAPTERS, WalletLoginError, ADAPTER_EVENTS } from '@web3auth/base';\nimport { PLUGIN_NAMESPACES } from '@web3auth/base-plugin';\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nconst ADAPTER_CACHE_KEY = \"Web3Auth-cachedAdapter\";\nclass Web3AuthNoModal extends SafeEventEmitter {\n  constructor(options) {\n    var _options$chainConfig, _options$chainConfig2, _options$chainConfig3, _options$chainConfig4;\n    super();\n    _defineProperty(this, \"coreOptions\", void 0);\n    _defineProperty(this, \"connectedAdapterName\", null);\n    _defineProperty(this, \"status\", ADAPTER_STATUS.NOT_READY);\n    _defineProperty(this, \"cachedAdapter\", null);\n    _defineProperty(this, \"walletAdapters\", {});\n    _defineProperty(this, \"plugins\", {});\n    _defineProperty(this, \"storage\", \"localStorage\");\n    if (!options.clientId) throw WalletInitializationError.invalidParams(\"Please provide a valid clientId in constructor\");\n    if (options.enableLogging) log.enableAll();else log.disableAll();\n    if (!((_options$chainConfig = options.chainConfig) !== null && _options$chainConfig !== void 0 && _options$chainConfig.chainNamespace) || !Object.values(CHAIN_NAMESPACES).includes((_options$chainConfig2 = options.chainConfig) === null || _options$chainConfig2 === void 0 ? void 0 : _options$chainConfig2.chainNamespace)) throw WalletInitializationError.invalidParams(\"Please provide a valid chainNamespace in chainConfig\");\n    if (options.storageKey === \"session\") this.storage = \"sessionStorage\";\n    this.cachedAdapter = storageAvailable(this.storage) ? window[this.storage].getItem(ADAPTER_CACHE_KEY) : null;\n    this.coreOptions = _objectSpread(_objectSpread({}, options), {}, {\n      chainConfig: _objectSpread(_objectSpread({}, getChainConfig((_options$chainConfig3 = options.chainConfig) === null || _options$chainConfig3 === void 0 ? void 0 : _options$chainConfig3.chainNamespace, (_options$chainConfig4 = options.chainConfig) === null || _options$chainConfig4 === void 0 ? void 0 : _options$chainConfig4.chainId) || {}), options.chainConfig)\n    });\n    this.subscribeToAdapterEvents = this.subscribeToAdapterEvents.bind(this);\n  }\n  get provider() {\n    if (this.status === ADAPTER_STATUS.CONNECTED && this.connectedAdapterName) {\n      const adapter = this.walletAdapters[this.connectedAdapterName];\n      return adapter.provider;\n    }\n    return null;\n  }\n  set provider(_) {\n    throw new Error(\"Not implemented\");\n  }\n  async init() {\n    const initPromises = Object.keys(this.walletAdapters).map(adapterName => {\n      this.subscribeToAdapterEvents(this.walletAdapters[adapterName]);\n      // if adapter doesn't have any chain config yet thn set it based on provided namespace and chainId.\n      // if no chainNamespace or chainId is being provided, it will connect with mainnet.\n      if (!this.walletAdapters[adapterName].chainConfigProxy) {\n        const providedChainConfig = this.coreOptions.chainConfig;\n        if (!providedChainConfig.chainNamespace) throw WalletInitializationError.invalidParams(\"Please provide chainNamespace in chainConfig\");\n        this.walletAdapters[adapterName].setAdapterSettings({\n          chainConfig: providedChainConfig,\n          sessionTime: this.coreOptions.sessionTime,\n          clientId: this.coreOptions.clientId,\n          web3AuthNetwork: this.coreOptions.web3AuthNetwork,\n          useCoreKitKey: this.coreOptions.useCoreKitKey\n        });\n      } else {\n        this.walletAdapters[adapterName].setAdapterSettings({\n          sessionTime: this.coreOptions.sessionTime,\n          clientId: this.coreOptions.clientId,\n          web3AuthNetwork: this.coreOptions.web3AuthNetwork,\n          useCoreKitKey: this.coreOptions.useCoreKitKey\n        });\n      }\n      return this.walletAdapters[adapterName].init({\n        autoConnect: this.cachedAdapter === adapterName\n      }).catch(e => log.error(e));\n    });\n    this.status = ADAPTER_STATUS.READY;\n    await Promise.all(initPromises);\n  }\n  configureAdapter(adapter) {\n    this.checkInitRequirements();\n    const providedChainConfig = this.coreOptions.chainConfig;\n    if (!providedChainConfig.chainNamespace) throw WalletInitializationError.invalidParams(\"Please provide chainNamespace in chainConfig\");\n    const adapterAlreadyExists = this.walletAdapters[adapter.name];\n    if (adapterAlreadyExists) throw WalletInitializationError.duplicateAdapterError(`Wallet adapter for ${adapter.name} already exists`);\n    if (adapter.adapterNamespace !== ADAPTER_NAMESPACES.MULTICHAIN && adapter.adapterNamespace !== providedChainConfig.chainNamespace) throw WalletInitializationError.incompatibleChainNameSpace(`This wallet adapter belongs to ${adapter.adapterNamespace} which is incompatible with currently used namespace: ${providedChainConfig.chainNamespace}`);\n    if (adapter.name === WALLET_ADAPTERS.WALLET_CONNECT_V2 && this.walletAdapters[WALLET_ADAPTERS.WALLET_CONNECT_V1]) {\n      throw WalletInitializationError.invalidParams(\"Either one of wallet connect v2 or wallet connect v1 can be used, wallet connect v1 is already added to adapter lists.\");\n    }\n    if (adapter.name === WALLET_ADAPTERS.WALLET_CONNECT_V1 && this.walletAdapters[WALLET_ADAPTERS.WALLET_CONNECT_V2]) {\n      throw WalletInitializationError.invalidParams(\"Either one of wallet connect v2 or wallet connect v1 can be used, wallet connect v2 is already added to adapter lists.\");\n    }\n    if (adapter.adapterNamespace === ADAPTER_NAMESPACES.MULTICHAIN && adapter.currentChainNamespace && providedChainConfig.chainNamespace !== adapter.currentChainNamespace) {\n      // chainConfig checks are already validated in constructor so using typecast is safe here.\n      adapter.setAdapterSettings({\n        chainConfig: providedChainConfig\n      });\n    }\n    this.walletAdapters[adapter.name] = adapter;\n    return this;\n  }\n  clearCache() {\n    if (!storageAvailable(this.storage)) return;\n    window[this.storage].removeItem(ADAPTER_CACHE_KEY);\n    this.cachedAdapter = null;\n  }\n  async addChain(chainConfig) {\n    if (this.status !== ADAPTER_STATUS.CONNECTED || !this.connectedAdapterName) throw WalletLoginError.notConnectedError(`No wallet is connected`);\n    return this.walletAdapters[this.connectedAdapterName].addChain(chainConfig);\n  }\n  async switchChain(params) {\n    if (this.status !== ADAPTER_STATUS.CONNECTED || !this.connectedAdapterName) throw WalletLoginError.notConnectedError(`No wallet is connected`);\n    return this.walletAdapters[this.connectedAdapterName].switchChain(params);\n  }\n  /**\n   * Connect to a specific wallet adapter\n   * @param walletName - Key of the walletAdapter to use.\n   */\n  async connectTo(walletName, loginParams) {\n    if (!this.walletAdapters[walletName]) throw WalletInitializationError.notFound(`Please add wallet adapter for ${walletName} wallet, before connecting`);\n    const provider = await this.walletAdapters[walletName].connect(loginParams);\n    return provider;\n  }\n  async logout() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n      cleanup: false\n    };\n    if (this.status !== ADAPTER_STATUS.CONNECTED || !this.connectedAdapterName) throw WalletLoginError.notConnectedError(`No wallet is connected`);\n    await this.walletAdapters[this.connectedAdapterName].disconnect(options);\n  }\n  async getUserInfo() {\n    log.debug(\"Getting user info\", this.status, this.connectedAdapterName);\n    if (this.status !== ADAPTER_STATUS.CONNECTED || !this.connectedAdapterName) throw WalletLoginError.notConnectedError(`No wallet is connected`);\n    return this.walletAdapters[this.connectedAdapterName].getUserInfo();\n  }\n  async authenticateUser() {\n    if (this.status !== ADAPTER_STATUS.CONNECTED || !this.connectedAdapterName) throw WalletLoginError.notConnectedError(`No wallet is connected`);\n    return this.walletAdapters[this.connectedAdapterName].authenticateUser();\n  }\n  async addPlugin(plugin) {\n    if (this.plugins[plugin.name]) throw new Error(`Plugin ${plugin.name} already exist`);\n    if (plugin.pluginNamespace !== PLUGIN_NAMESPACES.MULTICHAIN && plugin.pluginNamespace !== this.coreOptions.chainConfig.chainNamespace) throw new Error(`This plugin belongs to ${plugin.pluginNamespace} namespace which is incompatible with currently used namespace: ${this.coreOptions.chainConfig.chainNamespace}`);\n    this.plugins[plugin.name] = plugin;\n    return this;\n  }\n  subscribeToAdapterEvents(walletAdapter) {\n    walletAdapter.on(ADAPTER_EVENTS.CONNECTED, async data => {\n      this.status = ADAPTER_STATUS.CONNECTED;\n      this.connectedAdapterName = data.adapter;\n      this.cacheWallet(data.adapter);\n      log.debug(\"connected\", this.status, this.connectedAdapterName);\n      Object.values(this.plugins).map(async plugin => {\n        try {\n          if (!plugin.SUPPORTED_ADAPTERS.includes(data.adapter)) {\n            return;\n          }\n          await plugin.initWithWeb3Auth(this);\n          await plugin.connect();\n        } catch (error) {\n          // swallow error if connector adapter doesn't supports this plugin.\n          if (error.code === 5211) {\n            return;\n          }\n          log.error(error);\n        }\n      });\n      this.emit(ADAPTER_EVENTS.CONNECTED, _objectSpread({}, data));\n    });\n    walletAdapter.on(ADAPTER_EVENTS.DISCONNECTED, async data => {\n      // get back to ready state for rehydrating.\n      this.status = ADAPTER_STATUS.READY;\n      if (storageAvailable(this.storage)) {\n        const cachedAdapter = window[this.storage].getItem(ADAPTER_CACHE_KEY);\n        if (this.connectedAdapterName === cachedAdapter) {\n          this.clearCache();\n        }\n      }\n      log.debug(\"disconnected\", this.status, this.connectedAdapterName);\n      await Promise.all(Object.values(this.plugins).map(plugin => {\n        return plugin.disconnect().catch(error => {\n          // swallow error if adapter doesn't supports this plugin.\n          if (error.code === 5211) {\n            return;\n          }\n          // throw error;\n          log.error(error);\n        });\n      }));\n      this.connectedAdapterName = null;\n      this.emit(ADAPTER_EVENTS.DISCONNECTED, data);\n    });\n    walletAdapter.on(ADAPTER_EVENTS.CONNECTING, data => {\n      this.status = ADAPTER_STATUS.CONNECTING;\n      this.emit(ADAPTER_EVENTS.CONNECTING, data);\n      log.debug(\"connecting\", this.status, this.connectedAdapterName);\n    });\n    walletAdapter.on(ADAPTER_EVENTS.ERRORED, data => {\n      this.status = ADAPTER_STATUS.ERRORED;\n      this.clearCache();\n      this.emit(ADAPTER_EVENTS.ERRORED, data);\n      log.debug(\"errored\", this.status, this.connectedAdapterName);\n    });\n    walletAdapter.on(ADAPTER_EVENTS.ADAPTER_DATA_UPDATED, data => {\n      log.debug(\"adapter data updated\", data);\n      this.emit(ADAPTER_EVENTS.ADAPTER_DATA_UPDATED, data);\n    });\n    walletAdapter.on(ADAPTER_EVENTS.CACHE_CLEAR, data => {\n      log.debug(\"adapter cache clear\", data);\n      if (storageAvailable(this.storage)) {\n        this.clearCache();\n      }\n    });\n  }\n  checkInitRequirements() {\n    if (this.status === ADAPTER_STATUS.CONNECTING) throw WalletInitializationError.notReady(\"Already pending connection\");\n    if (this.status === ADAPTER_STATUS.CONNECTED) throw WalletInitializationError.notReady(\"Already connected\");\n    if (this.status === ADAPTER_STATUS.READY) throw WalletInitializationError.notReady(\"Adapter is already initialized\");\n  }\n  cacheWallet(walletName) {\n    if (!storageAvailable(this.storage)) return;\n    window[this.storage].setItem(ADAPTER_CACHE_KEY, walletName);\n    this.cachedAdapter = walletName;\n  }\n}\n\nexport { Web3AuthNoModal };\n//# sourceMappingURL=noModal.esm.js.map\n"]},"metadata":{},"sourceType":"module"}