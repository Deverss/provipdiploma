{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.crypto = exports.wrapHash = exports.equalsBytes = exports.hexToBytes = exports.bytesToUtf8 = exports.utf8ToBytes = exports.createView = exports.concatBytes = exports.toHex = exports.bytesToHex = exports.assertBytes = exports.assertBool = void 0; // buf.toString('hex') -> toHex(buf)\n\nconst _assert_1 = __importDefault(require(\"@noble/hashes/_assert\"));\n\nconst utils_1 = require(\"@noble/hashes/utils\");\n\nconst assertBool = _assert_1.default.bool;\nexports.assertBool = assertBool;\nconst assertBytes = _assert_1.default.bytes;\nexports.assertBytes = assertBytes;\n\nvar utils_2 = require(\"@noble/hashes/utils\");\n\nObject.defineProperty(exports, \"bytesToHex\", {\n  enumerable: true,\n  get: function () {\n    return utils_2.bytesToHex;\n  }\n});\nObject.defineProperty(exports, \"toHex\", {\n  enumerable: true,\n  get: function () {\n    return utils_2.bytesToHex;\n  }\n});\nObject.defineProperty(exports, \"concatBytes\", {\n  enumerable: true,\n  get: function () {\n    return utils_2.concatBytes;\n  }\n});\nObject.defineProperty(exports, \"createView\", {\n  enumerable: true,\n  get: function () {\n    return utils_2.createView;\n  }\n});\nObject.defineProperty(exports, \"utf8ToBytes\", {\n  enumerable: true,\n  get: function () {\n    return utils_2.utf8ToBytes;\n  }\n}); // buf.toString('utf8') -> bytesToUtf8(buf)\n\nfunction bytesToUtf8(data) {\n  if (!(data instanceof Uint8Array)) {\n    throw new TypeError(`bytesToUtf8 expected Uint8Array, got ${typeof data}`);\n  }\n\n  return new TextDecoder().decode(data);\n}\n\nexports.bytesToUtf8 = bytesToUtf8;\n\nfunction hexToBytes(data) {\n  const sliced = data.startsWith(\"0x\") ? data.substring(2) : data;\n  return (0, utils_1.hexToBytes)(sliced);\n}\n\nexports.hexToBytes = hexToBytes; // buf.equals(buf2) -> equalsBytes(buf, buf2)\n\nfunction equalsBytes(a, b) {\n  if (a.length !== b.length) {\n    return false;\n  }\n\n  for (let i = 0; i < a.length; i++) {\n    if (a[i] !== b[i]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nexports.equalsBytes = equalsBytes; // Internal utils\n\nfunction wrapHash(hash) {\n  return msg => {\n    _assert_1.default.bytes(msg);\n\n    return hash(msg);\n  };\n}\n\nexports.wrapHash = wrapHash;\n\nexports.crypto = (() => {\n  const webCrypto = typeof self === \"object\" && \"crypto\" in self ? self.crypto : undefined;\n\n  const nodeRequire = typeof module !== \"undefined\" && typeof module.require === \"function\" && module.require.bind(module);\n\n  return {\n    node: nodeRequire && !webCrypto ? nodeRequire(\"crypto\") : undefined,\n    web: webCrypto\n  };\n})();","map":{"version":3,"sources":["/Users/dev3rs/provipdiploma/node_modules/ethereum-cryptography/utils.js"],"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","crypto","wrapHash","equalsBytes","hexToBytes","bytesToUtf8","utf8ToBytes","createView","concatBytes","toHex","bytesToHex","assertBytes","assertBool","_assert_1","require","utils_1","default","bool","bytes","utils_2","enumerable","get","data","Uint8Array","TypeError","TextDecoder","decode","sliced","startsWith","substring","a","b","length","i","hash","msg","webCrypto","self","undefined","nodeRequire","module","bind","node","web"],"mappings":"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","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.crypto = exports.wrapHash = exports.equalsBytes = exports.hexToBytes = exports.bytesToUtf8 = exports.utf8ToBytes = exports.createView = exports.concatBytes = exports.toHex = exports.bytesToHex = exports.assertBytes = exports.assertBool = void 0;\n// buf.toString('hex') -> toHex(buf)\nconst _assert_1 = __importDefault(require(\"@noble/hashes/_assert\"));\nconst utils_1 = require(\"@noble/hashes/utils\");\nconst assertBool = _assert_1.default.bool;\nexports.assertBool = assertBool;\nconst assertBytes = _assert_1.default.bytes;\nexports.assertBytes = assertBytes;\nvar utils_2 = require(\"@noble/hashes/utils\");\nObject.defineProperty(exports, \"bytesToHex\", { enumerable: true, get: function () { return utils_2.bytesToHex; } });\nObject.defineProperty(exports, \"toHex\", { enumerable: true, get: function () { return utils_2.bytesToHex; } });\nObject.defineProperty(exports, \"concatBytes\", { enumerable: true, get: function () { return utils_2.concatBytes; } });\nObject.defineProperty(exports, \"createView\", { enumerable: true, get: function () { return utils_2.createView; } });\nObject.defineProperty(exports, \"utf8ToBytes\", { enumerable: true, get: function () { return utils_2.utf8ToBytes; } });\n// buf.toString('utf8') -> bytesToUtf8(buf)\nfunction bytesToUtf8(data) {\n    if (!(data instanceof Uint8Array)) {\n        throw new TypeError(`bytesToUtf8 expected Uint8Array, got ${typeof data}`);\n    }\n    return new TextDecoder().decode(data);\n}\nexports.bytesToUtf8 = bytesToUtf8;\nfunction hexToBytes(data) {\n    const sliced = data.startsWith(\"0x\") ? data.substring(2) : data;\n    return (0, utils_1.hexToBytes)(sliced);\n}\nexports.hexToBytes = hexToBytes;\n// buf.equals(buf2) -> equalsBytes(buf, buf2)\nfunction equalsBytes(a, b) {\n    if (a.length !== b.length) {\n        return false;\n    }\n    for (let i = 0; i < a.length; i++) {\n        if (a[i] !== b[i]) {\n            return false;\n        }\n    }\n    return true;\n}\nexports.equalsBytes = equalsBytes;\n// Internal utils\nfunction wrapHash(hash) {\n    return (msg) => {\n        _assert_1.default.bytes(msg);\n        return hash(msg);\n    };\n}\nexports.wrapHash = wrapHash;\nexports.crypto = (() => {\n    const webCrypto = typeof self === \"object\" && \"crypto\" in self ? self.crypto : undefined;\n    const nodeRequire = typeof module !== \"undefined\" &&\n        typeof module.require === \"function\" &&\n        module.require.bind(module);\n    return {\n        node: nodeRequire && !webCrypto ? nodeRequire(\"crypto\") : undefined,\n        web: webCrypto\n    };\n})();\n"]},"metadata":{},"sourceType":"script"}