{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.BitListType = void 0;\n\nconst persistent_merkle_tree_1 = require(\"@chainsafe/persistent-merkle-tree\");\n\nconst merkleize_1 = require(\"../util/merkleize\");\n\nconst named_1 = require(\"../util/named\");\n\nconst arrayBasic_1 = require(\"./arrayBasic\");\n\nconst bitArray_1 = require(\"../value/bitArray\");\n\nconst bitArray_2 = require(\"./bitArray\");\n/**\n * BitList: ordered variable-length collection of boolean values, limited to N bits\n * - Notation `Bitlist[N]`\n * - Value: `BitArray`, @see BitArray for a justification of its memory efficiency and performance\n * - View: `BitArrayTreeView`\n * - ViewDU: `BitArrayTreeViewDU`\n */\n\n\nclass BitListType extends bitArray_2.BitArrayType {\n  constructor(limitBits, opts) {\n    super();\n    this.limitBits = limitBits;\n    this.fixedSize = null;\n    this.minSize = 1; // +1 for the extra padding bit\n\n    this.isList = true;\n    if (limitBits === 0) throw Error(\"List limit must be > 0\");\n    this.typeName = (opts === null || opts === void 0 ? void 0 : opts.typeName) ?? `BitList[${limitBits}]`; // TODO Check that itemsPerChunk is an integer\n\n    this.maxChunkCount = Math.ceil(this.limitBits / 8 / 32);\n    this.chunkDepth = merkleize_1.maxChunksToDepth(this.maxChunkCount); // Depth includes the extra level for the length node\n\n    this.depth = 1 + this.chunkDepth;\n    this.maxSize = Math.ceil(limitBits / 8) + 1; // +1 for the extra padding bit\n  }\n\n  static named(limitBits, opts) {\n    return new (named_1.namedClass(BitListType, opts.typeName))(limitBits, opts);\n  }\n\n  defaultValue() {\n    return bitArray_1.BitArray.fromBitLen(0);\n  } // Views: inherited from BitArrayType\n  // Serialization + deserialization\n\n\n  value_serializedSize(value) {\n    return bitLenToSerializedLength(value.bitLen);\n  }\n\n  value_serializeToBytes(output, offset, value) {\n    output.uint8Array.set(value.uint8Array, offset);\n    return applyPaddingBit(output.uint8Array, offset, value.bitLen);\n  }\n\n  value_deserializeFromBytes(data, start, end) {\n    const {\n      uint8Array,\n      bitLen\n    } = this.deserializeUint8ArrayBitListFromBytes(data.uint8Array, start, end);\n    return new bitArray_1.BitArray(uint8Array, bitLen);\n  }\n\n  tree_serializedSize(node) {\n    return bitLenToSerializedLength(arrayBasic_1.getLengthFromRootNode(node));\n  }\n\n  tree_serializeToBytes(output, offset, node) {\n    const chunksNode = arrayBasic_1.getChunksNodeFromRootNode(node);\n    const bitLen = arrayBasic_1.getLengthFromRootNode(node);\n    const byteLen = Math.ceil(bitLen / 8);\n    const chunkLen = Math.ceil(byteLen / 32);\n    const nodes = persistent_merkle_tree_1.getNodesAtDepth(chunksNode, this.chunkDepth, 0, chunkLen);\n    persistent_merkle_tree_1.packedNodeRootsToBytes(output.dataView, offset, byteLen, nodes);\n    return applyPaddingBit(output.uint8Array, offset, bitLen);\n  }\n\n  tree_deserializeFromBytes(data, start, end) {\n    const {\n      uint8Array,\n      bitLen\n    } = this.deserializeUint8ArrayBitListFromBytes(data.uint8Array, start, end);\n    const dataView = new DataView(uint8Array.buffer, uint8Array.byteOffset, uint8Array.byteLength);\n    const chunksNode = persistent_merkle_tree_1.packedRootsBytesToNode(this.chunkDepth, dataView, 0, uint8Array.length);\n    return arrayBasic_1.addLengthNode(chunksNode, bitLen);\n  }\n\n  tree_getByteLen(node) {\n    if (!node) throw new Error(\"BitListType requires a node to get leaves\");\n    return Math.ceil(arrayBasic_1.getLengthFromRootNode(node) / 8);\n  } // Merkleization: inherited from BitArrayType\n\n\n  hashTreeRoot(value) {\n    return merkleize_1.mixInLength(super.hashTreeRoot(value), value.bitLen);\n  } // Proofs: inherited from BitArrayType\n  // JSON: inherited from BitArrayType\n  // Deserializer helpers\n\n\n  deserializeUint8ArrayBitListFromBytes(data, start, end) {\n    const {\n      uint8Array,\n      bitLen\n    } = deserializeUint8ArrayBitListFromBytes(data, start, end);\n\n    if (bitLen > this.limitBits) {\n      throw Error(`bitLen over limit ${bitLen} > ${this.limitBits}`);\n    }\n\n    return {\n      uint8Array,\n      bitLen\n    };\n  }\n\n}\n\nexports.BitListType = BitListType;\n\nfunction deserializeUint8ArrayBitListFromBytes(data, start, end) {\n  if (end > data.length) {\n    throw Error(`BitList attempting to read byte ${end} of data length ${data.length}`);\n  }\n\n  const lastByte = data[end - 1];\n  const size = end - start;\n\n  if (lastByte === 0) {\n    throw new Error(\"Invalid deserialized bitlist, padding bit required\");\n  }\n\n  if (lastByte === 1) {\n    // Buffer.prototype.slice does not copy memory, Enforce Uint8Array usage https://github.com/nodejs/node/issues/28087\n    const uint8Array = Uint8Array.prototype.slice.call(data, start, end - 1);\n    const bitLen = (size - 1) * 8;\n    return {\n      uint8Array,\n      bitLen\n    };\n  } // the last byte is > 1, so a padding bit will exist in the last byte and need to be removed\n  // Buffer.prototype.slice does not copy memory, Enforce Uint8Array usage https://github.com/nodejs/node/issues/28087\n\n\n  const uint8Array = Uint8Array.prototype.slice.call(data, start, end); // mask lastChunkByte\n\n  const lastByteBitLength = lastByte.toString(2).length - 1;\n  const bitLen = (size - 1) * 8 + lastByteBitLength;\n  const mask = 0xff >> 8 - lastByteBitLength;\n  uint8Array[size - 1] &= mask;\n  return {\n    uint8Array,\n    bitLen\n  };\n}\n\nfunction bitLenToSerializedLength(bitLen) {\n  const bytes = Math.ceil(bitLen / 8); // +1 for the extra padding bit\n\n  return bitLen % 8 === 0 ? bytes + 1 : bytes;\n}\n/**\n * Apply padding bit to a serialized BitList already written to `output` at `offset`\n * @returns New offset after (maybe) writting a padding bit.\n */\n\n\nfunction applyPaddingBit(output, offset, bitLen) {\n  const byteLen = Math.ceil(bitLen / 8);\n  const newOffset = offset + byteLen;\n\n  if (bitLen % 8 === 0) {\n    output[newOffset] = 1;\n    return newOffset + 1;\n  } else {\n    output[newOffset - 1] |= 1 << bitLen % 8;\n    return newOffset;\n  }\n}","map":{"version":3,"sources":["../../src/type/bitList.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BitListType = void 0;\nconst persistent_merkle_tree_1 = require(\"@chainsafe/persistent-merkle-tree\");\nconst merkleize_1 = require(\"../util/merkleize\");\nconst named_1 = require(\"../util/named\");\nconst arrayBasic_1 = require(\"./arrayBasic\");\nconst bitArray_1 = require(\"../value/bitArray\");\nconst bitArray_2 = require(\"./bitArray\");\n/**\n * BitList: ordered variable-length collection of boolean values, limited to N bits\n * - Notation `Bitlist[N]`\n * - Value: `BitArray`, @see BitArray for a justification of its memory efficiency and performance\n * - View: `BitArrayTreeView`\n * - ViewDU: `BitArrayTreeViewDU`\n */\nclass BitListType extends bitArray_2.BitArrayType {\n    constructor(limitBits, opts) {\n        super();\n        this.limitBits = limitBits;\n        this.fixedSize = null;\n        this.minSize = 1; // +1 for the extra padding bit\n        this.isList = true;\n        if (limitBits === 0)\n            throw Error(\"List limit must be > 0\");\n        this.typeName = opts?.typeName ?? `BitList[${limitBits}]`;\n        // TODO Check that itemsPerChunk is an integer\n        this.maxChunkCount = Math.ceil(this.limitBits / 8 / 32);\n        this.chunkDepth = merkleize_1.maxChunksToDepth(this.maxChunkCount);\n        // Depth includes the extra level for the length node\n        this.depth = 1 + this.chunkDepth;\n        this.maxSize = Math.ceil(limitBits / 8) + 1; // +1 for the extra padding bit\n    }\n    static named(limitBits, opts) {\n        return new (named_1.namedClass(BitListType, opts.typeName))(limitBits, opts);\n    }\n    defaultValue() {\n        return bitArray_1.BitArray.fromBitLen(0);\n    }\n    // Views: inherited from BitArrayType\n    // Serialization + deserialization\n    value_serializedSize(value) {\n        return bitLenToSerializedLength(value.bitLen);\n    }\n    value_serializeToBytes(output, offset, value) {\n        output.uint8Array.set(value.uint8Array, offset);\n        return applyPaddingBit(output.uint8Array, offset, value.bitLen);\n    }\n    value_deserializeFromBytes(data, start, end) {\n        const { uint8Array, bitLen } = this.deserializeUint8ArrayBitListFromBytes(data.uint8Array, start, end);\n        return new bitArray_1.BitArray(uint8Array, bitLen);\n    }\n    tree_serializedSize(node) {\n        return bitLenToSerializedLength(arrayBasic_1.getLengthFromRootNode(node));\n    }\n    tree_serializeToBytes(output, offset, node) {\n        const chunksNode = arrayBasic_1.getChunksNodeFromRootNode(node);\n        const bitLen = arrayBasic_1.getLengthFromRootNode(node);\n        const byteLen = Math.ceil(bitLen / 8);\n        const chunkLen = Math.ceil(byteLen / 32);\n        const nodes = persistent_merkle_tree_1.getNodesAtDepth(chunksNode, this.chunkDepth, 0, chunkLen);\n        persistent_merkle_tree_1.packedNodeRootsToBytes(output.dataView, offset, byteLen, nodes);\n        return applyPaddingBit(output.uint8Array, offset, bitLen);\n    }\n    tree_deserializeFromBytes(data, start, end) {\n        const { uint8Array, bitLen } = this.deserializeUint8ArrayBitListFromBytes(data.uint8Array, start, end);\n        const dataView = new DataView(uint8Array.buffer, uint8Array.byteOffset, uint8Array.byteLength);\n        const chunksNode = persistent_merkle_tree_1.packedRootsBytesToNode(this.chunkDepth, dataView, 0, uint8Array.length);\n        return arrayBasic_1.addLengthNode(chunksNode, bitLen);\n    }\n    tree_getByteLen(node) {\n        if (!node)\n            throw new Error(\"BitListType requires a node to get leaves\");\n        return Math.ceil(arrayBasic_1.getLengthFromRootNode(node) / 8);\n    }\n    // Merkleization: inherited from BitArrayType\n    hashTreeRoot(value) {\n        return merkleize_1.mixInLength(super.hashTreeRoot(value), value.bitLen);\n    }\n    // Proofs: inherited from BitArrayType\n    // JSON: inherited from BitArrayType\n    // Deserializer helpers\n    deserializeUint8ArrayBitListFromBytes(data, start, end) {\n        const { uint8Array, bitLen } = deserializeUint8ArrayBitListFromBytes(data, start, end);\n        if (bitLen > this.limitBits) {\n            throw Error(`bitLen over limit ${bitLen} > ${this.limitBits}`);\n        }\n        return { uint8Array, bitLen };\n    }\n}\nexports.BitListType = BitListType;\nfunction deserializeUint8ArrayBitListFromBytes(data, start, end) {\n    if (end > data.length) {\n        throw Error(`BitList attempting to read byte ${end} of data length ${data.length}`);\n    }\n    const lastByte = data[end - 1];\n    const size = end - start;\n    if (lastByte === 0) {\n        throw new Error(\"Invalid deserialized bitlist, padding bit required\");\n    }\n    if (lastByte === 1) {\n        // Buffer.prototype.slice does not copy memory, Enforce Uint8Array usage https://github.com/nodejs/node/issues/28087\n        const uint8Array = Uint8Array.prototype.slice.call(data, start, end - 1);\n        const bitLen = (size - 1) * 8;\n        return { uint8Array, bitLen };\n    }\n    // the last byte is > 1, so a padding bit will exist in the last byte and need to be removed\n    // Buffer.prototype.slice does not copy memory, Enforce Uint8Array usage https://github.com/nodejs/node/issues/28087\n    const uint8Array = Uint8Array.prototype.slice.call(data, start, end);\n    // mask lastChunkByte\n    const lastByteBitLength = lastByte.toString(2).length - 1;\n    const bitLen = (size - 1) * 8 + lastByteBitLength;\n    const mask = 0xff >> (8 - lastByteBitLength);\n    uint8Array[size - 1] &= mask;\n    return { uint8Array, bitLen };\n}\nfunction bitLenToSerializedLength(bitLen) {\n    const bytes = Math.ceil(bitLen / 8);\n    // +1 for the extra padding bit\n    return bitLen % 8 === 0 ? bytes + 1 : bytes;\n}\n/**\n * Apply padding bit to a serialized BitList already written to `output` at `offset`\n * @returns New offset after (maybe) writting a padding bit.\n */\nfunction applyPaddingBit(output, offset, bitLen) {\n    const byteLen = Math.ceil(bitLen / 8);\n    const newOffset = offset + byteLen;\n    if (bitLen % 8 === 0) {\n        output[newOffset] = 1;\n        return newOffset + 1;\n    }\n    else {\n        output[newOffset - 1] |= 1 << bitLen % 8;\n        return newOffset;\n    }\n}\n//# sourceMappingURL=bitList.js.map"]},"metadata":{},"sourceType":"script"}