{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.BlobNetworkTransactionWrapper = exports.KZGProofType = exports.KZGCommitmentType = exports.SignedBlobTransactionType = exports.ECDSASignatureType = exports.BlobTransactionType = exports.AccessTupleType = exports.AddressType = exports.isAccessList = exports.isAccessListBuffer = exports.Capability = void 0;\n\nconst ssz_1 = require(\"@chainsafe/ssz\");\n\nconst constants_1 = require(\"./constants\");\n\nconst Bytes20 = new ssz_1.ByteVectorType(20);\nconst Bytes32 = new ssz_1.ByteVectorType(32);\nconst Bytes48 = new ssz_1.ByteVectorType(48);\nconst Uint64 = new ssz_1.UintBigintType(8);\nconst Uint256 = new ssz_1.UintBigintType(32);\n/**\n * Can be used in conjunction with {@link Transaction.supports}\n * to query on tx capabilities\n */\n\nvar Capability;\n\n(function (Capability) {\n  /**\n   * Tx supports EIP-155 replay protection\n   * See: [155](https://eips.ethereum.org/EIPS/eip-155) Replay Attack Protection EIP\n   */\n  Capability[Capability[\"EIP155ReplayProtection\"] = 155] = \"EIP155ReplayProtection\";\n  /**\n   * Tx supports EIP-1559 gas fee market mechanism\n   * See: [1559](https://eips.ethereum.org/EIPS/eip-1559) Fee Market EIP\n   */\n\n  Capability[Capability[\"EIP1559FeeMarket\"] = 1559] = \"EIP1559FeeMarket\";\n  /**\n   * Tx is a typed transaction as defined in EIP-2718\n   * See: [2718](https://eips.ethereum.org/EIPS/eip-2718) Transaction Type EIP\n   */\n\n  Capability[Capability[\"EIP2718TypedTransaction\"] = 2718] = \"EIP2718TypedTransaction\";\n  /**\n   * Tx supports access list generation as defined in EIP-2930\n   * See: [2930](https://eips.ethereum.org/EIPS/eip-2930) Access Lists EIP\n   */\n\n  Capability[Capability[\"EIP2930AccessLists\"] = 2930] = \"EIP2930AccessLists\";\n})(Capability = exports.Capability || (exports.Capability = {}));\n\nfunction isAccessListBuffer(input) {\n  if (input.length === 0) {\n    return true;\n  }\n\n  const firstItem = input[0];\n\n  if (Array.isArray(firstItem)) {\n    return true;\n  }\n\n  return false;\n}\n\nexports.isAccessListBuffer = isAccessListBuffer;\n\nfunction isAccessList(input) {\n  return !isAccessListBuffer(input); // This is exactly the same method, except the output is negated.\n}\n\nexports.isAccessList = isAccessList;\n/** EIP4844 types */\n\nexports.AddressType = Bytes20; // SSZ encoded address\n// SSZ encoded container for address and storage keys\n\nexports.AccessTupleType = new ssz_1.ContainerType({\n  address: exports.AddressType,\n  storageKeys: new ssz_1.ListCompositeType(Bytes32, constants_1.MAX_VERSIONED_HASHES_LIST_SIZE)\n}); // SSZ encoded blob transaction\n\nexports.BlobTransactionType = new ssz_1.ContainerType({\n  chainId: Uint256,\n  nonce: Uint64,\n  maxPriorityFeePerGas: Uint256,\n  maxFeePerGas: Uint256,\n  gas: Uint64,\n  to: new ssz_1.UnionType([new ssz_1.NoneType(), exports.AddressType]),\n  value: Uint256,\n  data: new ssz_1.ByteListType(constants_1.MAX_CALLDATA_SIZE),\n  accessList: new ssz_1.ListCompositeType(exports.AccessTupleType, constants_1.MAX_ACCESS_LIST_SIZE),\n  maxFeePerDataGas: Uint256,\n  blobVersionedHashes: new ssz_1.ListCompositeType(Bytes32, constants_1.MAX_VERSIONED_HASHES_LIST_SIZE)\n}); // SSZ encoded ECDSA Signature\n\nexports.ECDSASignatureType = new ssz_1.ContainerType({\n  yParity: new ssz_1.BooleanType(),\n  r: Uint256,\n  s: Uint256\n}); // SSZ encoded signed blob transaction\n\nexports.SignedBlobTransactionType = new ssz_1.ContainerType({\n  message: exports.BlobTransactionType,\n  signature: exports.ECDSASignatureType\n}); // SSZ encoded KZG Commitment/Proof (48 bytes)\n\nexports.KZGCommitmentType = Bytes48;\nexports.KZGProofType = exports.KZGCommitmentType; // SSZ encoded blob network transaction wrapper\n\nexports.BlobNetworkTransactionWrapper = new ssz_1.ContainerType({\n  tx: exports.SignedBlobTransactionType,\n  blobKzgs: new ssz_1.ListCompositeType(exports.KZGCommitmentType, constants_1.MAX_TX_WRAP_KZG_COMMITMENTS),\n  blobs: new ssz_1.ListCompositeType(new ssz_1.ByteVectorType(constants_1.FIELD_ELEMENTS_PER_BLOB * constants_1.BYTES_PER_FIELD_ELEMENT), constants_1.LIMIT_BLOBS_PER_TX),\n  kzgAggregatedProof: exports.KZGProofType\n});","map":{"version":3,"sources":["../src/types.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BlobNetworkTransactionWrapper = exports.KZGProofType = exports.KZGCommitmentType = exports.SignedBlobTransactionType = exports.ECDSASignatureType = exports.BlobTransactionType = exports.AccessTupleType = exports.AddressType = exports.isAccessList = exports.isAccessListBuffer = exports.Capability = void 0;\nconst ssz_1 = require(\"@chainsafe/ssz\");\nconst constants_1 = require(\"./constants\");\nconst Bytes20 = new ssz_1.ByteVectorType(20);\nconst Bytes32 = new ssz_1.ByteVectorType(32);\nconst Bytes48 = new ssz_1.ByteVectorType(48);\nconst Uint64 = new ssz_1.UintBigintType(8);\nconst Uint256 = new ssz_1.UintBigintType(32);\n/**\n * Can be used in conjunction with {@link Transaction.supports}\n * to query on tx capabilities\n */\nvar Capability;\n(function (Capability) {\n    /**\n     * Tx supports EIP-155 replay protection\n     * See: [155](https://eips.ethereum.org/EIPS/eip-155) Replay Attack Protection EIP\n     */\n    Capability[Capability[\"EIP155ReplayProtection\"] = 155] = \"EIP155ReplayProtection\";\n    /**\n     * Tx supports EIP-1559 gas fee market mechanism\n     * See: [1559](https://eips.ethereum.org/EIPS/eip-1559) Fee Market EIP\n     */\n    Capability[Capability[\"EIP1559FeeMarket\"] = 1559] = \"EIP1559FeeMarket\";\n    /**\n     * Tx is a typed transaction as defined in EIP-2718\n     * See: [2718](https://eips.ethereum.org/EIPS/eip-2718) Transaction Type EIP\n     */\n    Capability[Capability[\"EIP2718TypedTransaction\"] = 2718] = \"EIP2718TypedTransaction\";\n    /**\n     * Tx supports access list generation as defined in EIP-2930\n     * See: [2930](https://eips.ethereum.org/EIPS/eip-2930) Access Lists EIP\n     */\n    Capability[Capability[\"EIP2930AccessLists\"] = 2930] = \"EIP2930AccessLists\";\n})(Capability = exports.Capability || (exports.Capability = {}));\nfunction isAccessListBuffer(input) {\n    if (input.length === 0) {\n        return true;\n    }\n    const firstItem = input[0];\n    if (Array.isArray(firstItem)) {\n        return true;\n    }\n    return false;\n}\nexports.isAccessListBuffer = isAccessListBuffer;\nfunction isAccessList(input) {\n    return !isAccessListBuffer(input); // This is exactly the same method, except the output is negated.\n}\nexports.isAccessList = isAccessList;\n/** EIP4844 types */\nexports.AddressType = Bytes20; // SSZ encoded address\n// SSZ encoded container for address and storage keys\nexports.AccessTupleType = new ssz_1.ContainerType({\n    address: exports.AddressType,\n    storageKeys: new ssz_1.ListCompositeType(Bytes32, constants_1.MAX_VERSIONED_HASHES_LIST_SIZE),\n});\n// SSZ encoded blob transaction\nexports.BlobTransactionType = new ssz_1.ContainerType({\n    chainId: Uint256,\n    nonce: Uint64,\n    maxPriorityFeePerGas: Uint256,\n    maxFeePerGas: Uint256,\n    gas: Uint64,\n    to: new ssz_1.UnionType([new ssz_1.NoneType(), exports.AddressType]),\n    value: Uint256,\n    data: new ssz_1.ByteListType(constants_1.MAX_CALLDATA_SIZE),\n    accessList: new ssz_1.ListCompositeType(exports.AccessTupleType, constants_1.MAX_ACCESS_LIST_SIZE),\n    maxFeePerDataGas: Uint256,\n    blobVersionedHashes: new ssz_1.ListCompositeType(Bytes32, constants_1.MAX_VERSIONED_HASHES_LIST_SIZE),\n});\n// SSZ encoded ECDSA Signature\nexports.ECDSASignatureType = new ssz_1.ContainerType({\n    yParity: new ssz_1.BooleanType(),\n    r: Uint256,\n    s: Uint256,\n});\n// SSZ encoded signed blob transaction\nexports.SignedBlobTransactionType = new ssz_1.ContainerType({\n    message: exports.BlobTransactionType,\n    signature: exports.ECDSASignatureType,\n});\n// SSZ encoded KZG Commitment/Proof (48 bytes)\nexports.KZGCommitmentType = Bytes48;\nexports.KZGProofType = exports.KZGCommitmentType;\n// SSZ encoded blob network transaction wrapper\nexports.BlobNetworkTransactionWrapper = new ssz_1.ContainerType({\n    tx: exports.SignedBlobTransactionType,\n    blobKzgs: new ssz_1.ListCompositeType(exports.KZGCommitmentType, constants_1.MAX_TX_WRAP_KZG_COMMITMENTS),\n    blobs: new ssz_1.ListCompositeType(new ssz_1.ByteVectorType(constants_1.FIELD_ELEMENTS_PER_BLOB * constants_1.BYTES_PER_FIELD_ELEMENT), constants_1.LIMIT_BLOBS_PER_TX),\n    kzgAggregatedProof: exports.KZGProofType,\n});\n//# sourceMappingURL=types.js.map"]},"metadata":{},"sourceType":"script"}