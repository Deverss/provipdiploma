{"ast":null,"code":"\"use strict\";\n/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.randomBytes = exports.wrapConstructorWithOpts = exports.wrapConstructor = exports.checkOpts = exports.Hash = exports.concatBytes = exports.toBytes = exports.utf8ToBytes = exports.asyncLoop = exports.nextTick = exports.hexToBytes = exports.bytesToHex = exports.isLE = exports.rotr = exports.createView = exports.u32 = exports.u8 = void 0; // The import here is via the package name. This is to ensure\n// that exports mapping/resolution does fall into place.\n\nconst crypto_1 = require(\"@noble/hashes/crypto\"); // Cast array to different type\n\n\nconst u8 = arr => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\n\nexports.u8 = u8;\n\nconst u32 = arr => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n\nexports.u32 = u32; // Cast array to view\n\nconst createView = arr => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n\nexports.createView = createView; // The rotate right (circular right shift) operation for uint32\n\nconst rotr = (word, shift) => word << 32 - shift | word >>> shift;\n\nexports.rotr = rotr;\nexports.isLE = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44; // There is almost no big endian hardware, but js typed arrays uses platform specific endianness.\n// So, just to be sure not to corrupt anything.\n\nif (!exports.isLE) throw new Error('Non little-endian hardware is not supported');\nconst hexes = Array.from({\n  length: 256\n}, (v, i) => i.toString(16).padStart(2, '0'));\n/**\n * @example bytesToHex(Uint8Array.from([0xde, 0xad, 0xbe, 0xef]))\n */\n\nfunction bytesToHex(uint8a) {\n  // pre-caching improves the speed 6x\n  if (!(uint8a instanceof Uint8Array)) throw new Error('Uint8Array expected');\n  let hex = '';\n\n  for (let i = 0; i < uint8a.length; i++) {\n    hex += hexes[uint8a[i]];\n  }\n\n  return hex;\n}\n\nexports.bytesToHex = bytesToHex;\n/**\n * @example hexToBytes('deadbeef')\n */\n\nfunction hexToBytes(hex) {\n  if (typeof hex !== 'string') {\n    throw new TypeError('hexToBytes: expected string, got ' + typeof hex);\n  }\n\n  if (hex.length % 2) throw new Error('hexToBytes: received invalid unpadded hex');\n  const array = new Uint8Array(hex.length / 2);\n\n  for (let i = 0; i < array.length; i++) {\n    const j = i * 2;\n    const hexByte = hex.slice(j, j + 2);\n    const byte = Number.parseInt(hexByte, 16);\n    if (Number.isNaN(byte) || byte < 0) throw new Error('Invalid byte sequence');\n    array[i] = byte;\n  }\n\n  return array;\n}\n\nexports.hexToBytes = hexToBytes; // There is no setImmediate in browser and setTimeout is slow. However, call to async function will return Promise\n// which will be fullfiled only on next scheduler queue processing step and this is exactly what we need.\n\nconst nextTick = async () => {};\n\nexports.nextTick = nextTick; // Returns control to thread each 'tick' ms to avoid blocking\n\nasync function asyncLoop(iters, tick, cb) {\n  let ts = Date.now();\n\n  for (let i = 0; i < iters; i++) {\n    cb(i); // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n\n    const diff = Date.now() - ts;\n    if (diff >= 0 && diff < tick) continue;\n    await (0, exports.nextTick)();\n    ts += diff;\n  }\n}\n\nexports.asyncLoop = asyncLoop;\n\nfunction utf8ToBytes(str) {\n  if (typeof str !== 'string') {\n    throw new TypeError(`utf8ToBytes expected string, got ${typeof str}`);\n  }\n\n  return new TextEncoder().encode(str);\n}\n\nexports.utf8ToBytes = utf8ToBytes;\n\nfunction toBytes(data) {\n  if (typeof data === 'string') data = utf8ToBytes(data);\n  if (!(data instanceof Uint8Array)) throw new TypeError(`Expected input type is Uint8Array (got ${typeof data})`);\n  return data;\n}\n\nexports.toBytes = toBytes;\n/**\n * Concats Uint8Array-s into one; like `Buffer.concat([buf1, buf2])`\n * @example concatBytes(buf1, buf2)\n */\n\nfunction concatBytes(...arrays) {\n  if (!arrays.every(a => a instanceof Uint8Array)) throw new Error('Uint8Array list expected');\n  if (arrays.length === 1) return arrays[0];\n  const length = arrays.reduce((a, arr) => a + arr.length, 0);\n  const result = new Uint8Array(length);\n\n  for (let i = 0, pad = 0; i < arrays.length; i++) {\n    const arr = arrays[i];\n    result.set(arr, pad);\n    pad += arr.length;\n  }\n\n  return result;\n}\n\nexports.concatBytes = concatBytes; // For runtime check if class implements interface\n\nclass Hash {\n  // Safe version that clones internal state\n  clone() {\n    return this._cloneInto();\n  }\n\n}\n\nexports.Hash = Hash; // Check if object doens't have custom constructor (like Uint8Array/Array)\n\nconst isPlainObject = obj => Object.prototype.toString.call(obj) === '[object Object]' && obj.constructor === Object;\n\nfunction checkOpts(defaults, opts) {\n  if (opts !== undefined && (typeof opts !== 'object' || !isPlainObject(opts))) throw new TypeError('Options should be object or undefined');\n  const merged = Object.assign(defaults, opts);\n  return merged;\n}\n\nexports.checkOpts = checkOpts;\n\nfunction wrapConstructor(hashConstructor) {\n  const hashC = message => hashConstructor().update(toBytes(message)).digest();\n\n  const tmp = hashConstructor();\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n\n  hashC.create = () => hashConstructor();\n\n  return hashC;\n}\n\nexports.wrapConstructor = wrapConstructor;\n\nfunction wrapConstructorWithOpts(hashCons) {\n  const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n\n  const tmp = hashCons({});\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n\n  hashC.create = opts => hashCons(opts);\n\n  return hashC;\n}\n\nexports.wrapConstructorWithOpts = wrapConstructorWithOpts;\n/**\n * Secure PRNG\n */\n\nfunction randomBytes(bytesLength = 32) {\n  if (crypto_1.crypto.web) {\n    return crypto_1.crypto.web.getRandomValues(new Uint8Array(bytesLength));\n  } else if (crypto_1.crypto.node) {\n    return new Uint8Array(crypto_1.crypto.node.randomBytes(bytesLength).buffer);\n  } else {\n    throw new Error(\"The environment doesn't have randomBytes function\");\n  }\n}\n\nexports.randomBytes = randomBytes;","map":{"version":3,"sources":["src/utils.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.randomBytes = exports.wrapConstructorWithOpts = exports.wrapConstructor = exports.checkOpts = exports.Hash = exports.concatBytes = exports.toBytes = exports.utf8ToBytes = exports.asyncLoop = exports.nextTick = exports.hexToBytes = exports.bytesToHex = exports.isLE = exports.rotr = exports.createView = exports.u32 = exports.u8 = void 0;\n// The import here is via the package name. This is to ensure\n// that exports mapping/resolution does fall into place.\nconst crypto_1 = require(\"@noble/hashes/crypto\");\n// Cast array to different type\nconst u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\nexports.u8 = u8;\nconst u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\nexports.u32 = u32;\n// Cast array to view\nconst createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\nexports.createView = createView;\n// The rotate right (circular right shift) operation for uint32\nconst rotr = (word, shift) => (word << (32 - shift)) | (word >>> shift);\nexports.rotr = rotr;\nexports.isLE = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;\n// There is almost no big endian hardware, but js typed arrays uses platform specific endianness.\n// So, just to be sure not to corrupt anything.\nif (!exports.isLE)\n    throw new Error('Non little-endian hardware is not supported');\nconst hexes = Array.from({ length: 256 }, (v, i) => i.toString(16).padStart(2, '0'));\n/**\n * @example bytesToHex(Uint8Array.from([0xde, 0xad, 0xbe, 0xef]))\n */\nfunction bytesToHex(uint8a) {\n    // pre-caching improves the speed 6x\n    if (!(uint8a instanceof Uint8Array))\n        throw new Error('Uint8Array expected');\n    let hex = '';\n    for (let i = 0; i < uint8a.length; i++) {\n        hex += hexes[uint8a[i]];\n    }\n    return hex;\n}\nexports.bytesToHex = bytesToHex;\n/**\n * @example hexToBytes('deadbeef')\n */\nfunction hexToBytes(hex) {\n    if (typeof hex !== 'string') {\n        throw new TypeError('hexToBytes: expected string, got ' + typeof hex);\n    }\n    if (hex.length % 2)\n        throw new Error('hexToBytes: received invalid unpadded hex');\n    const array = new Uint8Array(hex.length / 2);\n    for (let i = 0; i < array.length; i++) {\n        const j = i * 2;\n        const hexByte = hex.slice(j, j + 2);\n        const byte = Number.parseInt(hexByte, 16);\n        if (Number.isNaN(byte) || byte < 0)\n            throw new Error('Invalid byte sequence');\n        array[i] = byte;\n    }\n    return array;\n}\nexports.hexToBytes = hexToBytes;\n// There is no setImmediate in browser and setTimeout is slow. However, call to async function will return Promise\n// which will be fullfiled only on next scheduler queue processing step and this is exactly what we need.\nconst nextTick = async () => { };\nexports.nextTick = nextTick;\n// Returns control to thread each 'tick' ms to avoid blocking\nasync function asyncLoop(iters, tick, cb) {\n    let ts = Date.now();\n    for (let i = 0; i < iters; i++) {\n        cb(i);\n        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n        const diff = Date.now() - ts;\n        if (diff >= 0 && diff < tick)\n            continue;\n        await (0, exports.nextTick)();\n        ts += diff;\n    }\n}\nexports.asyncLoop = asyncLoop;\nfunction utf8ToBytes(str) {\n    if (typeof str !== 'string') {\n        throw new TypeError(`utf8ToBytes expected string, got ${typeof str}`);\n    }\n    return new TextEncoder().encode(str);\n}\nexports.utf8ToBytes = utf8ToBytes;\nfunction toBytes(data) {\n    if (typeof data === 'string')\n        data = utf8ToBytes(data);\n    if (!(data instanceof Uint8Array))\n        throw new TypeError(`Expected input type is Uint8Array (got ${typeof data})`);\n    return data;\n}\nexports.toBytes = toBytes;\n/**\n * Concats Uint8Array-s into one; like `Buffer.concat([buf1, buf2])`\n * @example concatBytes(buf1, buf2)\n */\nfunction concatBytes(...arrays) {\n    if (!arrays.every((a) => a instanceof Uint8Array))\n        throw new Error('Uint8Array list expected');\n    if (arrays.length === 1)\n        return arrays[0];\n    const length = arrays.reduce((a, arr) => a + arr.length, 0);\n    const result = new Uint8Array(length);\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\n        const arr = arrays[i];\n        result.set(arr, pad);\n        pad += arr.length;\n    }\n    return result;\n}\nexports.concatBytes = concatBytes;\n// For runtime check if class implements interface\nclass Hash {\n    // Safe version that clones internal state\n    clone() {\n        return this._cloneInto();\n    }\n}\nexports.Hash = Hash;\n// Check if object doens't have custom constructor (like Uint8Array/Array)\nconst isPlainObject = (obj) => Object.prototype.toString.call(obj) === '[object Object]' && obj.constructor === Object;\nfunction checkOpts(defaults, opts) {\n    if (opts !== undefined && (typeof opts !== 'object' || !isPlainObject(opts)))\n        throw new TypeError('Options should be object or undefined');\n    const merged = Object.assign(defaults, opts);\n    return merged;\n}\nexports.checkOpts = checkOpts;\nfunction wrapConstructor(hashConstructor) {\n    const hashC = (message) => hashConstructor().update(toBytes(message)).digest();\n    const tmp = hashConstructor();\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = () => hashConstructor();\n    return hashC;\n}\nexports.wrapConstructor = wrapConstructor;\nfunction wrapConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\nexports.wrapConstructorWithOpts = wrapConstructorWithOpts;\n/**\n * Secure PRNG\n */\nfunction randomBytes(bytesLength = 32) {\n    if (crypto_1.crypto.web) {\n        return crypto_1.crypto.web.getRandomValues(new Uint8Array(bytesLength));\n    }\n    else if (crypto_1.crypto.node) {\n        return new Uint8Array(crypto_1.crypto.node.randomBytes(bytesLength).buffer);\n    }\n    else {\n        throw new Error(\"The environment doesn't have randomBytes function\");\n    }\n}\nexports.randomBytes = randomBytes;\n//# sourceMappingURL=utils.js.map"]},"metadata":{},"sourceType":"script"}