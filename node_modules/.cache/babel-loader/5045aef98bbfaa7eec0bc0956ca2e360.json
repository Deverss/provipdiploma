{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.nextPowerOf2 = exports.maxChunksToDepth = exports.bitLength = exports.mixInLength = exports.splitIntoRootChunks = exports.merkleize = exports.hash64 = void 0;\n\nconst as_sha256_1 = require(\"@chainsafe/as-sha256\");\n\nconst zeros_1 = require(\"./zeros\");\n\nfunction hash64(bytes32A, bytes32B) {\n  return as_sha256_1.digest2Bytes32(bytes32A, bytes32B);\n}\n\nexports.hash64 = hash64;\n\nfunction merkleize(chunks, padFor) {\n  const layerCount = bitLength(nextPowerOf2(padFor) - 1);\n\n  if (chunks.length == 0) {\n    return zeros_1.zeroHash(layerCount);\n  }\n\n  let chunkCount = chunks.length; // Instead of pushing on all padding zero chunks at the leaf level\n  // we push on zero hash chunks at the highest possible level to avoid over-hashing\n\n  for (let l = 0; l < layerCount; l++) {\n    const padCount = chunkCount % 2;\n    const paddedChunkCount = chunkCount + padCount; // if the chunks.length is odd\n    // we need to push on the zero-hash of that level to merkleize that level\n\n    for (let i = 0; i < padCount; i++) {\n      chunks[chunkCount + i] = zeros_1.zeroHash(l);\n    }\n\n    for (let i = 0; i < paddedChunkCount; i += 2) {\n      chunks[i / 2] = hash64(chunks[i], chunks[i + 1]);\n    }\n\n    chunkCount = paddedChunkCount / 2;\n  }\n\n  return chunks[0];\n}\n\nexports.merkleize = merkleize;\n/**\n * Split a long Uint8Array into Uint8Array of exactly 32 bytes\n */\n\nfunction splitIntoRootChunks(longChunk) {\n  const chunkCount = Math.ceil(longChunk.length / 32);\n  const chunks = new Array(chunkCount);\n\n  for (let i = 0; i < chunkCount; i++) {\n    const chunk = new Uint8Array(32);\n    chunk.set(longChunk.slice(i * 32, (i + 1) * 32));\n    chunks[i] = chunk;\n  }\n\n  return chunks;\n}\n\nexports.splitIntoRootChunks = splitIntoRootChunks;\n/** @ignore */\n\nfunction mixInLength(root, length) {\n  const lengthBuf = Buffer.alloc(32);\n  lengthBuf.writeUIntLE(length, 0, 6);\n  return hash64(root, lengthBuf);\n}\n\nexports.mixInLength = mixInLength; // x2 faster than bitLengthStr() which uses Number.toString(2)\n\nfunction bitLength(i) {\n  if (i === 0) {\n    return 0;\n  }\n\n  return Math.floor(Math.log2(i)) + 1;\n}\n\nexports.bitLength = bitLength;\n/**\n * Given maxChunkCount return the chunkDepth\n * ```\n * n: [0,1,2,3,4,5,6,7,8,9]\n * d: [0,0,1,2,2,3,3,3,3,4]\n * ```\n */\n\nfunction maxChunksToDepth(n) {\n  if (n === 0) return 0;\n  return Math.ceil(Math.log2(n));\n}\n\nexports.maxChunksToDepth = maxChunksToDepth;\n/** @ignore */\n\nfunction nextPowerOf2(n) {\n  return n <= 0 ? 1 : Math.pow(2, bitLength(n - 1));\n}\n\nexports.nextPowerOf2 = nextPowerOf2;","map":{"version":3,"sources":["../../src/util/merkleize.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.nextPowerOf2 = exports.maxChunksToDepth = exports.bitLength = exports.mixInLength = exports.splitIntoRootChunks = exports.merkleize = exports.hash64 = void 0;\nconst as_sha256_1 = require(\"@chainsafe/as-sha256\");\nconst zeros_1 = require(\"./zeros\");\nfunction hash64(bytes32A, bytes32B) {\n    return as_sha256_1.digest2Bytes32(bytes32A, bytes32B);\n}\nexports.hash64 = hash64;\nfunction merkleize(chunks, padFor) {\n    const layerCount = bitLength(nextPowerOf2(padFor) - 1);\n    if (chunks.length == 0) {\n        return zeros_1.zeroHash(layerCount);\n    }\n    let chunkCount = chunks.length;\n    // Instead of pushing on all padding zero chunks at the leaf level\n    // we push on zero hash chunks at the highest possible level to avoid over-hashing\n    for (let l = 0; l < layerCount; l++) {\n        const padCount = chunkCount % 2;\n        const paddedChunkCount = chunkCount + padCount;\n        // if the chunks.length is odd\n        // we need to push on the zero-hash of that level to merkleize that level\n        for (let i = 0; i < padCount; i++) {\n            chunks[chunkCount + i] = zeros_1.zeroHash(l);\n        }\n        for (let i = 0; i < paddedChunkCount; i += 2) {\n            chunks[i / 2] = hash64(chunks[i], chunks[i + 1]);\n        }\n        chunkCount = paddedChunkCount / 2;\n    }\n    return chunks[0];\n}\nexports.merkleize = merkleize;\n/**\n * Split a long Uint8Array into Uint8Array of exactly 32 bytes\n */\nfunction splitIntoRootChunks(longChunk) {\n    const chunkCount = Math.ceil(longChunk.length / 32);\n    const chunks = new Array(chunkCount);\n    for (let i = 0; i < chunkCount; i++) {\n        const chunk = new Uint8Array(32);\n        chunk.set(longChunk.slice(i * 32, (i + 1) * 32));\n        chunks[i] = chunk;\n    }\n    return chunks;\n}\nexports.splitIntoRootChunks = splitIntoRootChunks;\n/** @ignore */\nfunction mixInLength(root, length) {\n    const lengthBuf = Buffer.alloc(32);\n    lengthBuf.writeUIntLE(length, 0, 6);\n    return hash64(root, lengthBuf);\n}\nexports.mixInLength = mixInLength;\n// x2 faster than bitLengthStr() which uses Number.toString(2)\nfunction bitLength(i) {\n    if (i === 0) {\n        return 0;\n    }\n    return Math.floor(Math.log2(i)) + 1;\n}\nexports.bitLength = bitLength;\n/**\n * Given maxChunkCount return the chunkDepth\n * ```\n * n: [0,1,2,3,4,5,6,7,8,9]\n * d: [0,0,1,2,2,3,3,3,3,4]\n * ```\n */\nfunction maxChunksToDepth(n) {\n    if (n === 0)\n        return 0;\n    return Math.ceil(Math.log2(n));\n}\nexports.maxChunksToDepth = maxChunksToDepth;\n/** @ignore */\nfunction nextPowerOf2(n) {\n    return n <= 0 ? 1 : Math.pow(2, bitLength(n - 1));\n}\nexports.nextPowerOf2 = nextPowerOf2;\n//# sourceMappingURL=merkleize.js.map"]},"metadata":{},"sourceType":"script"}