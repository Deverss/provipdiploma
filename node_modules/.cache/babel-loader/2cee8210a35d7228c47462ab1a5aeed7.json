{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.BlobEIP4844Transaction = void 0;\n\nconst ssz_1 = require(\"@chainsafe/ssz\");\n\nconst util_1 = require(\"@ethereumjs/util\");\n\nconst keccak_1 = require(\"ethereum-cryptography/keccak\");\n\nconst baseTransaction_1 = require(\"./baseTransaction\");\n\nconst constants_1 = require(\"./constants\");\n\nconst kzg_1 = require(\"./kzg/kzg\");\n\nconst types_1 = require(\"./types\");\n\nconst util_2 = require(\"./util\");\n\nconst blobHelpers_1 = require(\"./utils/blobHelpers\");\n\nconst TRANSACTION_TYPE = 0x05;\nconst TRANSACTION_TYPE_BUFFER = Buffer.from(TRANSACTION_TYPE.toString(16).padStart(2, '0'), 'hex');\n\nconst validateBlobTransactionNetworkWrapper = (versionedHashes, blobs, commitments, kzgProof, version) => {\n  if (!(versionedHashes.length === blobs.length && blobs.length === commitments.length)) {\n    throw new Error('Number of versionedHashes, blobs, and commitments not all equal');\n  }\n\n  try {\n    kzg_1.kzg.verifyAggregateKzgProof(blobs, commitments, kzgProof);\n  } catch (e) {\n    throw new Error('KZG proof cannot be verified from blobs/commitments');\n  }\n\n  for (let x = 0; x < versionedHashes.length; x++) {\n    const computedVersionedHash = (0, blobHelpers_1.computeVersionedHash)(commitments[x], version);\n\n    if (!(0, ssz_1.byteArrayEquals)(computedVersionedHash, versionedHashes[x])) {\n      throw new Error(`commitment for blob at index ${x} does not match versionedHash`);\n    }\n  }\n};\n/**\n * Typed transaction with a new gas fee market mechanism for transactions that include \"blobs\" of data\n *\n * - TransactionType: 5\n * - EIP: [EIP-4844](https://eips.ethereum.org/EIPS/eip-4844)\n */\n\n\nclass BlobEIP4844Transaction extends baseTransaction_1.BaseTransaction {\n  /**\n   * This constructor takes the values, validates them, assigns them and freezes the object.\n   *\n   * It is not recommended to use this constructor directly. Instead use\n   * the static constructors or factory methods to assist in creating a Transaction object from\n   * varying data types.\n   */\n  constructor(txData, opts = {}) {\n    var _txData$blobs, _txData$kzgCommitment;\n\n    super({ ...txData,\n      type: TRANSACTION_TYPE\n    }, opts);\n    const {\n      chainId,\n      accessList,\n      maxFeePerGas,\n      maxPriorityFeePerGas,\n      maxFeePerDataGas\n    } = txData;\n    this.common = this._getCommon(opts.common, chainId);\n    this.chainId = this.common.chainId();\n\n    if (this.common.isActivatedEIP(1559) === false) {\n      throw new Error('EIP-1559 not enabled on Common');\n    }\n\n    if (this.common.isActivatedEIP(4844) === false) {\n      throw new Error('EIP-4844 not enabled on Common');\n    }\n\n    this.activeCapabilities = this.activeCapabilities.concat([1559, 2718, 2930]); // Populate the access list fields\n\n    const accessListData = util_2.AccessLists.getAccessListData(accessList ?? []);\n    this.accessList = accessListData.accessList;\n    this.AccessListJSON = accessListData.AccessListJSON; // Verify the access list format.\n\n    util_2.AccessLists.verifyAccessList(this.accessList);\n    this.maxFeePerGas = (0, util_1.bufferToBigInt)((0, util_1.toBuffer)(maxFeePerGas === '' ? '0x' : maxFeePerGas));\n    this.maxPriorityFeePerGas = (0, util_1.bufferToBigInt)((0, util_1.toBuffer)(maxPriorityFeePerGas === '' ? '0x' : maxPriorityFeePerGas));\n\n    this._validateCannotExceedMaxInteger({\n      maxFeePerGas: this.maxFeePerGas,\n      maxPriorityFeePerGas: this.maxPriorityFeePerGas\n    });\n\n    baseTransaction_1.BaseTransaction._validateNotArray(txData);\n\n    if (this.gasLimit * this.maxFeePerGas > util_1.MAX_INTEGER) {\n      const msg = this._errorMsg('gasLimit * maxFeePerGas cannot exceed MAX_INTEGER (2^256-1)');\n\n      throw new Error(msg);\n    }\n\n    if (this.maxFeePerGas < this.maxPriorityFeePerGas) {\n      const msg = this._errorMsg('maxFeePerGas cannot be less than maxPriorityFeePerGas (The total must be the larger of the two)');\n\n      throw new Error(msg);\n    }\n\n    this.maxFeePerDataGas = (0, util_1.bufferToBigInt)((0, util_1.toBuffer)((maxFeePerDataGas ?? '') === '' ? '0x' : maxFeePerDataGas));\n    this.versionedHashes = (txData.versionedHashes ?? []).map(vh => (0, util_1.toBuffer)(vh));\n\n    this._validateYParity();\n\n    this._validateHighS();\n\n    if (this.common.isActivatedEIP(3860)) {\n      (0, util_2.checkMaxInitCodeSize)(this.common, this.data.length);\n    }\n\n    for (const hash of this.versionedHashes) {\n      if (hash.length !== 32) {\n        const msg = this._errorMsg('versioned hash is invalid length');\n\n        throw new Error(msg);\n      }\n\n      if (BigInt(hash[0]) !== this.common.paramByEIP('sharding', 'blobCommitmentVersionKzg', 4844)) {\n        const msg = this._errorMsg('versioned hash does not start with KZG commitment version');\n\n        throw new Error(msg);\n      }\n    }\n\n    if (this.versionedHashes.length > constants_1.LIMIT_BLOBS_PER_TX) {\n      const msg = this._errorMsg(`tx can contain at most ${constants_1.LIMIT_BLOBS_PER_TX} blobs`);\n\n      throw new Error(msg);\n    }\n\n    this.blobs = (_txData$blobs = txData.blobs) === null || _txData$blobs === void 0 ? void 0 : _txData$blobs.map(blob => (0, util_1.toBuffer)(blob));\n    this.kzgCommitments = (_txData$kzgCommitment = txData.kzgCommitments) === null || _txData$kzgCommitment === void 0 ? void 0 : _txData$kzgCommitment.map(commitment => (0, util_1.toBuffer)(commitment));\n    this.aggregateKzgProof = (0, util_1.toBuffer)(txData.kzgProof);\n    const freeze = (opts === null || opts === void 0 ? void 0 : opts.freeze) ?? true;\n\n    if (freeze) {\n      Object.freeze(this);\n    }\n  }\n\n  static fromTxData(txData, opts) {\n    return new BlobEIP4844Transaction(txData, opts);\n  }\n  /**\n   * Creates the minimal representation of a blob transaction from the network wrapper version.\n   * The minimal representation is used when adding transactions to an execution payload/block\n   * @param txData a {@link BlobEIP4844Transaction} containing optional blobs/kzg commitments\n   * @param opts - dictionary of {@link TxOptions}\n   * @returns the \"minimal\" representation of a BlobEIP4844Transaction (i.e. transaction object minus blobs and kzg commitments)\n   */\n\n\n  static minimalFromNetworkWrapper(txData, opts) {\n    const tx = BlobEIP4844Transaction.fromTxData({ ...txData,\n      ...{\n        blobs: undefined,\n        kzgCommitments: undefined,\n        kzgProof: undefined\n      }\n    }, opts);\n    return tx;\n  }\n  /**\n   * Creates a transaction from the network encoding of a blob transaction (with blobs/commitments/proof)\n   * @param serialized a buffer representing a serialized BlobTransactionNetworkWrapper\n   * @param opts any TxOptions defined\n   * @returns a BlobEIP4844Transaction\n   * @throws if no KZG library is loaded -- using the `initKzg` helper method -- or if `opts.common` not provided\n   */\n\n\n  static fromSerializedBlobTxNetworkWrapper(serialized, opts) {\n    if (!opts || !opts.common) {\n      throw new Error('common instance required to validate versioned hashes');\n    } // Validate network wrapper\n\n\n    const wrapper = types_1.BlobNetworkTransactionWrapper.deserialize(serialized.slice(1));\n    const decodedTx = wrapper.tx.message;\n    const version = Number(opts.common.paramByEIP('sharding', 'blobCommitmentVersionKzg', 4844));\n    validateBlobTransactionNetworkWrapper(decodedTx.blobVersionedHashes, wrapper.blobs, wrapper.blobKzgs, wrapper.kzgAggregatedProof, version);\n    const accessList = [];\n\n    for (const listItem of decodedTx.accessList) {\n      const address = Buffer.from(listItem.address);\n      const storageKeys = listItem.storageKeys.map(key => Buffer.from(key));\n      const accessListItem = [address, storageKeys];\n      accessList.push(accessListItem);\n    }\n\n    const to = decodedTx.to.value === null ? undefined : util_1.Address.fromString((0, util_1.bufferToHex)(Buffer.from(decodedTx.to.value)));\n    const versionedHashes = decodedTx.blobVersionedHashes.map(el => Buffer.from(el));\n    const commitments = wrapper.blobKzgs.map(el => Buffer.from(el));\n    const blobs = wrapper.blobs.map(el => Buffer.from(el));\n    const txData = { ...decodedTx,\n      ...{\n        versionedHashes,\n        accessList,\n        to,\n        blobs,\n        kzgCommitments: commitments,\n        kzgProof: Buffer.from(wrapper.kzgAggregatedProof),\n        r: wrapper.tx.signature.r,\n        s: wrapper.tx.signature.s,\n        v: BigInt(wrapper.tx.signature.yParity),\n        gasLimit: decodedTx.gas,\n        maxFeePerGas: decodedTx.maxFeePerGas,\n        maxPriorityFeePerGas: decodedTx.maxPriorityFeePerGas\n      }\n    };\n    return new BlobEIP4844Transaction(txData, opts);\n  }\n  /**\n   * Creates a transaction from the \"minimal\" encoding of a blob transaction (without blobs/commitments/kzg proof)\n   * @param serialized a buffer representing a serialized signed blob transaction\n   * @param opts any TxOptions defined\n   * @returns a BlobEIP4844Transaction\n   */\n\n\n  static fromSerializedTx(serialized, opts) {\n    const decoded = types_1.SignedBlobTransactionType.deserialize(serialized.slice(1));\n    const tx = decoded.message;\n    const accessList = [];\n\n    for (const listItem of tx.accessList) {\n      const address = Buffer.from(listItem.address);\n      const storageKeys = listItem.storageKeys.map(key => Buffer.from(key));\n      const accessListItem = [address, storageKeys];\n      accessList.push(accessListItem);\n    }\n\n    const to = tx.to.value === null ? undefined : util_1.Address.fromString((0, util_1.bufferToHex)(Buffer.from(tx.to.value)));\n    const versionedHashes = tx.blobVersionedHashes.map(el => Buffer.from(el));\n    const txData = { ...tx,\n      ...{\n        versionedHashes,\n        to,\n        accessList,\n        r: decoded.signature.r,\n        s: decoded.signature.s,\n        v: BigInt(decoded.signature.yParity),\n        gasLimit: decoded.message.gas\n      }\n    };\n    return new BlobEIP4844Transaction(txData, opts);\n  }\n  /**\n   * The up front amount that an account must have for this transaction to be valid\n   * @param baseFee The base fee of the block (will be set to 0 if not provided)\n   */\n\n\n  getUpfrontCost(baseFee = BigInt(0)) {\n    const prio = this.maxPriorityFeePerGas;\n    const maxBase = this.maxFeePerGas - baseFee;\n    const inclusionFeePerGas = prio < maxBase ? prio : maxBase;\n    const gasPrice = inclusionFeePerGas + baseFee;\n    return this.gasLimit * gasPrice + this.value;\n  }\n  /**\n   * This method is not implemented for blob transactions as the `raw` method is used exclusively with\n   * rlp encoding and these transactions use SSZ for serialization.\n   */\n\n\n  raw() {\n    throw new Error('Method not implemented.');\n  }\n\n  toValue() {\n    var _this$to;\n\n    const to = {\n      selector: this.to !== undefined ? 1 : 0,\n      value: ((_this$to = this.to) === null || _this$to === void 0 ? void 0 : _this$to.toBuffer()) ?? null\n    };\n    return {\n      message: {\n        chainId: this.common.chainId(),\n        nonce: this.nonce,\n        maxPriorityFeePerGas: this.maxPriorityFeePerGas,\n        maxFeePerGas: this.maxFeePerGas,\n        gas: this.gasLimit,\n        to,\n        value: this.value,\n        data: this.data,\n        accessList: this.accessList.map(listItem => {\n          return {\n            address: listItem[0],\n            storageKeys: listItem[1]\n          };\n        }),\n        blobVersionedHashes: this.versionedHashes,\n        maxFeePerDataGas: this.maxFeePerDataGas\n      },\n      // TODO: Decide how to serialize an unsigned transaction\n      signature: {\n        r: this.r ?? BigInt(0),\n        s: this.s ?? BigInt(0),\n        yParity: this.v === BigInt(1) ? true : false\n      }\n    };\n  }\n  /**\n   * Serialize a blob transaction to the execution payload variant\n   * @returns the minimum (execution payload) serialization of a signed transaction\n   */\n\n\n  serialize() {\n    const sszEncodedTx = types_1.SignedBlobTransactionType.serialize(this.toValue());\n    return Buffer.concat([TRANSACTION_TYPE_BUFFER, sszEncodedTx]);\n  }\n  /**\n   * @returns the serialized form of a blob transaction in the network wrapper format (used for gossipping mempool transactions over devp2p)\n   */\n\n\n  serializeNetworkWrapper() {\n    var _this$to2, _this$blobs, _this$kzgCommitments;\n\n    if (this.blobs === undefined || this.kzgCommitments === undefined || this.aggregateKzgProof === undefined) {\n      throw new Error('cannot serialize network wrapper without blobs, KZG commitments and aggregate KZG proof provided');\n    }\n\n    const to = {\n      selector: this.to !== undefined ? 1 : 0,\n      value: ((_this$to2 = this.to) === null || _this$to2 === void 0 ? void 0 : _this$to2.toBuffer()) ?? null\n    };\n    const blobArrays = ((_this$blobs = this.blobs) === null || _this$blobs === void 0 ? void 0 : _this$blobs.map(blob => Uint8Array.from(blob))) ?? [];\n    const serializedTxWrapper = types_1.BlobNetworkTransactionWrapper.serialize({\n      blobs: blobArrays,\n      blobKzgs: ((_this$kzgCommitments = this.kzgCommitments) === null || _this$kzgCommitments === void 0 ? void 0 : _this$kzgCommitments.map(commitment => Uint8Array.from(commitment))) ?? [],\n      tx: { ...(0, util_2.blobTxToNetworkWrapperDataFormat)(this),\n        ...to\n      },\n      kzgAggregatedProof: Uint8Array.from(this.aggregateKzgProof ?? [])\n    });\n    return Buffer.concat([Buffer.from([0x05]), serializedTxWrapper]);\n  }\n\n  getMessageToSign(_hashMessage) {\n    return this.unsignedHash();\n  }\n  /**\n   * Returns the hash of a blob transaction\n   */\n\n\n  unsignedHash() {\n    const serializedTx = types_1.BlobTransactionType.serialize(this.toValue().message);\n    return Buffer.from((0, keccak_1.keccak256)(Buffer.concat([TRANSACTION_TYPE_BUFFER, serializedTx])));\n  }\n\n  hash() {\n    return Buffer.from((0, keccak_1.keccak256)(this.serialize()));\n  }\n\n  getMessageToVerifySignature() {\n    return this.getMessageToSign();\n  }\n  /**\n   * Returns the public key of the sender\n   */\n\n\n  getSenderPublicKey() {\n    if (!this.isSigned()) {\n      const msg = this._errorMsg('Cannot call this method if transaction is not signed');\n\n      throw new Error(msg);\n    }\n\n    const msgHash = this.getMessageToVerifySignature();\n    const {\n      v,\n      r,\n      s\n    } = this;\n\n    this._validateHighS();\n\n    try {\n      return (0, util_1.ecrecover)(msgHash, v + BigInt(27), // Recover the 27 which was stripped from ecsign\n      (0, util_1.bigIntToUnpaddedBuffer)(r), (0, util_1.bigIntToUnpaddedBuffer)(s));\n    } catch (e) {\n      const msg = this._errorMsg('Invalid Signature');\n\n      throw new Error(msg);\n    }\n  }\n\n  toJSON() {\n    const accessListJSON = util_2.AccessLists.getAccessListJSON(this.accessList);\n    return {\n      chainId: (0, util_1.bigIntToHex)(this.chainId),\n      nonce: (0, util_1.bigIntToHex)(this.nonce),\n      maxPriorityFeePerGas: (0, util_1.bigIntToHex)(this.maxPriorityFeePerGas),\n      maxFeePerGas: (0, util_1.bigIntToHex)(this.maxFeePerGas),\n      gasLimit: (0, util_1.bigIntToHex)(this.gasLimit),\n      to: this.to !== undefined ? this.to.toString() : undefined,\n      value: (0, util_1.bigIntToHex)(this.value),\n      data: '0x' + this.data.toString('hex'),\n      accessList: accessListJSON,\n      v: this.v !== undefined ? (0, util_1.bigIntToHex)(this.v) : undefined,\n      r: this.r !== undefined ? (0, util_1.bigIntToHex)(this.r) : undefined,\n      s: this.s !== undefined ? (0, util_1.bigIntToHex)(this.s) : undefined,\n      maxFeePerDataGas: (0, util_1.bigIntToHex)(this.maxFeePerDataGas),\n      versionedHashes: this.versionedHashes.map(hash => (0, util_1.bufferToHex)(hash))\n    };\n  }\n\n  _processSignature(v, r, s) {\n    const opts = { ...this.txOptions,\n      common: this.common\n    };\n    return BlobEIP4844Transaction.fromTxData({\n      chainId: this.chainId,\n      nonce: this.nonce,\n      maxPriorityFeePerGas: this.maxPriorityFeePerGas,\n      maxFeePerGas: this.maxFeePerGas,\n      gasLimit: this.gasLimit,\n      to: this.to,\n      value: this.value,\n      data: this.data,\n      accessList: this.accessList,\n      v: v - BigInt(27),\n      r: (0, util_1.bufferToBigInt)(r),\n      s: (0, util_1.bufferToBigInt)(s),\n      maxFeePerDataGas: this.maxFeePerDataGas,\n      versionedHashes: this.versionedHashes,\n      blobs: this.blobs,\n      kzgCommitments: this.kzgCommitments,\n      kzgProof: this.aggregateKzgProof\n    }, opts);\n  }\n  /**\n   * Return a compact error string representation of the object\n   */\n\n\n  errorStr() {\n    let errorStr = this._getSharedErrorPostfix();\n\n    errorStr += ` maxFeePerGas=${this.maxFeePerGas} maxPriorityFeePerGas=${this.maxPriorityFeePerGas}`;\n    return errorStr;\n  }\n  /**\n   * Internal helper function to create an annotated error message\n   *\n   * @param msg Base error message\n   * @hidden\n   */\n\n\n  _errorMsg(msg) {\n    return `${msg} (${this.errorStr()})`;\n  }\n  /**\n   * @returns the number of blobs included with this transaction\n   */\n\n\n  numBlobs() {\n    return this.versionedHashes.length;\n  }\n\n}\n\nexports.BlobEIP4844Transaction = BlobEIP4844Transaction;","map":{"version":3,"sources":["../src/eip4844Transaction.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BlobEIP4844Transaction = void 0;\nconst ssz_1 = require(\"@chainsafe/ssz\");\nconst util_1 = require(\"@ethereumjs/util\");\nconst keccak_1 = require(\"ethereum-cryptography/keccak\");\nconst baseTransaction_1 = require(\"./baseTransaction\");\nconst constants_1 = require(\"./constants\");\nconst kzg_1 = require(\"./kzg/kzg\");\nconst types_1 = require(\"./types\");\nconst util_2 = require(\"./util\");\nconst blobHelpers_1 = require(\"./utils/blobHelpers\");\nconst TRANSACTION_TYPE = 0x05;\nconst TRANSACTION_TYPE_BUFFER = Buffer.from(TRANSACTION_TYPE.toString(16).padStart(2, '0'), 'hex');\nconst validateBlobTransactionNetworkWrapper = (versionedHashes, blobs, commitments, kzgProof, version) => {\n    if (!(versionedHashes.length === blobs.length && blobs.length === commitments.length)) {\n        throw new Error('Number of versionedHashes, blobs, and commitments not all equal');\n    }\n    try {\n        kzg_1.kzg.verifyAggregateKzgProof(blobs, commitments, kzgProof);\n    }\n    catch (e) {\n        throw new Error('KZG proof cannot be verified from blobs/commitments');\n    }\n    for (let x = 0; x < versionedHashes.length; x++) {\n        const computedVersionedHash = (0, blobHelpers_1.computeVersionedHash)(commitments[x], version);\n        if (!(0, ssz_1.byteArrayEquals)(computedVersionedHash, versionedHashes[x])) {\n            throw new Error(`commitment for blob at index ${x} does not match versionedHash`);\n        }\n    }\n};\n/**\n * Typed transaction with a new gas fee market mechanism for transactions that include \"blobs\" of data\n *\n * - TransactionType: 5\n * - EIP: [EIP-4844](https://eips.ethereum.org/EIPS/eip-4844)\n */\nclass BlobEIP4844Transaction extends baseTransaction_1.BaseTransaction {\n    /**\n     * This constructor takes the values, validates them, assigns them and freezes the object.\n     *\n     * It is not recommended to use this constructor directly. Instead use\n     * the static constructors or factory methods to assist in creating a Transaction object from\n     * varying data types.\n     */\n    constructor(txData, opts = {}) {\n        super({ ...txData, type: TRANSACTION_TYPE }, opts);\n        const { chainId, accessList, maxFeePerGas, maxPriorityFeePerGas, maxFeePerDataGas } = txData;\n        this.common = this._getCommon(opts.common, chainId);\n        this.chainId = this.common.chainId();\n        if (this.common.isActivatedEIP(1559) === false) {\n            throw new Error('EIP-1559 not enabled on Common');\n        }\n        if (this.common.isActivatedEIP(4844) === false) {\n            throw new Error('EIP-4844 not enabled on Common');\n        }\n        this.activeCapabilities = this.activeCapabilities.concat([1559, 2718, 2930]);\n        // Populate the access list fields\n        const accessListData = util_2.AccessLists.getAccessListData(accessList ?? []);\n        this.accessList = accessListData.accessList;\n        this.AccessListJSON = accessListData.AccessListJSON;\n        // Verify the access list format.\n        util_2.AccessLists.verifyAccessList(this.accessList);\n        this.maxFeePerGas = (0, util_1.bufferToBigInt)((0, util_1.toBuffer)(maxFeePerGas === '' ? '0x' : maxFeePerGas));\n        this.maxPriorityFeePerGas = (0, util_1.bufferToBigInt)((0, util_1.toBuffer)(maxPriorityFeePerGas === '' ? '0x' : maxPriorityFeePerGas));\n        this._validateCannotExceedMaxInteger({\n            maxFeePerGas: this.maxFeePerGas,\n            maxPriorityFeePerGas: this.maxPriorityFeePerGas,\n        });\n        baseTransaction_1.BaseTransaction._validateNotArray(txData);\n        if (this.gasLimit * this.maxFeePerGas > util_1.MAX_INTEGER) {\n            const msg = this._errorMsg('gasLimit * maxFeePerGas cannot exceed MAX_INTEGER (2^256-1)');\n            throw new Error(msg);\n        }\n        if (this.maxFeePerGas < this.maxPriorityFeePerGas) {\n            const msg = this._errorMsg('maxFeePerGas cannot be less than maxPriorityFeePerGas (The total must be the larger of the two)');\n            throw new Error(msg);\n        }\n        this.maxFeePerDataGas = (0, util_1.bufferToBigInt)((0, util_1.toBuffer)((maxFeePerDataGas ?? '') === '' ? '0x' : maxFeePerDataGas));\n        this.versionedHashes = (txData.versionedHashes ?? []).map((vh) => (0, util_1.toBuffer)(vh));\n        this._validateYParity();\n        this._validateHighS();\n        if (this.common.isActivatedEIP(3860)) {\n            (0, util_2.checkMaxInitCodeSize)(this.common, this.data.length);\n        }\n        for (const hash of this.versionedHashes) {\n            if (hash.length !== 32) {\n                const msg = this._errorMsg('versioned hash is invalid length');\n                throw new Error(msg);\n            }\n            if (BigInt(hash[0]) !== this.common.paramByEIP('sharding', 'blobCommitmentVersionKzg', 4844)) {\n                const msg = this._errorMsg('versioned hash does not start with KZG commitment version');\n                throw new Error(msg);\n            }\n        }\n        if (this.versionedHashes.length > constants_1.LIMIT_BLOBS_PER_TX) {\n            const msg = this._errorMsg(`tx can contain at most ${constants_1.LIMIT_BLOBS_PER_TX} blobs`);\n            throw new Error(msg);\n        }\n        this.blobs = txData.blobs?.map((blob) => (0, util_1.toBuffer)(blob));\n        this.kzgCommitments = txData.kzgCommitments?.map((commitment) => (0, util_1.toBuffer)(commitment));\n        this.aggregateKzgProof = (0, util_1.toBuffer)(txData.kzgProof);\n        const freeze = opts?.freeze ?? true;\n        if (freeze) {\n            Object.freeze(this);\n        }\n    }\n    static fromTxData(txData, opts) {\n        return new BlobEIP4844Transaction(txData, opts);\n    }\n    /**\n     * Creates the minimal representation of a blob transaction from the network wrapper version.\n     * The minimal representation is used when adding transactions to an execution payload/block\n     * @param txData a {@link BlobEIP4844Transaction} containing optional blobs/kzg commitments\n     * @param opts - dictionary of {@link TxOptions}\n     * @returns the \"minimal\" representation of a BlobEIP4844Transaction (i.e. transaction object minus blobs and kzg commitments)\n     */\n    static minimalFromNetworkWrapper(txData, opts) {\n        const tx = BlobEIP4844Transaction.fromTxData({\n            ...txData,\n            ...{ blobs: undefined, kzgCommitments: undefined, kzgProof: undefined },\n        }, opts);\n        return tx;\n    }\n    /**\n     * Creates a transaction from the network encoding of a blob transaction (with blobs/commitments/proof)\n     * @param serialized a buffer representing a serialized BlobTransactionNetworkWrapper\n     * @param opts any TxOptions defined\n     * @returns a BlobEIP4844Transaction\n     * @throws if no KZG library is loaded -- using the `initKzg` helper method -- or if `opts.common` not provided\n     */\n    static fromSerializedBlobTxNetworkWrapper(serialized, opts) {\n        if (!opts || !opts.common) {\n            throw new Error('common instance required to validate versioned hashes');\n        }\n        // Validate network wrapper\n        const wrapper = types_1.BlobNetworkTransactionWrapper.deserialize(serialized.slice(1));\n        const decodedTx = wrapper.tx.message;\n        const version = Number(opts.common.paramByEIP('sharding', 'blobCommitmentVersionKzg', 4844));\n        validateBlobTransactionNetworkWrapper(decodedTx.blobVersionedHashes, wrapper.blobs, wrapper.blobKzgs, wrapper.kzgAggregatedProof, version);\n        const accessList = [];\n        for (const listItem of decodedTx.accessList) {\n            const address = Buffer.from(listItem.address);\n            const storageKeys = listItem.storageKeys.map((key) => Buffer.from(key));\n            const accessListItem = [address, storageKeys];\n            accessList.push(accessListItem);\n        }\n        const to = decodedTx.to.value === null\n            ? undefined\n            : util_1.Address.fromString((0, util_1.bufferToHex)(Buffer.from(decodedTx.to.value)));\n        const versionedHashes = decodedTx.blobVersionedHashes.map((el) => Buffer.from(el));\n        const commitments = wrapper.blobKzgs.map((el) => Buffer.from(el));\n        const blobs = wrapper.blobs.map((el) => Buffer.from(el));\n        const txData = {\n            ...decodedTx,\n            ...{\n                versionedHashes,\n                accessList,\n                to,\n                blobs,\n                kzgCommitments: commitments,\n                kzgProof: Buffer.from(wrapper.kzgAggregatedProof),\n                r: wrapper.tx.signature.r,\n                s: wrapper.tx.signature.s,\n                v: BigInt(wrapper.tx.signature.yParity),\n                gasLimit: decodedTx.gas,\n                maxFeePerGas: decodedTx.maxFeePerGas,\n                maxPriorityFeePerGas: decodedTx.maxPriorityFeePerGas,\n            },\n        };\n        return new BlobEIP4844Transaction(txData, opts);\n    }\n    /**\n     * Creates a transaction from the \"minimal\" encoding of a blob transaction (without blobs/commitments/kzg proof)\n     * @param serialized a buffer representing a serialized signed blob transaction\n     * @param opts any TxOptions defined\n     * @returns a BlobEIP4844Transaction\n     */\n    static fromSerializedTx(serialized, opts) {\n        const decoded = types_1.SignedBlobTransactionType.deserialize(serialized.slice(1));\n        const tx = decoded.message;\n        const accessList = [];\n        for (const listItem of tx.accessList) {\n            const address = Buffer.from(listItem.address);\n            const storageKeys = listItem.storageKeys.map((key) => Buffer.from(key));\n            const accessListItem = [address, storageKeys];\n            accessList.push(accessListItem);\n        }\n        const to = tx.to.value === null ? undefined : util_1.Address.fromString((0, util_1.bufferToHex)(Buffer.from(tx.to.value)));\n        const versionedHashes = tx.blobVersionedHashes.map((el) => Buffer.from(el));\n        const txData = {\n            ...tx,\n            ...{\n                versionedHashes,\n                to,\n                accessList,\n                r: decoded.signature.r,\n                s: decoded.signature.s,\n                v: BigInt(decoded.signature.yParity),\n                gasLimit: decoded.message.gas,\n            },\n        };\n        return new BlobEIP4844Transaction(txData, opts);\n    }\n    /**\n     * The up front amount that an account must have for this transaction to be valid\n     * @param baseFee The base fee of the block (will be set to 0 if not provided)\n     */\n    getUpfrontCost(baseFee = BigInt(0)) {\n        const prio = this.maxPriorityFeePerGas;\n        const maxBase = this.maxFeePerGas - baseFee;\n        const inclusionFeePerGas = prio < maxBase ? prio : maxBase;\n        const gasPrice = inclusionFeePerGas + baseFee;\n        return this.gasLimit * gasPrice + this.value;\n    }\n    /**\n     * This method is not implemented for blob transactions as the `raw` method is used exclusively with\n     * rlp encoding and these transactions use SSZ for serialization.\n     */\n    raw() {\n        throw new Error('Method not implemented.');\n    }\n    toValue() {\n        const to = {\n            selector: this.to !== undefined ? 1 : 0,\n            value: this.to?.toBuffer() ?? null,\n        };\n        return {\n            message: {\n                chainId: this.common.chainId(),\n                nonce: this.nonce,\n                maxPriorityFeePerGas: this.maxPriorityFeePerGas,\n                maxFeePerGas: this.maxFeePerGas,\n                gas: this.gasLimit,\n                to,\n                value: this.value,\n                data: this.data,\n                accessList: this.accessList.map((listItem) => {\n                    return { address: listItem[0], storageKeys: listItem[1] };\n                }),\n                blobVersionedHashes: this.versionedHashes,\n                maxFeePerDataGas: this.maxFeePerDataGas,\n            },\n            // TODO: Decide how to serialize an unsigned transaction\n            signature: {\n                r: this.r ?? BigInt(0),\n                s: this.s ?? BigInt(0),\n                yParity: this.v === BigInt(1) ? true : false,\n            },\n        };\n    }\n    /**\n     * Serialize a blob transaction to the execution payload variant\n     * @returns the minimum (execution payload) serialization of a signed transaction\n     */\n    serialize() {\n        const sszEncodedTx = types_1.SignedBlobTransactionType.serialize(this.toValue());\n        return Buffer.concat([TRANSACTION_TYPE_BUFFER, sszEncodedTx]);\n    }\n    /**\n     * @returns the serialized form of a blob transaction in the network wrapper format (used for gossipping mempool transactions over devp2p)\n     */\n    serializeNetworkWrapper() {\n        if (this.blobs === undefined ||\n            this.kzgCommitments === undefined ||\n            this.aggregateKzgProof === undefined) {\n            throw new Error('cannot serialize network wrapper without blobs, KZG commitments and aggregate KZG proof provided');\n        }\n        const to = {\n            selector: this.to !== undefined ? 1 : 0,\n            value: this.to?.toBuffer() ?? null,\n        };\n        const blobArrays = this.blobs?.map((blob) => Uint8Array.from(blob)) ?? [];\n        const serializedTxWrapper = types_1.BlobNetworkTransactionWrapper.serialize({\n            blobs: blobArrays,\n            blobKzgs: this.kzgCommitments?.map((commitment) => Uint8Array.from(commitment)) ?? [],\n            tx: { ...(0, util_2.blobTxToNetworkWrapperDataFormat)(this), ...to },\n            kzgAggregatedProof: Uint8Array.from(this.aggregateKzgProof ?? []),\n        });\n        return Buffer.concat([Buffer.from([0x05]), serializedTxWrapper]);\n    }\n    getMessageToSign(_hashMessage) {\n        return this.unsignedHash();\n    }\n    /**\n     * Returns the hash of a blob transaction\n     */\n    unsignedHash() {\n        const serializedTx = types_1.BlobTransactionType.serialize(this.toValue().message);\n        return Buffer.from((0, keccak_1.keccak256)(Buffer.concat([TRANSACTION_TYPE_BUFFER, serializedTx])));\n    }\n    hash() {\n        return Buffer.from((0, keccak_1.keccak256)(this.serialize()));\n    }\n    getMessageToVerifySignature() {\n        return this.getMessageToSign();\n    }\n    /**\n     * Returns the public key of the sender\n     */\n    getSenderPublicKey() {\n        if (!this.isSigned()) {\n            const msg = this._errorMsg('Cannot call this method if transaction is not signed');\n            throw new Error(msg);\n        }\n        const msgHash = this.getMessageToVerifySignature();\n        const { v, r, s } = this;\n        this._validateHighS();\n        try {\n            return (0, util_1.ecrecover)(msgHash, v + BigInt(27), // Recover the 27 which was stripped from ecsign\n            (0, util_1.bigIntToUnpaddedBuffer)(r), (0, util_1.bigIntToUnpaddedBuffer)(s));\n        }\n        catch (e) {\n            const msg = this._errorMsg('Invalid Signature');\n            throw new Error(msg);\n        }\n    }\n    toJSON() {\n        const accessListJSON = util_2.AccessLists.getAccessListJSON(this.accessList);\n        return {\n            chainId: (0, util_1.bigIntToHex)(this.chainId),\n            nonce: (0, util_1.bigIntToHex)(this.nonce),\n            maxPriorityFeePerGas: (0, util_1.bigIntToHex)(this.maxPriorityFeePerGas),\n            maxFeePerGas: (0, util_1.bigIntToHex)(this.maxFeePerGas),\n            gasLimit: (0, util_1.bigIntToHex)(this.gasLimit),\n            to: this.to !== undefined ? this.to.toString() : undefined,\n            value: (0, util_1.bigIntToHex)(this.value),\n            data: '0x' + this.data.toString('hex'),\n            accessList: accessListJSON,\n            v: this.v !== undefined ? (0, util_1.bigIntToHex)(this.v) : undefined,\n            r: this.r !== undefined ? (0, util_1.bigIntToHex)(this.r) : undefined,\n            s: this.s !== undefined ? (0, util_1.bigIntToHex)(this.s) : undefined,\n            maxFeePerDataGas: (0, util_1.bigIntToHex)(this.maxFeePerDataGas),\n            versionedHashes: this.versionedHashes.map((hash) => (0, util_1.bufferToHex)(hash)),\n        };\n    }\n    _processSignature(v, r, s) {\n        const opts = { ...this.txOptions, common: this.common };\n        return BlobEIP4844Transaction.fromTxData({\n            chainId: this.chainId,\n            nonce: this.nonce,\n            maxPriorityFeePerGas: this.maxPriorityFeePerGas,\n            maxFeePerGas: this.maxFeePerGas,\n            gasLimit: this.gasLimit,\n            to: this.to,\n            value: this.value,\n            data: this.data,\n            accessList: this.accessList,\n            v: v - BigInt(27),\n            r: (0, util_1.bufferToBigInt)(r),\n            s: (0, util_1.bufferToBigInt)(s),\n            maxFeePerDataGas: this.maxFeePerDataGas,\n            versionedHashes: this.versionedHashes,\n            blobs: this.blobs,\n            kzgCommitments: this.kzgCommitments,\n            kzgProof: this.aggregateKzgProof,\n        }, opts);\n    }\n    /**\n     * Return a compact error string representation of the object\n     */\n    errorStr() {\n        let errorStr = this._getSharedErrorPostfix();\n        errorStr += ` maxFeePerGas=${this.maxFeePerGas} maxPriorityFeePerGas=${this.maxPriorityFeePerGas}`;\n        return errorStr;\n    }\n    /**\n     * Internal helper function to create an annotated error message\n     *\n     * @param msg Base error message\n     * @hidden\n     */\n    _errorMsg(msg) {\n        return `${msg} (${this.errorStr()})`;\n    }\n    /**\n     * @returns the number of blobs included with this transaction\n     */\n    numBlobs() {\n        return this.versionedHashes.length;\n    }\n}\nexports.BlobEIP4844Transaction = BlobEIP4844Transaction;\n//# sourceMappingURL=eip4844Transaction.js.map"]},"metadata":{},"sourceType":"script"}