{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ByteArrayType = void 0;\n\nconst persistent_merkle_tree_1 = require(\"@chainsafe/persistent-merkle-tree\");\n\nconst byteArray_1 = require(\"../util/byteArray\");\n\nconst merkleize_1 = require(\"../util/merkleize\");\n\nconst composite_1 = require(\"./composite\");\n/* eslint-disable @typescript-eslint/member-ordering */\n\n/**\n * ByteArray: ordered array collection of byte values\n * - Value: `Uint8Array`\n * - View: `Uint8Array`\n * - ViewDU: `Uint8Array`\n *\n * ByteArray is an immutable value which is represented by a Uint8Array for memory efficiency and performance.\n * Note: Consumers of this type MUST never mutate the `Uint8Array` representation of a ByteArray.\n */\n\n\nclass ByteArrayType extends composite_1.CompositeType {\n  constructor() {\n    super(...arguments);\n    this.isViewMutable = false;\n  }\n\n  defaultValue() {\n    // Since it's a byte array the minSize is bytes is the default size\n    return new Uint8Array(this.minSize);\n  }\n\n  getView(tree) {\n    return this.getViewDU(tree.rootNode);\n  }\n\n  getViewDU(node) {\n    return this.tree_toValue(node);\n  }\n\n  commitView(view) {\n    return this.commitViewDU(view);\n  }\n\n  commitViewDU(view) {\n    const uint8Array = new Uint8Array(this.value_serializedSize(view));\n    const dataView = new DataView(uint8Array.buffer, uint8Array.byteOffset, uint8Array.byteLength);\n    this.value_serializeToBytes({\n      uint8Array,\n      dataView\n    }, 0, view);\n    return this.tree_deserializeFromBytes({\n      uint8Array,\n      dataView\n    }, 0, uint8Array.length);\n  }\n\n  cacheOfViewDU() {\n    return;\n  } // Over-write to prevent serialize + deserialize\n\n\n  toView(value) {\n    return value;\n  }\n\n  toViewDU(value) {\n    return value;\n  } // Serialization + deserialization (only value is generic)\n\n\n  value_serializeToBytes(output, offset, value) {\n    output.uint8Array.set(value, offset);\n    return offset + value.length;\n  }\n\n  value_deserializeFromBytes(data, start, end) {\n    this.assertValidSize(end - start);\n    return Uint8Array.prototype.slice.call(data.uint8Array, start, end);\n  } // Merkleization\n\n\n  getRoots(value) {\n    return merkleize_1.splitIntoRootChunks(value);\n  } // Proofs\n\n\n  getPropertyGindex() {\n    // Stop navigating below this type. Must only request complete data\n    return null;\n  }\n\n  getPropertyType() {\n    throw Error(\"Must only request ByteArray complete data\");\n  }\n\n  getIndexProperty() {\n    throw Error(\"Must only request ByteArray complete data\");\n  }\n\n  tree_fromProofNode(node) {\n    return {\n      node,\n      done: true\n    };\n  }\n\n  tree_getLeafGindices(rootGindex, rootNode) {\n    const byteLen = this.tree_getByteLen(rootNode);\n    const chunkCount = Math.ceil(byteLen / 32);\n    const startIndex = persistent_merkle_tree_1.concatGindices([rootGindex, persistent_merkle_tree_1.toGindex(this.depth, BigInt(0))]);\n    const gindices = new Array(chunkCount);\n\n    for (let i = 0, gindex = startIndex; i < chunkCount; i++, gindex++) {\n      gindices[i] = gindex;\n    } // include the length chunk\n\n\n    if (this.isList) {\n      gindices.push(persistent_merkle_tree_1.concatGindices([rootGindex, composite_1.LENGTH_GINDEX]));\n    }\n\n    return gindices;\n  } // JSON\n\n\n  fromJson(json) {\n    const value = byteArray_1.fromHexString(json);\n    this.assertValidSize(value.length);\n    return value;\n  }\n\n  toJson(value) {\n    return byteArray_1.toHexString(value);\n  } // ByteArray is immutable\n\n\n  clone(value) {\n    return value;\n  }\n\n  equals(a, b) {\n    return byteArray_1.byteArrayEquals(a, b);\n  }\n\n}\n\nexports.ByteArrayType = ByteArrayType;","map":{"version":3,"sources":["../../src/type/byteArray.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ByteArrayType = void 0;\nconst persistent_merkle_tree_1 = require(\"@chainsafe/persistent-merkle-tree\");\nconst byteArray_1 = require(\"../util/byteArray\");\nconst merkleize_1 = require(\"../util/merkleize\");\nconst composite_1 = require(\"./composite\");\n/* eslint-disable @typescript-eslint/member-ordering */\n/**\n * ByteArray: ordered array collection of byte values\n * - Value: `Uint8Array`\n * - View: `Uint8Array`\n * - ViewDU: `Uint8Array`\n *\n * ByteArray is an immutable value which is represented by a Uint8Array for memory efficiency and performance.\n * Note: Consumers of this type MUST never mutate the `Uint8Array` representation of a ByteArray.\n */\nclass ByteArrayType extends composite_1.CompositeType {\n    constructor() {\n        super(...arguments);\n        this.isViewMutable = false;\n    }\n    defaultValue() {\n        // Since it's a byte array the minSize is bytes is the default size\n        return new Uint8Array(this.minSize);\n    }\n    getView(tree) {\n        return this.getViewDU(tree.rootNode);\n    }\n    getViewDU(node) {\n        return this.tree_toValue(node);\n    }\n    commitView(view) {\n        return this.commitViewDU(view);\n    }\n    commitViewDU(view) {\n        const uint8Array = new Uint8Array(this.value_serializedSize(view));\n        const dataView = new DataView(uint8Array.buffer, uint8Array.byteOffset, uint8Array.byteLength);\n        this.value_serializeToBytes({ uint8Array, dataView }, 0, view);\n        return this.tree_deserializeFromBytes({ uint8Array, dataView }, 0, uint8Array.length);\n    }\n    cacheOfViewDU() {\n        return;\n    }\n    // Over-write to prevent serialize + deserialize\n    toView(value) {\n        return value;\n    }\n    toViewDU(value) {\n        return value;\n    }\n    // Serialization + deserialization (only value is generic)\n    value_serializeToBytes(output, offset, value) {\n        output.uint8Array.set(value, offset);\n        return offset + value.length;\n    }\n    value_deserializeFromBytes(data, start, end) {\n        this.assertValidSize(end - start);\n        return Uint8Array.prototype.slice.call(data.uint8Array, start, end);\n    }\n    // Merkleization\n    getRoots(value) {\n        return merkleize_1.splitIntoRootChunks(value);\n    }\n    // Proofs\n    getPropertyGindex() {\n        // Stop navigating below this type. Must only request complete data\n        return null;\n    }\n    getPropertyType() {\n        throw Error(\"Must only request ByteArray complete data\");\n    }\n    getIndexProperty() {\n        throw Error(\"Must only request ByteArray complete data\");\n    }\n    tree_fromProofNode(node) {\n        return { node, done: true };\n    }\n    tree_getLeafGindices(rootGindex, rootNode) {\n        const byteLen = this.tree_getByteLen(rootNode);\n        const chunkCount = Math.ceil(byteLen / 32);\n        const startIndex = persistent_merkle_tree_1.concatGindices([rootGindex, persistent_merkle_tree_1.toGindex(this.depth, BigInt(0))]);\n        const gindices = new Array(chunkCount);\n        for (let i = 0, gindex = startIndex; i < chunkCount; i++, gindex++) {\n            gindices[i] = gindex;\n        }\n        // include the length chunk\n        if (this.isList) {\n            gindices.push(persistent_merkle_tree_1.concatGindices([rootGindex, composite_1.LENGTH_GINDEX]));\n        }\n        return gindices;\n    }\n    // JSON\n    fromJson(json) {\n        const value = byteArray_1.fromHexString(json);\n        this.assertValidSize(value.length);\n        return value;\n    }\n    toJson(value) {\n        return byteArray_1.toHexString(value);\n    }\n    // ByteArray is immutable\n    clone(value) {\n        return value;\n    }\n    equals(a, b) {\n        return byteArray_1.byteArrayEquals(a, b);\n    }\n}\nexports.ByteArrayType = ByteArrayType;\n//# sourceMappingURL=byteArray.js.map"]},"metadata":{},"sourceType":"script"}