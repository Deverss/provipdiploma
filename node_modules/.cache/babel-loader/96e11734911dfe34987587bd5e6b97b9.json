{"ast":null,"code":"import { BaseAdapter, getChainConfig, CHAIN_NAMESPACES, ADAPTER_STATUS, WalletLoginError, getSavedToken, checkIfTokenIsExpired, signChallenge, verifySignedChallenge, saveToken, clearToken, ADAPTER_EVENTS } from '@web3auth/base';\n\nclass BaseEvmAdapter extends BaseAdapter {\n  async init(_) {\n    if (!this.chainConfig) this.chainConfig = getChainConfig(CHAIN_NAMESPACES.EIP155, 1);\n  }\n\n  async authenticateUser() {\n    if (!this.provider || this.status !== ADAPTER_STATUS.CONNECTED) throw WalletLoginError.notConnectedError();\n    const {\n      chainNamespace,\n      chainId\n    } = this.chainConfig;\n    const accounts = await this.provider.request({\n      method: \"eth_accounts\"\n    });\n\n    if (accounts && accounts.length > 0) {\n      const existingToken = getSavedToken(accounts[0], this.name);\n\n      if (existingToken) {\n        const isExpired = checkIfTokenIsExpired(existingToken);\n\n        if (!isExpired) {\n          return {\n            idToken: existingToken\n          };\n        }\n      }\n\n      const payload = {\n        domain: window.location.origin,\n        uri: window.location.href,\n        address: accounts[0],\n        chainId: parseInt(chainId, 16),\n        version: \"1\",\n        nonce: Math.random().toString(36).slice(2),\n        issuedAt: new Date().toISOString()\n      };\n      const challenge = await signChallenge(payload, chainNamespace);\n      const signedMessage = await this.provider.request({\n        method: \"personal_sign\",\n        params: [challenge, accounts[0]]\n      });\n      const idToken = await verifySignedChallenge(chainNamespace, signedMessage, challenge, this.name, this.sessionTime, this.clientId, this.web3AuthNetwork);\n      saveToken(accounts[0], this.name, idToken);\n      return {\n        idToken\n      };\n    }\n\n    throw WalletLoginError.notConnectedError(\"Not connected with wallet, Please login/connect first\");\n  }\n\n  async disconnectSession() {\n    super.checkDisconnectionRequirements();\n    const accounts = await this.provider.request({\n      method: \"eth_accounts\"\n    });\n\n    if (accounts && accounts.length > 0) {\n      clearToken(accounts[0], this.name);\n    }\n  }\n\n  async disconnect() {\n    this.rehydrated = false;\n    this.emit(ADAPTER_EVENTS.DISCONNECTED);\n  }\n\n}\n\nexport { BaseEvmAdapter };","map":{"version":3,"sources":["../src/baseEvmAdapter.ts"],"names":["BaseEvmAdapter","BaseAdapter","init","_","chainConfig","getChainConfig","CHAIN_NAMESPACES","EIP155","authenticateUser","provider","status","ADAPTER_STATUS","CONNECTED","WalletLoginError","notConnectedError","chainNamespace","chainId","accounts","request","method","length","existingToken","getSavedToken","name","isExpired","checkIfTokenIsExpired","idToken","payload","domain","window","location","origin","uri","href","address","parseInt","version","nonce","Math","random","toString","slice","issuedAt","Date","toISOString","challenge","signChallenge","signedMessage","params","verifySignedChallenge","sessionTime","clientId","web3AuthNetwork","saveToken","disconnectSession","checkDisconnectionRequirements","clearToken","disconnect","rehydrated","emit","ADAPTER_EVENTS","DISCONNECTED"],"mappings":"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","sourcesContent":["import { BaseAdapter, getChainConfig, CHAIN_NAMESPACES, ADAPTER_STATUS, WalletLoginError, getSavedToken, checkIfTokenIsExpired, signChallenge, verifySignedChallenge, saveToken, clearToken, ADAPTER_EVENTS } from '@web3auth/base';\n\nclass BaseEvmAdapter extends BaseAdapter {\n  async init(_) {\n    if (!this.chainConfig) this.chainConfig = getChainConfig(CHAIN_NAMESPACES.EIP155, 1);\n  }\n  async authenticateUser() {\n    if (!this.provider || this.status !== ADAPTER_STATUS.CONNECTED) throw WalletLoginError.notConnectedError();\n    const {\n      chainNamespace,\n      chainId\n    } = this.chainConfig;\n    const accounts = await this.provider.request({\n      method: \"eth_accounts\"\n    });\n    if (accounts && accounts.length > 0) {\n      const existingToken = getSavedToken(accounts[0], this.name);\n      if (existingToken) {\n        const isExpired = checkIfTokenIsExpired(existingToken);\n        if (!isExpired) {\n          return {\n            idToken: existingToken\n          };\n        }\n      }\n      const payload = {\n        domain: window.location.origin,\n        uri: window.location.href,\n        address: accounts[0],\n        chainId: parseInt(chainId, 16),\n        version: \"1\",\n        nonce: Math.random().toString(36).slice(2),\n        issuedAt: new Date().toISOString()\n      };\n      const challenge = await signChallenge(payload, chainNamespace);\n      const signedMessage = await this.provider.request({\n        method: \"personal_sign\",\n        params: [challenge, accounts[0]]\n      });\n      const idToken = await verifySignedChallenge(chainNamespace, signedMessage, challenge, this.name, this.sessionTime, this.clientId, this.web3AuthNetwork);\n      saveToken(accounts[0], this.name, idToken);\n      return {\n        idToken\n      };\n    }\n    throw WalletLoginError.notConnectedError(\"Not connected with wallet, Please login/connect first\");\n  }\n  async disconnectSession() {\n    super.checkDisconnectionRequirements();\n    const accounts = await this.provider.request({\n      method: \"eth_accounts\"\n    });\n    if (accounts && accounts.length > 0) {\n      clearToken(accounts[0], this.name);\n    }\n  }\n  async disconnect() {\n    this.rehydrated = false;\n    this.emit(ADAPTER_EVENTS.DISCONNECTED);\n  }\n}\n\nexport { BaseEvmAdapter };\n//# sourceMappingURL=baseEvmAdapter.esm.js.map\n"]},"metadata":{},"sourceType":"module"}