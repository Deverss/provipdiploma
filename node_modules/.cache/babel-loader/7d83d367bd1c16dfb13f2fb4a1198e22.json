{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.assertValidArrayLength = exports.value_defaultValueArray = exports.value_equals = exports.value_cloneArray = exports.value_toJsonArray = exports.value_fromJsonArray = exports.tree_deserializeFromBytesArrayBasic = exports.tree_serializeToBytesArrayBasic = exports.value_deserializeFromBytesArrayBasic = exports.value_serializeToBytesArrayBasic = exports.setChunksNode = exports.addLengthNode = exports.getChunksNodeFromRootNode = exports.getLengthFromRootNode = void 0;\n\nconst persistent_merkle_tree_1 = require(\"@chainsafe/persistent-merkle-tree\"); // There's a matrix of Array-ish types that require a combination of this functions.\n// Regular class extends syntax doesn't work because it can only extend a single class.\n//\n// Type of array: List, Vector. Changes length property\n// Type of element: Basic, Composite. Changes merkelization if packing or not.\n// If Composite: Fixed len, Variable len. Changes the serialization requiring offsets.\n\n/**\n * SSZ Lists (variable-length arrays) include the length of the list in the tree\n * This length is always in the same index in the tree\n * ```\n *   1\n *  / \\\n * 2   3 // <-here\n * ```\n */\n\n\nfunction getLengthFromRootNode(node) {\n  // Length is represented as a Uint32 at the start of the chunk:\n  // 4 = 4 bytes in Uint32\n  // 0 = 0 offset bytes in Node's data\n  return node.right.getUint(4, 0);\n}\n\nexports.getLengthFromRootNode = getLengthFromRootNode;\n\nfunction getChunksNodeFromRootNode(node) {\n  return node.left;\n}\n\nexports.getChunksNodeFromRootNode = getChunksNodeFromRootNode;\n\nfunction addLengthNode(chunksNode, length) {\n  return new persistent_merkle_tree_1.BranchNode(chunksNode, persistent_merkle_tree_1.LeafNode.fromUint32(length));\n}\n\nexports.addLengthNode = addLengthNode;\n\nfunction setChunksNode(rootNode, chunksNode, newLength) {\n  const lengthNode = newLength !== undefined ? // If newLength is set, create a new node for length\n  persistent_merkle_tree_1.LeafNode.fromUint32(newLength) : // else re-use existing node\n  rootNode.right;\n  return new persistent_merkle_tree_1.BranchNode(chunksNode, lengthNode);\n}\n\nexports.setChunksNode = setChunksNode;\n/**\n * @param length In List length = value.length, Vector length = fixed value\n */\n\nfunction value_serializeToBytesArrayBasic(elementType, length, output, offset, value) {\n  const elSize = elementType.byteLength;\n\n  for (let i = 0; i < length; i++) {\n    elementType.value_serializeToBytes(output, offset + i * elSize, value[i]);\n  }\n\n  return offset + length * elSize;\n}\n\nexports.value_serializeToBytesArrayBasic = value_serializeToBytesArrayBasic;\n\nfunction value_deserializeFromBytesArrayBasic(elementType, data, start, end, arrayProps) {\n  const elSize = elementType.byteLength; // Vector + List length validation\n\n  const length = (end - start) / elSize;\n  assertValidArrayLength(length, arrayProps, true);\n  const values = new Array(length);\n\n  for (let i = 0; i < length; i++) {\n    // TODO: If faster, consider skipping size check for uint types\n    values[i] = elementType.value_deserializeFromBytes(data, start + i * elSize, start + (i + 1) * elSize);\n  }\n\n  return values;\n}\n\nexports.value_deserializeFromBytesArrayBasic = value_deserializeFromBytesArrayBasic;\n/**\n * @param length In List length = value.length, Vector length = fixed value\n */\n\nfunction tree_serializeToBytesArrayBasic(elementType, length, depth, output, offset, node) {\n  const size = elementType.byteLength * length;\n  const chunkCount = Math.ceil(size / 32);\n  const nodes = persistent_merkle_tree_1.getNodesAtDepth(node, depth, 0, chunkCount);\n  persistent_merkle_tree_1.packedNodeRootsToBytes(output.dataView, offset, size, nodes);\n  return offset + size;\n}\n\nexports.tree_serializeToBytesArrayBasic = tree_serializeToBytesArrayBasic; // List of basic elements will pack them in merkelized form\n\nfunction tree_deserializeFromBytesArrayBasic(elementType, chunkDepth, data, start, end, arrayProps) {\n  // Vector + List length validation\n  const length = (end - start) / elementType.byteLength;\n  assertValidArrayLength(length, arrayProps, true); // Abstract converting data to LeafNode to allow for custom data representation, such as the hashObject\n\n  const chunksNode = persistent_merkle_tree_1.packedRootsBytesToNode(chunkDepth, data.dataView, start, end);\n\n  if (arrayProps.isList) {\n    return addLengthNode(chunksNode, length);\n  } else {\n    return chunksNode;\n  }\n}\n\nexports.tree_deserializeFromBytesArrayBasic = tree_deserializeFromBytesArrayBasic;\n/**\n * @param length In List length = undefined, Vector length = fixed value\n */\n\nfunction value_fromJsonArray(elementType, json, arrayProps) {\n  if (!Array.isArray(json)) {\n    throw Error(\"JSON is not an array\");\n  }\n\n  assertValidArrayLength(json.length, arrayProps);\n  const value = new Array(json.length);\n\n  for (let i = 0; i < json.length; i++) {\n    value[i] = elementType.fromJson(json[i]);\n  }\n\n  return value;\n}\n\nexports.value_fromJsonArray = value_fromJsonArray;\n/**\n * @param length In List length = undefined, Vector length = fixed value\n */\n\nfunction value_toJsonArray(elementType, value, arrayProps) {\n  const length = arrayProps.isList ? value.length : arrayProps.length;\n  const json = new Array(length);\n\n  for (let i = 0; i < length; i++) {\n    json[i] = elementType.toJson(value[i]);\n  }\n\n  return json;\n}\n\nexports.value_toJsonArray = value_toJsonArray;\n/**\n * Clone recursively an array of basic or composite types\n */\n\nfunction value_cloneArray(elementType, value) {\n  const newValue = new Array(value.length);\n\n  for (let i = 0; i < value.length; i++) {\n    newValue[i] = elementType.clone(value[i]);\n  }\n\n  return newValue;\n}\n\nexports.value_cloneArray = value_cloneArray;\n/**\n * Check recursively if a type is structuraly equal. Returns early\n */\n\nfunction value_equals(elementType, a, b) {\n  if (a.length !== b.length) {\n    return false;\n  }\n\n  for (let i = 0; i < a.length; i++) {\n    if (!elementType.equals(a[i], b[i])) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nexports.value_equals = value_equals;\n\nfunction value_defaultValueArray(elementType, length) {\n  const values = new Array(length);\n\n  for (let i = 0; i < length; i++) {\n    values[i] = elementType.defaultValue();\n  }\n\n  return values;\n}\n\nexports.value_defaultValueArray = value_defaultValueArray;\n/**\n * @param checkNonDecimalLength Check that length is a multiple of element size.\n * Optional since it's not necessary in getOffsetsArrayComposite() fn.\n */\n\nfunction assertValidArrayLength(length, arrayProps, checkNonDecimalLength) {\n  if (checkNonDecimalLength && length % 1 !== 0) {\n    throw Error(\"size not multiple of element fixedSize\");\n  } // Vector + List length validation\n\n\n  if (arrayProps.isList) {\n    if (length > arrayProps.limit) {\n      throw new Error(`Invalid list length ${length} over limit ${arrayProps.limit}`);\n    }\n  } else {\n    if (length !== arrayProps.length) {\n      throw new Error(`Incorrect vector length ${length} expected ${arrayProps.length}`);\n    }\n  }\n}\n\nexports.assertValidArrayLength = assertValidArrayLength;","map":{"version":3,"sources":["../../src/type/arrayBasic.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.assertValidArrayLength = exports.value_defaultValueArray = exports.value_equals = exports.value_cloneArray = exports.value_toJsonArray = exports.value_fromJsonArray = exports.tree_deserializeFromBytesArrayBasic = exports.tree_serializeToBytesArrayBasic = exports.value_deserializeFromBytesArrayBasic = exports.value_serializeToBytesArrayBasic = exports.setChunksNode = exports.addLengthNode = exports.getChunksNodeFromRootNode = exports.getLengthFromRootNode = void 0;\nconst persistent_merkle_tree_1 = require(\"@chainsafe/persistent-merkle-tree\");\n// There's a matrix of Array-ish types that require a combination of this functions.\n// Regular class extends syntax doesn't work because it can only extend a single class.\n//\n// Type of array: List, Vector. Changes length property\n// Type of element: Basic, Composite. Changes merkelization if packing or not.\n// If Composite: Fixed len, Variable len. Changes the serialization requiring offsets.\n/**\n * SSZ Lists (variable-length arrays) include the length of the list in the tree\n * This length is always in the same index in the tree\n * ```\n *   1\n *  / \\\n * 2   3 // <-here\n * ```\n */\nfunction getLengthFromRootNode(node) {\n    // Length is represented as a Uint32 at the start of the chunk:\n    // 4 = 4 bytes in Uint32\n    // 0 = 0 offset bytes in Node's data\n    return node.right.getUint(4, 0);\n}\nexports.getLengthFromRootNode = getLengthFromRootNode;\nfunction getChunksNodeFromRootNode(node) {\n    return node.left;\n}\nexports.getChunksNodeFromRootNode = getChunksNodeFromRootNode;\nfunction addLengthNode(chunksNode, length) {\n    return new persistent_merkle_tree_1.BranchNode(chunksNode, persistent_merkle_tree_1.LeafNode.fromUint32(length));\n}\nexports.addLengthNode = addLengthNode;\nfunction setChunksNode(rootNode, chunksNode, newLength) {\n    const lengthNode = newLength !== undefined\n        ? // If newLength is set, create a new node for length\n            persistent_merkle_tree_1.LeafNode.fromUint32(newLength)\n        : // else re-use existing node\n            rootNode.right;\n    return new persistent_merkle_tree_1.BranchNode(chunksNode, lengthNode);\n}\nexports.setChunksNode = setChunksNode;\n/**\n * @param length In List length = value.length, Vector length = fixed value\n */\nfunction value_serializeToBytesArrayBasic(elementType, length, output, offset, value) {\n    const elSize = elementType.byteLength;\n    for (let i = 0; i < length; i++) {\n        elementType.value_serializeToBytes(output, offset + i * elSize, value[i]);\n    }\n    return offset + length * elSize;\n}\nexports.value_serializeToBytesArrayBasic = value_serializeToBytesArrayBasic;\nfunction value_deserializeFromBytesArrayBasic(elementType, data, start, end, arrayProps) {\n    const elSize = elementType.byteLength;\n    // Vector + List length validation\n    const length = (end - start) / elSize;\n    assertValidArrayLength(length, arrayProps, true);\n    const values = new Array(length);\n    for (let i = 0; i < length; i++) {\n        // TODO: If faster, consider skipping size check for uint types\n        values[i] = elementType.value_deserializeFromBytes(data, start + i * elSize, start + (i + 1) * elSize);\n    }\n    return values;\n}\nexports.value_deserializeFromBytesArrayBasic = value_deserializeFromBytesArrayBasic;\n/**\n * @param length In List length = value.length, Vector length = fixed value\n */\nfunction tree_serializeToBytesArrayBasic(elementType, length, depth, output, offset, node) {\n    const size = elementType.byteLength * length;\n    const chunkCount = Math.ceil(size / 32);\n    const nodes = persistent_merkle_tree_1.getNodesAtDepth(node, depth, 0, chunkCount);\n    persistent_merkle_tree_1.packedNodeRootsToBytes(output.dataView, offset, size, nodes);\n    return offset + size;\n}\nexports.tree_serializeToBytesArrayBasic = tree_serializeToBytesArrayBasic;\n// List of basic elements will pack them in merkelized form\nfunction tree_deserializeFromBytesArrayBasic(elementType, chunkDepth, data, start, end, arrayProps) {\n    // Vector + List length validation\n    const length = (end - start) / elementType.byteLength;\n    assertValidArrayLength(length, arrayProps, true);\n    // Abstract converting data to LeafNode to allow for custom data representation, such as the hashObject\n    const chunksNode = persistent_merkle_tree_1.packedRootsBytesToNode(chunkDepth, data.dataView, start, end);\n    if (arrayProps.isList) {\n        return addLengthNode(chunksNode, length);\n    }\n    else {\n        return chunksNode;\n    }\n}\nexports.tree_deserializeFromBytesArrayBasic = tree_deserializeFromBytesArrayBasic;\n/**\n * @param length In List length = undefined, Vector length = fixed value\n */\nfunction value_fromJsonArray(elementType, json, arrayProps) {\n    if (!Array.isArray(json)) {\n        throw Error(\"JSON is not an array\");\n    }\n    assertValidArrayLength(json.length, arrayProps);\n    const value = new Array(json.length);\n    for (let i = 0; i < json.length; i++) {\n        value[i] = elementType.fromJson(json[i]);\n    }\n    return value;\n}\nexports.value_fromJsonArray = value_fromJsonArray;\n/**\n * @param length In List length = undefined, Vector length = fixed value\n */\nfunction value_toJsonArray(elementType, value, arrayProps) {\n    const length = arrayProps.isList ? value.length : arrayProps.length;\n    const json = new Array(length);\n    for (let i = 0; i < length; i++) {\n        json[i] = elementType.toJson(value[i]);\n    }\n    return json;\n}\nexports.value_toJsonArray = value_toJsonArray;\n/**\n * Clone recursively an array of basic or composite types\n */\nfunction value_cloneArray(elementType, value) {\n    const newValue = new Array(value.length);\n    for (let i = 0; i < value.length; i++) {\n        newValue[i] = elementType.clone(value[i]);\n    }\n    return newValue;\n}\nexports.value_cloneArray = value_cloneArray;\n/**\n * Check recursively if a type is structuraly equal. Returns early\n */\nfunction value_equals(elementType, a, b) {\n    if (a.length !== b.length) {\n        return false;\n    }\n    for (let i = 0; i < a.length; i++) {\n        if (!elementType.equals(a[i], b[i])) {\n            return false;\n        }\n    }\n    return true;\n}\nexports.value_equals = value_equals;\nfunction value_defaultValueArray(elementType, length) {\n    const values = new Array(length);\n    for (let i = 0; i < length; i++) {\n        values[i] = elementType.defaultValue();\n    }\n    return values;\n}\nexports.value_defaultValueArray = value_defaultValueArray;\n/**\n * @param checkNonDecimalLength Check that length is a multiple of element size.\n * Optional since it's not necessary in getOffsetsArrayComposite() fn.\n */\nfunction assertValidArrayLength(length, arrayProps, checkNonDecimalLength) {\n    if (checkNonDecimalLength && length % 1 !== 0) {\n        throw Error(\"size not multiple of element fixedSize\");\n    }\n    // Vector + List length validation\n    if (arrayProps.isList) {\n        if (length > arrayProps.limit) {\n            throw new Error(`Invalid list length ${length} over limit ${arrayProps.limit}`);\n        }\n    }\n    else {\n        if (length !== arrayProps.length) {\n            throw new Error(`Incorrect vector length ${length} expected ${arrayProps.length}`);\n        }\n    }\n}\nexports.assertValidArrayLength = assertValidArrayLength;\n//# sourceMappingURL=arrayBasic.js.map"]},"metadata":{},"sourceType":"script"}