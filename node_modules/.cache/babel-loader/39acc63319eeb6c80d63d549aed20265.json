{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createNodeFromMultiProof = exports.createMultiProof = void 0;\n\nconst node_1 = require(\"../node\");\n\nconst tree_1 = require(\"../tree\");\n\nconst util_1 = require(\"./util\");\n/**\n * Create an multiproof\n *\n * See https://github.com/ethereum/consensus-specs/blob/dev/ssz/merkle-proofs.md#merkle-multiproofs\n *\n * @param rootNode the root node of the tree\n * @param gindices generalized indices of leaves to include in the proof\n */\n\n\nfunction createMultiProof(rootNode, gindices) {\n  const tree = new tree_1.Tree(rootNode);\n  const witnessGindices = util_1.computeMultiProofBitstrings(gindices.map(gindex => gindex.toString(2)), false, util_1.SortOrder.Decreasing);\n  const leafGindices = gindices.slice().sort((a, b) => a < b ? 1 : -1);\n  const leaves = leafGindices.map(gindex => tree.getRoot(gindex));\n  const witnesses = witnessGindices.map(gindex => tree.getRoot(gindex));\n  return [leaves, witnesses, leafGindices];\n}\n\nexports.createMultiProof = createMultiProof;\n/**\n * Recreate a `Node` given a multiproof\n *\n * See https://github.com/ethereum/consensus-specs/blob/dev/ssz/merkle-proofs.md#merkle-multiproofs\n *\n * @param leaves leaves of a EF multiproof\n * @param witnesses witnesses of a EF multiproof\n * @param gindices generalized indices of the leaves\n */\n\nfunction createNodeFromMultiProof(leaves, witnesses, gindices) {\n  var _leafBitstrings$, _witnessBitstrings$;\n\n  if (leaves.length !== gindices.length) {\n    throw new Error(\"Leaves length should equal gindices length\");\n  }\n\n  const leafBitstrings = gindices.map(gindex => gindex.toString(2));\n  const witnessBitstrings = util_1.computeMultiProofBitstrings(leafBitstrings, false, util_1.SortOrder.Decreasing);\n\n  if (witnessBitstrings.length !== witnesses.length) {\n    throw new Error(\"Witnesses length should equal witnesses gindices length\");\n  } // Algorithm:\n  // create an object which tracks key-values for each level\n  // pre-load leaves and witnesses into the level object\n  // level by level, starting from the bottom,\n  // find the sibling, create the parent, store it in the next level up\n  // the root is in level 1\n\n\n  const maxLevel = Math.max(((_leafBitstrings$ = leafBitstrings[0]) === null || _leafBitstrings$ === void 0 ? void 0 : _leafBitstrings$.length) ?? 0, ((_witnessBitstrings$ = witnessBitstrings[0]) === null || _witnessBitstrings$ === void 0 ? void 0 : _witnessBitstrings$.length) ?? 0);\n  const levels = Object.fromEntries(Array.from({\n    length: maxLevel\n  }, (_, i) => [i + 1, {}])); // preload leaves and witnesses\n\n  for (let i = 0; i < leafBitstrings.length; i++) {\n    const leafBitstring = leafBitstrings[i];\n    const leaf = leaves[i];\n    levels[leafBitstring.length][leafBitstring] = node_1.LeafNode.fromRoot(leaf);\n  }\n\n  for (let i = 0; i < witnessBitstrings.length; i++) {\n    const witnessBitstring = witnessBitstrings[i];\n    const witness = witnesses[i];\n    levels[witnessBitstring.length][witnessBitstring] = node_1.LeafNode.fromRoot(witness);\n  }\n\n  for (let i = maxLevel; i > 1; i--) {\n    const level = levels[i];\n    const parentLevel = levels[i - 1];\n\n    for (const bitstring of Object.keys(level)) {\n      const node = level[bitstring]; // if the node doesn't exist, we've already processed its sibling\n\n      if (!node) {\n        continue;\n      }\n\n      const isLeft = bitstring[bitstring.length - 1] === \"0\";\n      const parentBitstring = bitstring.substring(0, bitstring.length - 1);\n      const siblingBitstring = parentBitstring + (isLeft ? \"1\" : \"0\");\n      const siblingNode = level[siblingBitstring];\n\n      if (!siblingNode) {\n        throw new Error(`Sibling not found: ${siblingBitstring}`);\n      } // store the parent node\n\n\n      const parentNode = isLeft ? new node_1.BranchNode(node, siblingNode) : new node_1.BranchNode(siblingNode, node);\n      parentLevel[parentBitstring] = parentNode; // delete the used nodes\n\n      delete level[bitstring];\n      delete level[siblingBitstring];\n    }\n  }\n\n  const root = levels[1][\"1\"];\n\n  if (!root) {\n    throw new Error(\"Internal consistency error: no root found\");\n  }\n\n  return root;\n}\n\nexports.createNodeFromMultiProof = createNodeFromMultiProof;","map":{"version":3,"sources":["/Users/dev3rs/provipdiploma/node_modules/@chainsafe/persistent-merkle-tree/lib/proof/multi.js"],"names":["Object","defineProperty","exports","value","createNodeFromMultiProof","createMultiProof","node_1","require","tree_1","util_1","rootNode","gindices","tree","Tree","witnessGindices","computeMultiProofBitstrings","map","gindex","toString","SortOrder","Decreasing","leafGindices","slice","sort","a","b","leaves","getRoot","witnesses","length","Error","leafBitstrings","witnessBitstrings","maxLevel","Math","max","levels","fromEntries","Array","from","_","i","leafBitstring","leaf","LeafNode","fromRoot","witnessBitstring","witness","level","parentLevel","bitstring","keys","node","isLeft","parentBitstring","substring","siblingBitstring","siblingNode","parentNode","BranchNode","root"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.createNodeFromMultiProof = exports.createMultiProof = void 0;\nconst node_1 = require(\"../node\");\nconst tree_1 = require(\"../tree\");\nconst util_1 = require(\"./util\");\n/**\n * Create an multiproof\n *\n * See https://github.com/ethereum/consensus-specs/blob/dev/ssz/merkle-proofs.md#merkle-multiproofs\n *\n * @param rootNode the root node of the tree\n * @param gindices generalized indices of leaves to include in the proof\n */\nfunction createMultiProof(rootNode, gindices) {\n    const tree = new tree_1.Tree(rootNode);\n    const witnessGindices = util_1.computeMultiProofBitstrings(gindices.map((gindex) => gindex.toString(2)), false, util_1.SortOrder.Decreasing);\n    const leafGindices = gindices.slice().sort((a, b) => (a < b ? 1 : -1));\n    const leaves = leafGindices.map((gindex) => tree.getRoot(gindex));\n    const witnesses = witnessGindices.map((gindex) => tree.getRoot(gindex));\n    return [leaves, witnesses, leafGindices];\n}\nexports.createMultiProof = createMultiProof;\n/**\n * Recreate a `Node` given a multiproof\n *\n * See https://github.com/ethereum/consensus-specs/blob/dev/ssz/merkle-proofs.md#merkle-multiproofs\n *\n * @param leaves leaves of a EF multiproof\n * @param witnesses witnesses of a EF multiproof\n * @param gindices generalized indices of the leaves\n */\nfunction createNodeFromMultiProof(leaves, witnesses, gindices) {\n    if (leaves.length !== gindices.length) {\n        throw new Error(\"Leaves length should equal gindices length\");\n    }\n    const leafBitstrings = gindices.map((gindex) => gindex.toString(2));\n    const witnessBitstrings = util_1.computeMultiProofBitstrings(leafBitstrings, false, util_1.SortOrder.Decreasing);\n    if (witnessBitstrings.length !== witnesses.length) {\n        throw new Error(\"Witnesses length should equal witnesses gindices length\");\n    }\n    // Algorithm:\n    // create an object which tracks key-values for each level\n    // pre-load leaves and witnesses into the level object\n    // level by level, starting from the bottom,\n    // find the sibling, create the parent, store it in the next level up\n    // the root is in level 1\n    const maxLevel = Math.max(leafBitstrings[0]?.length ?? 0, witnessBitstrings[0]?.length ?? 0);\n    const levels = Object.fromEntries(Array.from({ length: maxLevel }, (_, i) => [i + 1, {}]));\n    // preload leaves and witnesses\n    for (let i = 0; i < leafBitstrings.length; i++) {\n        const leafBitstring = leafBitstrings[i];\n        const leaf = leaves[i];\n        levels[leafBitstring.length][leafBitstring] = node_1.LeafNode.fromRoot(leaf);\n    }\n    for (let i = 0; i < witnessBitstrings.length; i++) {\n        const witnessBitstring = witnessBitstrings[i];\n        const witness = witnesses[i];\n        levels[witnessBitstring.length][witnessBitstring] = node_1.LeafNode.fromRoot(witness);\n    }\n    for (let i = maxLevel; i > 1; i--) {\n        const level = levels[i];\n        const parentLevel = levels[i - 1];\n        for (const bitstring of Object.keys(level)) {\n            const node = level[bitstring];\n            // if the node doesn't exist, we've already processed its sibling\n            if (!node) {\n                continue;\n            }\n            const isLeft = bitstring[bitstring.length - 1] === \"0\";\n            const parentBitstring = bitstring.substring(0, bitstring.length - 1);\n            const siblingBitstring = parentBitstring + (isLeft ? \"1\" : \"0\");\n            const siblingNode = level[siblingBitstring];\n            if (!siblingNode) {\n                throw new Error(`Sibling not found: ${siblingBitstring}`);\n            }\n            // store the parent node\n            const parentNode = isLeft ? new node_1.BranchNode(node, siblingNode) : new node_1.BranchNode(siblingNode, node);\n            parentLevel[parentBitstring] = parentNode;\n            // delete the used nodes\n            delete level[bitstring];\n            delete level[siblingBitstring];\n        }\n    }\n    const root = levels[1][\"1\"];\n    if (!root) {\n        throw new Error(\"Internal consistency error: no root found\");\n    }\n    return root;\n}\nexports.createNodeFromMultiProof = createNodeFromMultiProof;\n"]},"metadata":{},"sourceType":"script"}