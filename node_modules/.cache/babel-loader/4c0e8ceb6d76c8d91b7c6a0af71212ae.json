{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.deserializeProof = exports.serializeProof = exports.createNodeFromProof = exports.createProof = exports.ProofTypeSerialized = exports.ProofType = void 0;\n\nconst multi_1 = require(\"./multi\");\n\nconst single_1 = require(\"./single\");\n\nconst treeOffset_1 = require(\"./treeOffset\");\n\nvar ProofType;\n\n(function (ProofType) {\n  ProofType[\"single\"] = \"single\";\n  ProofType[\"treeOffset\"] = \"treeOffset\";\n  ProofType[\"multi\"] = \"multi\";\n})(ProofType = exports.ProofType || (exports.ProofType = {}));\n/**\n * Serialized proofs are prepended with a single byte, denoting their type\n */\n\n\nexports.ProofTypeSerialized = [ProofType.single, ProofType.treeOffset, ProofType.multi // 2\n];\n\nfunction createProof(rootNode, input) {\n  switch (input.type) {\n    case ProofType.single:\n      {\n        const [leaf, witnesses] = single_1.createSingleProof(rootNode, input.gindex);\n        return {\n          type: ProofType.single,\n          gindex: input.gindex,\n          leaf,\n          witnesses\n        };\n      }\n\n    case ProofType.treeOffset:\n      {\n        const [offsets, leaves] = treeOffset_1.createTreeOffsetProof(rootNode, input.gindices);\n        return {\n          type: ProofType.treeOffset,\n          offsets,\n          leaves\n        };\n      }\n\n    case ProofType.multi:\n      {\n        const [leaves, witnesses, gindices] = multi_1.createMultiProof(rootNode, input.gindices);\n        return {\n          type: ProofType.multi,\n          leaves,\n          witnesses,\n          gindices\n        };\n      }\n\n    default:\n      throw new Error(\"Invalid proof type\");\n  }\n}\n\nexports.createProof = createProof;\n\nfunction createNodeFromProof(proof) {\n  switch (proof.type) {\n    case ProofType.single:\n      return single_1.createNodeFromSingleProof(proof.gindex, proof.leaf, proof.witnesses);\n\n    case ProofType.treeOffset:\n      return treeOffset_1.createNodeFromTreeOffsetProof(proof.offsets, proof.leaves);\n\n    case ProofType.multi:\n      return multi_1.createNodeFromMultiProof(proof.leaves, proof.witnesses, proof.gindices);\n\n    default:\n      throw new Error(\"Invalid proof type\");\n  }\n}\n\nexports.createNodeFromProof = createNodeFromProof;\n\nfunction serializeProof(proof) {\n  switch (proof.type) {\n    case ProofType.single:\n    case ProofType.multi:\n      throw new Error(\"Not implemented\");\n\n    case ProofType.treeOffset:\n      {\n        const output = new Uint8Array(1 + treeOffset_1.computeTreeOffsetProofSerializedLength(proof.offsets, proof.leaves));\n        output[0] = exports.ProofTypeSerialized.indexOf(ProofType.treeOffset);\n        treeOffset_1.serializeTreeOffsetProof(output, 1, proof.offsets, proof.leaves);\n        return output;\n      }\n\n    default:\n      throw new Error(\"Invalid proof type\");\n  }\n}\n\nexports.serializeProof = serializeProof;\n\nfunction deserializeProof(data) {\n  const proofType = exports.ProofTypeSerialized[data[0]];\n\n  if (!proofType) {\n    throw new Error(\"Invalid proof type\");\n  }\n\n  switch (proofType) {\n    case ProofType.single:\n    case ProofType.multi:\n      throw new Error(\"Not implemented\");\n\n    case ProofType.treeOffset:\n      {\n        const [offsets, leaves] = treeOffset_1.deserializeTreeOffsetProof(data, 1);\n        return {\n          type: ProofType.treeOffset,\n          offsets,\n          leaves\n        };\n      }\n\n    default:\n      throw new Error(\"Invalid proof type\");\n  }\n}\n\nexports.deserializeProof = deserializeProof;","map":{"version":3,"sources":["/Users/dev3rs/provipdiploma/node_modules/@chainsafe/persistent-merkle-tree/lib/proof/index.js"],"names":["Object","defineProperty","exports","value","deserializeProof","serializeProof","createNodeFromProof","createProof","ProofTypeSerialized","ProofType","multi_1","require","single_1","treeOffset_1","single","treeOffset","multi","rootNode","input","type","leaf","witnesses","createSingleProof","gindex","offsets","leaves","createTreeOffsetProof","gindices","createMultiProof","Error","proof","createNodeFromSingleProof","createNodeFromTreeOffsetProof","createNodeFromMultiProof","output","Uint8Array","computeTreeOffsetProofSerializedLength","indexOf","serializeTreeOffsetProof","data","proofType","deserializeTreeOffsetProof"],"mappings":"AAAA;;AACAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;AACAD,OAAO,CAACE,gBAAR,GAA2BF,OAAO,CAACG,cAAR,GAAyBH,OAAO,CAACI,mBAAR,GAA8BJ,OAAO,CAACK,WAAR,GAAsBL,OAAO,CAACM,mBAAR,GAA8BN,OAAO,CAACO,SAAR,GAAoB,KAAK,CAA/J;;AACA,MAAMC,OAAO,GAAGC,OAAO,CAAC,SAAD,CAAvB;;AACA,MAAMC,QAAQ,GAAGD,OAAO,CAAC,UAAD,CAAxB;;AACA,MAAME,YAAY,GAAGF,OAAO,CAAC,cAAD,CAA5B;;AACA,IAAIF,SAAJ;;AACA,CAAC,UAAUA,SAAV,EAAqB;AAClBA,EAAAA,SAAS,CAAC,QAAD,CAAT,GAAsB,QAAtB;AACAA,EAAAA,SAAS,CAAC,YAAD,CAAT,GAA0B,YAA1B;AACAA,EAAAA,SAAS,CAAC,OAAD,CAAT,GAAqB,OAArB;AACH,CAJD,EAIGA,SAAS,GAAGP,OAAO,CAACO,SAAR,KAAsBP,OAAO,CAACO,SAAR,GAAoB,EAA1C,CAJf;AAKA;AACA;AACA;;;AACAP,OAAO,CAACM,mBAAR,GAA8B,CAC1BC,SAAS,CAACK,MADgB,EAE1BL,SAAS,CAACM,UAFgB,EAG1BN,SAAS,CAACO,KAHgB,CAGT;AAHS,CAA9B;;AAKA,SAAST,WAAT,CAAqBU,QAArB,EAA+BC,KAA/B,EAAsC;AAClC,UAAQA,KAAK,CAACC,IAAd;AACI,SAAKV,SAAS,CAACK,MAAf;AAAuB;AACnB,cAAM,CAACM,IAAD,EAAOC,SAAP,IAAoBT,QAAQ,CAACU,iBAAT,CAA2BL,QAA3B,EAAqCC,KAAK,CAACK,MAA3C,CAA1B;AACA,eAAO;AACHJ,UAAAA,IAAI,EAAEV,SAAS,CAACK,MADb;AAEHS,UAAAA,MAAM,EAAEL,KAAK,CAACK,MAFX;AAGHH,UAAAA,IAHG;AAIHC,UAAAA;AAJG,SAAP;AAMH;;AACD,SAAKZ,SAAS,CAACM,UAAf;AAA2B;AACvB,cAAM,CAACS,OAAD,EAAUC,MAAV,IAAoBZ,YAAY,CAACa,qBAAb,CAAmCT,QAAnC,EAA6CC,KAAK,CAACS,QAAnD,CAA1B;AACA,eAAO;AACHR,UAAAA,IAAI,EAAEV,SAAS,CAACM,UADb;AAEHS,UAAAA,OAFG;AAGHC,UAAAA;AAHG,SAAP;AAKH;;AACD,SAAKhB,SAAS,CAACO,KAAf;AAAsB;AAClB,cAAM,CAACS,MAAD,EAASJ,SAAT,EAAoBM,QAApB,IAAgCjB,OAAO,CAACkB,gBAAR,CAAyBX,QAAzB,EAAmCC,KAAK,CAACS,QAAzC,CAAtC;AACA,eAAO;AACHR,UAAAA,IAAI,EAAEV,SAAS,CAACO,KADb;AAEHS,UAAAA,MAFG;AAGHJ,UAAAA,SAHG;AAIHM,UAAAA;AAJG,SAAP;AAMH;;AACD;AACI,YAAM,IAAIE,KAAJ,CAAU,oBAAV,CAAN;AA5BR;AA8BH;;AACD3B,OAAO,CAACK,WAAR,GAAsBA,WAAtB;;AACA,SAASD,mBAAT,CAA6BwB,KAA7B,EAAoC;AAChC,UAAQA,KAAK,CAACX,IAAd;AACI,SAAKV,SAAS,CAACK,MAAf;AACI,aAAOF,QAAQ,CAACmB,yBAAT,CAAmCD,KAAK,CAACP,MAAzC,EAAiDO,KAAK,CAACV,IAAvD,EAA6DU,KAAK,CAACT,SAAnE,CAAP;;AACJ,SAAKZ,SAAS,CAACM,UAAf;AACI,aAAOF,YAAY,CAACmB,6BAAb,CAA2CF,KAAK,CAACN,OAAjD,EAA0DM,KAAK,CAACL,MAAhE,CAAP;;AACJ,SAAKhB,SAAS,CAACO,KAAf;AACI,aAAON,OAAO,CAACuB,wBAAR,CAAiCH,KAAK,CAACL,MAAvC,EAA+CK,KAAK,CAACT,SAArD,EAAgES,KAAK,CAACH,QAAtE,CAAP;;AACJ;AACI,YAAM,IAAIE,KAAJ,CAAU,oBAAV,CAAN;AARR;AAUH;;AACD3B,OAAO,CAACI,mBAAR,GAA8BA,mBAA9B;;AACA,SAASD,cAAT,CAAwByB,KAAxB,EAA+B;AAC3B,UAAQA,KAAK,CAACX,IAAd;AACI,SAAKV,SAAS,CAACK,MAAf;AACA,SAAKL,SAAS,CAACO,KAAf;AACI,YAAM,IAAIa,KAAJ,CAAU,iBAAV,CAAN;;AACJ,SAAKpB,SAAS,CAACM,UAAf;AAA2B;AACvB,cAAMmB,MAAM,GAAG,IAAIC,UAAJ,CAAe,IAAItB,YAAY,CAACuB,sCAAb,CAAoDN,KAAK,CAACN,OAA1D,EAAmEM,KAAK,CAACL,MAAzE,CAAnB,CAAf;AACAS,QAAAA,MAAM,CAAC,CAAD,CAAN,GAAYhC,OAAO,CAACM,mBAAR,CAA4B6B,OAA5B,CAAoC5B,SAAS,CAACM,UAA9C,CAAZ;AACAF,QAAAA,YAAY,CAACyB,wBAAb,CAAsCJ,MAAtC,EAA8C,CAA9C,EAAiDJ,KAAK,CAACN,OAAvD,EAAgEM,KAAK,CAACL,MAAtE;AACA,eAAOS,MAAP;AACH;;AACD;AACI,YAAM,IAAIL,KAAJ,CAAU,oBAAV,CAAN;AAXR;AAaH;;AACD3B,OAAO,CAACG,cAAR,GAAyBA,cAAzB;;AACA,SAASD,gBAAT,CAA0BmC,IAA1B,EAAgC;AAC5B,QAAMC,SAAS,GAAGtC,OAAO,CAACM,mBAAR,CAA4B+B,IAAI,CAAC,CAAD,CAAhC,CAAlB;;AACA,MAAI,CAACC,SAAL,EAAgB;AACZ,UAAM,IAAIX,KAAJ,CAAU,oBAAV,CAAN;AACH;;AACD,UAAQW,SAAR;AACI,SAAK/B,SAAS,CAACK,MAAf;AACA,SAAKL,SAAS,CAACO,KAAf;AACI,YAAM,IAAIa,KAAJ,CAAU,iBAAV,CAAN;;AACJ,SAAKpB,SAAS,CAACM,UAAf;AAA2B;AACvB,cAAM,CAACS,OAAD,EAAUC,MAAV,IAAoBZ,YAAY,CAAC4B,0BAAb,CAAwCF,IAAxC,EAA8C,CAA9C,CAA1B;AACA,eAAO;AACHpB,UAAAA,IAAI,EAAEV,SAAS,CAACM,UADb;AAEHS,UAAAA,OAFG;AAGHC,UAAAA;AAHG,SAAP;AAKH;;AACD;AACI,YAAM,IAAII,KAAJ,CAAU,oBAAV,CAAN;AAbR;AAeH;;AACD3B,OAAO,CAACE,gBAAR,GAA2BA,gBAA3B","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.deserializeProof = exports.serializeProof = exports.createNodeFromProof = exports.createProof = exports.ProofTypeSerialized = exports.ProofType = void 0;\nconst multi_1 = require(\"./multi\");\nconst single_1 = require(\"./single\");\nconst treeOffset_1 = require(\"./treeOffset\");\nvar ProofType;\n(function (ProofType) {\n    ProofType[\"single\"] = \"single\";\n    ProofType[\"treeOffset\"] = \"treeOffset\";\n    ProofType[\"multi\"] = \"multi\";\n})(ProofType = exports.ProofType || (exports.ProofType = {}));\n/**\n * Serialized proofs are prepended with a single byte, denoting their type\n */\nexports.ProofTypeSerialized = [\n    ProofType.single,\n    ProofType.treeOffset,\n    ProofType.multi, // 2\n];\nfunction createProof(rootNode, input) {\n    switch (input.type) {\n        case ProofType.single: {\n            const [leaf, witnesses] = single_1.createSingleProof(rootNode, input.gindex);\n            return {\n                type: ProofType.single,\n                gindex: input.gindex,\n                leaf,\n                witnesses,\n            };\n        }\n        case ProofType.treeOffset: {\n            const [offsets, leaves] = treeOffset_1.createTreeOffsetProof(rootNode, input.gindices);\n            return {\n                type: ProofType.treeOffset,\n                offsets,\n                leaves,\n            };\n        }\n        case ProofType.multi: {\n            const [leaves, witnesses, gindices] = multi_1.createMultiProof(rootNode, input.gindices);\n            return {\n                type: ProofType.multi,\n                leaves,\n                witnesses,\n                gindices,\n            };\n        }\n        default:\n            throw new Error(\"Invalid proof type\");\n    }\n}\nexports.createProof = createProof;\nfunction createNodeFromProof(proof) {\n    switch (proof.type) {\n        case ProofType.single:\n            return single_1.createNodeFromSingleProof(proof.gindex, proof.leaf, proof.witnesses);\n        case ProofType.treeOffset:\n            return treeOffset_1.createNodeFromTreeOffsetProof(proof.offsets, proof.leaves);\n        case ProofType.multi:\n            return multi_1.createNodeFromMultiProof(proof.leaves, proof.witnesses, proof.gindices);\n        default:\n            throw new Error(\"Invalid proof type\");\n    }\n}\nexports.createNodeFromProof = createNodeFromProof;\nfunction serializeProof(proof) {\n    switch (proof.type) {\n        case ProofType.single:\n        case ProofType.multi:\n            throw new Error(\"Not implemented\");\n        case ProofType.treeOffset: {\n            const output = new Uint8Array(1 + treeOffset_1.computeTreeOffsetProofSerializedLength(proof.offsets, proof.leaves));\n            output[0] = exports.ProofTypeSerialized.indexOf(ProofType.treeOffset);\n            treeOffset_1.serializeTreeOffsetProof(output, 1, proof.offsets, proof.leaves);\n            return output;\n        }\n        default:\n            throw new Error(\"Invalid proof type\");\n    }\n}\nexports.serializeProof = serializeProof;\nfunction deserializeProof(data) {\n    const proofType = exports.ProofTypeSerialized[data[0]];\n    if (!proofType) {\n        throw new Error(\"Invalid proof type\");\n    }\n    switch (proofType) {\n        case ProofType.single:\n        case ProofType.multi:\n            throw new Error(\"Not implemented\");\n        case ProofType.treeOffset: {\n            const [offsets, leaves] = treeOffset_1.deserializeTreeOffsetProof(data, 1);\n            return {\n                type: ProofType.treeOffset,\n                offsets,\n                leaves,\n            };\n        }\n        default:\n            throw new Error(\"Invalid proof type\");\n    }\n}\nexports.deserializeProof = deserializeProof;\n"]},"metadata":{},"sourceType":"script"}