{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.UintBigintType = exports.UintNumberType = exports.uintBigintByteLens = exports.uintNumberByteLens = void 0;\n\nconst persistent_merkle_tree_1 = require(\"@chainsafe/persistent-merkle-tree\");\n\nconst named_1 = require(\"../util/named\");\n\nconst basic_1 = require(\"./basic\");\n/* eslint-disable @typescript-eslint/member-ordering */\n\n\nconst MAX_SAFE_INTEGER_BN = BigInt(Number.MAX_SAFE_INTEGER);\nconst BIGINT_2_POW_64 = BigInt(2) ** BigInt(64);\nconst BIGINT_2_POW_128 = BigInt(2) ** BigInt(128);\nconst BIGINT_2_POW_192 = BigInt(2) ** BigInt(192); // const BIGINT_64_MAX = BigInt(\"0xffffffffffffffff\");\n\nconst NUMBER_2_POW_32 = 2 ** 32;\nconst NUMBER_32_MAX = 0xffffffff;\nexports.uintNumberByteLens = [1, 2, 4, 8];\nexports.uintBigintByteLens = [1, 2, 4, 8, 16, 32];\n/**\n * Uint: N-bit unsigned integer (where N in [8, 16, 32, 64, 128, 256])\n * - Notation: uintN\n *\n * UintNumber is represented as the Javascript primitive value 'Number'.\n *\n * The Number type is a double-precision 64-bit binary format IEEE 754 value (numbers between -(2^53 − 1) and\n * 2^53 − 1). It also has the symbolic value: +Infinity.\n *\n * As of 2021 performance of 'Number' is extremely faster than 'BigInt'. Some values are spec'ed as Uint64 but\n * practically they will never exceed 53 bits, such as any unit time or simple counters. This type is an optimization\n * for these cases, as UintNumber64 can represent any value between 0 and 2^53−1 as well as the max value 2^64-1.\n */\n\nclass UintNumberType extends basic_1.BasicType {\n  constructor(byteLength, opts) {\n    super();\n    this.byteLength = byteLength;\n\n    if (byteLength > 8) {\n      throw Error(\"UintNumber byteLength limit is 8\");\n    }\n\n    if (Math.log2(byteLength) % 1 !== 0) {\n      throw Error(\"byteLength must be a power of 2\");\n    }\n\n    this.typeName = (opts === null || opts === void 0 ? void 0 : opts.typeName) ?? `uint${byteLength * 8}`;\n    if (opts !== null && opts !== void 0 && opts.clipInfinity) this.typeName += \"Inf\";\n    if (opts !== null && opts !== void 0 && opts.setBitwiseOR) this.typeName += \"OR\";\n    this.itemsPerChunk = 32 / this.byteLength;\n    this.fixedSize = byteLength;\n    this.minSize = byteLength;\n    this.maxSize = byteLength;\n    this.maxDecimalStr = (BigInt(2) ** BigInt(this.byteLength * 8) - BigInt(1)).toString(10);\n    this.clipInfinity = (opts === null || opts === void 0 ? void 0 : opts.clipInfinity) === true;\n    this.setBitwiseOR = (opts === null || opts === void 0 ? void 0 : opts.setBitwiseOR) === true;\n  }\n\n  static named(byteLength, opts) {\n    return new (named_1.namedClass(UintNumberType, opts.typeName))(byteLength, opts);\n  }\n\n  defaultValue() {\n    return 0;\n  } // Serialization + deserialization\n\n\n  value_serializeToBytes({\n    dataView\n  }, offset, value) {\n    switch (this.byteLength) {\n      case 1:\n        dataView.setInt8(offset, value);\n        break;\n\n      case 2:\n        dataView.setUint16(offset, value, true);\n        break;\n\n      case 4:\n        dataView.setUint32(offset, value, true);\n        break;\n\n      case 8:\n        if (value === Infinity) {\n          // TODO: Benchmark if it's faster to set BIGINT_64_MAX once\n          dataView.setUint32(offset, 0xffffffff);\n          dataView.setUint32(offset + 4, 0xffffffff);\n        } else {\n          dataView.setUint32(offset, value & 0xffffffff, true);\n          dataView.setUint32(offset + 4, value / NUMBER_2_POW_32 & 0xffffffff, true);\n        }\n\n        break;\n    }\n\n    return offset + this.byteLength;\n  }\n\n  value_deserializeFromBytes({\n    dataView\n  }, start, end) {\n    this.assertValidSize(end - start);\n\n    switch (this.byteLength) {\n      case 1:\n        return dataView.getUint8(start);\n\n      case 2:\n        return dataView.getUint16(start, true);\n\n      case 4:\n        return dataView.getUint32(start, true);\n\n      case 8:\n        {\n          const a = dataView.getUint32(start, true);\n          const b = dataView.getUint32(start + 4, true);\n\n          if (b === NUMBER_32_MAX && a === NUMBER_32_MAX && this.clipInfinity) {\n            return Infinity;\n          } else {\n            return b * NUMBER_2_POW_32 + a;\n          }\n        }\n    }\n  }\n\n  tree_serializeToBytes(output, offset, node) {\n    const value = node.getUint(this.byteLength, 0, this.clipInfinity);\n    this.value_serializeToBytes(output, offset, value);\n    return offset + this.byteLength;\n  }\n\n  tree_deserializeFromBytes(data, start, end) {\n    this.assertValidSize(end - start);\n    const value = this.value_deserializeFromBytes(data, start, end);\n    const node = persistent_merkle_tree_1.LeafNode.fromZero();\n    node.setUint(this.byteLength, 0, value, this.clipInfinity);\n    return node;\n  } // Fast Tree access\n\n\n  tree_getFromNode(leafNode) {\n    return leafNode.getUint(this.byteLength, 0, this.clipInfinity);\n  }\n\n  tree_setToNode(leafNode, value) {\n    this.tree_setToPackedNode(leafNode, 0, value);\n  }\n\n  tree_getFromPackedNode(leafNode, index) {\n    const offsetBytes = this.byteLength * (index % this.itemsPerChunk);\n    return leafNode.getUint(this.byteLength, offsetBytes, this.clipInfinity);\n  }\n\n  tree_setToPackedNode(leafNode, index, value) {\n    const offsetBytes = this.byteLength * (index % this.itemsPerChunk); // TODO: Benchmark the cost of this if, and consider using a different class\n\n    if (this.setBitwiseOR) {\n      leafNode.bitwiseOrUint(this.byteLength, offsetBytes, value);\n    } else {\n      leafNode.setUint(this.byteLength, offsetBytes, value, this.clipInfinity);\n    }\n  } // JSON\n\n\n  fromJson(json) {\n    if (typeof json === \"number\") {\n      return json;\n    } else if (typeof json === \"string\") {\n      if (this.clipInfinity && json === this.maxDecimalStr) {\n        // Allow to handle max possible number\n        return Infinity;\n      } else {\n        const num = parseInt(json, 10);\n\n        if (isNaN(num)) {\n          throw Error(\"JSON invalid number isNaN\");\n        } else if (num > Number.MAX_SAFE_INTEGER) {\n          // Throw to prevent decimal precision errors downstream\n          throw Error(\"JSON invalid number > MAX_SAFE_INTEGER\");\n        } else {\n          return num;\n        }\n      }\n    } else if (typeof json === \"bigint\") {\n      if (json > MAX_SAFE_INTEGER_BN) {\n        // Throw to prevent decimal precision errors downstream\n        throw Error(\"JSON invalid number > MAX_SAFE_INTEGER_BN\");\n      } else {\n        return Number(json);\n      }\n    } else {\n      throw Error(`JSON invalid type ${typeof json} expected number`);\n    }\n  }\n\n  toJson(value) {\n    if (value === Infinity) {\n      return this.maxDecimalStr;\n    } else {\n      return value.toString(10);\n    }\n  }\n\n}\n\nexports.UintNumberType = UintNumberType;\n/**\n * Uint: N-bit unsigned integer (where N in [8, 16, 32, 64, 128, 256])\n * - Notation: uintN\n *\n * UintBigint is represented as the Javascript primitive value 'BigInt'.\n *\n * The BigInt type is a numeric primitive in JavaScript that can represent integers with arbitrary precision.\n * With BigInts, you can safely store and operate on large integers even beyond the safe integer limit for Numbers.\n *\n * As of 2021 performance of 'Number' is extremely faster than 'BigInt'. For Uint values under 53 bits use UintNumber.\n * For other values that may exceed 53 bits, use UintBigint.\n */\n\nclass UintBigintType extends basic_1.BasicType {\n  constructor(byteLength, opts) {\n    super();\n    this.byteLength = byteLength;\n\n    if (byteLength > 32) {\n      throw Error(\"UintBigint byteLength limit is 32\");\n    }\n\n    if (Math.log2(byteLength) % 1 !== 0) {\n      throw Error(\"byteLength must be a power of 2\");\n    }\n\n    this.typeName = (opts === null || opts === void 0 ? void 0 : opts.typeName) ?? `uintBigint${byteLength * 8}`;\n    this.byteLength = byteLength;\n    this.itemsPerChunk = 32 / this.byteLength;\n    this.fixedSize = byteLength;\n    this.minSize = byteLength;\n    this.maxSize = byteLength;\n  }\n\n  static named(byteLength, opts) {\n    return new (named_1.namedClass(UintBigintType, opts.typeName))(byteLength, opts);\n  }\n\n  defaultValue() {\n    return BigInt(0);\n  } // Serialization + deserialization\n\n\n  value_serializeToBytes({\n    dataView\n  }, offset, value) {\n    switch (this.byteLength) {\n      case 1:\n        dataView.setInt8(offset, Number(value));\n        break;\n\n      case 2:\n        dataView.setUint16(offset, Number(value), true);\n        break;\n\n      case 4:\n        dataView.setUint32(offset, Number(value), true);\n        break;\n\n      case 8:\n        dataView.setBigUint64(offset, value, true);\n        break;\n\n      default:\n        {\n          for (let i = 0; i < this.byteLength; i += 8) {\n            if (i > 0) value = value / BIGINT_2_POW_64;\n            const lo = BigInt.asUintN(64, value);\n            dataView.setBigUint64(offset + i, lo, true);\n          }\n        }\n    }\n\n    return offset + this.byteLength;\n  }\n\n  value_deserializeFromBytes({\n    dataView\n  }, start, end) {\n    const size = end - start;\n\n    if (size !== this.byteLength) {\n      throw Error(`Invalid size ${size} expected ${this.byteLength}`);\n    } // Note: pre-assigning the right function at the constructor to avoid this switch is not faster\n\n\n    switch (this.byteLength) {\n      case 1:\n        return BigInt(dataView.getUint8(start));\n\n      case 2:\n        return BigInt(dataView.getUint16(start, true));\n\n      case 4:\n        return BigInt(dataView.getUint32(start, true));\n\n      case 8:\n        return dataView.getBigUint64(start, true);\n\n      case 16:\n        {\n          const a = dataView.getBigUint64(start, true);\n          const b = dataView.getBigUint64(start + 8, true);\n          return b * BIGINT_2_POW_64 + a;\n        }\n\n      case 32:\n        {\n          const a = dataView.getBigUint64(start, true);\n          const b = dataView.getBigUint64(start + 8, true);\n          const c = dataView.getBigUint64(start + 16, true);\n          const d = dataView.getBigUint64(start + 24, true);\n          return d * BIGINT_2_POW_192 + c * BIGINT_2_POW_128 + b * BIGINT_2_POW_64 + a;\n        }\n    }\n  }\n\n  tree_serializeToBytes(output, offset, node) {\n    const value = node.getUintBigint(this.byteLength, 0);\n    this.value_serializeToBytes(output, offset, value);\n    return offset + this.byteLength;\n  }\n\n  tree_deserializeFromBytes(data, start, end) {\n    const size = end - start;\n\n    if (size !== this.byteLength) {\n      throw Error(`Invalid size ${size} expected ${this.byteLength}`);\n    }\n\n    const value = this.value_deserializeFromBytes(data, start, end);\n    const node = persistent_merkle_tree_1.LeafNode.fromZero();\n    node.setUintBigint(this.byteLength, 0, value);\n    return node;\n  } // Fast Tree access\n\n\n  tree_getFromNode(leafNode) {\n    return leafNode.getUintBigint(this.byteLength, 0);\n  }\n  /** Mutates node to set value */\n\n\n  tree_setToNode(leafNode, value) {\n    this.tree_setToPackedNode(leafNode, 0, value);\n  }\n  /** EXAMPLE of `tree_getFromNode` */\n\n\n  tree_getFromPackedNode(leafNode, index) {\n    const offsetBytes = this.byteLength * (index % this.itemsPerChunk);\n    return leafNode.getUintBigint(this.byteLength, offsetBytes);\n  }\n  /** Mutates node to set value */\n\n\n  tree_setToPackedNode(leafNode, index, value) {\n    const offsetBytes = this.byteLength * (index % this.itemsPerChunk); // TODO: Not-optimized, copy pasted from UintNumberType\n\n    leafNode.setUintBigint(this.byteLength, offsetBytes, value);\n  } // JSON\n\n\n  fromJson(json) {\n    if (typeof json === \"bigint\") {\n      return json;\n    } else if (typeof json === \"string\" || typeof json === \"number\") {\n      return BigInt(json);\n    } else {\n      throw Error(`JSON invalid type ${typeof json} expected bigint`);\n    }\n  }\n\n  toJson(value) {\n    return value.toString(10);\n  }\n\n}\n\nexports.UintBigintType = UintBigintType;","map":{"version":3,"sources":["../../src/type/uint.ts"],"names":[],"mappings":";;;;;;;AAAA,MAAA,wBAAA,GAAA,OAAA,CAAA,mCAAA,CAAA;;AACA,MAAA,OAAA,GAAA,OAAA,CAAA,eAAA,CAAA;;AAGA,MAAA,OAAA,GAAA,OAAA,CAAA,SAAA,CAAA;AAEA;;;AAEA,MAAM,mBAAmB,GAAG,MAAM,CAAC,MAAM,CAAC,gBAAR,CAAlC;AACA,MAAM,eAAe,GAAG,MAAM,CAAC,CAAD,CAAN,IAAa,MAAM,CAAC,EAAD,CAA3C;AACA,MAAM,gBAAgB,GAAG,MAAM,CAAC,CAAD,CAAN,IAAa,MAAM,CAAC,GAAD,CAA5C;AACA,MAAM,gBAAgB,GAAG,MAAM,CAAC,CAAD,CAAN,IAAa,MAAM,CAAC,GAAD,CAA5C,C,CACA;;AACA,MAAM,eAAe,GAAG,KAAK,EAA7B;AACA,MAAM,aAAa,GAAG,UAAtB;AAYa,OAAA,CAAA,kBAAA,GAA0C,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,EAAU,CAAV,CAA1C;AACA,OAAA,CAAA,kBAAA,GAA0C,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,EAAU,CAAV,EAAa,EAAb,EAAiB,EAAjB,CAA1C;AAEb;;;;;;;;;;;;AAYG;;AACH,MAAa,cAAb,SAAoC,OAAA,CAAA,SAApC,CAAqD;AAWnD,EAAA,WAAA,CAAqB,UAArB,EAAoD,IAApD,EAAyE;AACvE;AADmB,SAAA,UAAA,GAAA,UAAA;;AAGnB,QAAI,UAAU,GAAG,CAAjB,EAAoB;AAClB,YAAM,KAAK,CAAC,kCAAD,CAAX;AACD;;AACD,QAAI,IAAI,CAAC,IAAL,CAAU,UAAV,IAAwB,CAAxB,KAA8B,CAAlC,EAAqC;AACnC,YAAM,KAAK,CAAC,iCAAD,CAAX;AACD;;AAED,SAAK,QAAL,GAAgB,CAAA,IAAI,SAAJ,IAAA,IAAI,WAAJ,YAAA,IAAI,CAAE,QAAN,KAAkB,OAAO,UAAU,GAAG,CAAC,EAAvD;AACA,QAAI,IAAJ,aAAI,IAAJ,eAAI,IAAI,CAAE,YAAV,EAAwB,KAAK,QAAL,IAAiB,KAAjB;AACxB,QAAI,IAAJ,aAAI,IAAJ,eAAI,IAAI,CAAE,YAAV,EAAwB,KAAK,QAAL,IAAiB,IAAjB;AAExB,SAAK,aAAL,GAAqB,KAAK,KAAK,UAA/B;AACA,SAAK,SAAL,GAAiB,UAAjB;AACA,SAAK,OAAL,GAAe,UAAf;AACA,SAAK,OAAL,GAAe,UAAf;AACA,SAAK,aAAL,GAAqB,CAAC,MAAM,CAAC,CAAD,CAAN,IAAa,MAAM,CAAC,KAAK,UAAL,GAAkB,CAAnB,CAAnB,GAA2C,MAAM,CAAC,CAAD,CAAlD,EAAuD,QAAvD,CAAgE,EAAhE,CAArB;AAEA,SAAK,YAAL,GAAoB,CAAA,IAAI,SAAJ,IAAA,IAAI,WAAJ,YAAA,IAAI,CAAE,YAAN,MAAuB,IAA3C;AACA,SAAK,YAAL,GAAoB,CAAA,IAAI,SAAJ,IAAA,IAAI,WAAJ,YAAA,IAAI,CAAE,YAAN,MAAuB,IAA3C;AACD;;AAEW,SAAL,KAAK,CAAC,UAAD,EAAgC,IAAhC,EAAyE;AACnF,WAAO,KAAK,OAAA,CAAA,UAAA,CAAW,cAAX,EAA2B,IAAI,CAAC,QAAhC,CAAL,EAAgD,UAAhD,EAA4D,IAA5D,CAAP;AACD;;AAED,EAAA,YAAY,GAAA;AACV,WAAO,CAAP;AACD,GAzCkD,CA2CnD;;;AAEA,EAAA,sBAAsB,CAAC;AAAC,IAAA;AAAD,GAAD,EAAwB,MAAxB,EAAwC,KAAxC,EAAqD;AACzE,YAAQ,KAAK,UAAb;AACE,WAAK,CAAL;AACE,QAAA,QAAQ,CAAC,OAAT,CAAiB,MAAjB,EAAyB,KAAzB;AACA;;AACF,WAAK,CAAL;AACE,QAAA,QAAQ,CAAC,SAAT,CAAmB,MAAnB,EAA2B,KAA3B,EAAkC,IAAlC;AACA;;AACF,WAAK,CAAL;AACE,QAAA,QAAQ,CAAC,SAAT,CAAmB,MAAnB,EAA2B,KAA3B,EAAkC,IAAlC;AACA;;AACF,WAAK,CAAL;AACE,YAAI,KAAK,KAAK,QAAd,EAAwB;AACtB;AACA,UAAA,QAAQ,CAAC,SAAT,CAAmB,MAAnB,EAA2B,UAA3B;AACA,UAAA,QAAQ,CAAC,SAAT,CAAmB,MAAM,GAAG,CAA5B,EAA+B,UAA/B;AACD,SAJD,MAIO;AACL,UAAA,QAAQ,CAAC,SAAT,CAAmB,MAAnB,EAA2B,KAAK,GAAG,UAAnC,EAA+C,IAA/C;AACA,UAAA,QAAQ,CAAC,SAAT,CAAmB,MAAM,GAAG,CAA5B,EAAgC,KAAK,GAAG,eAAT,GAA4B,UAA3D,EAAuE,IAAvE;AACD;;AACD;AAnBJ;;AAsBA,WAAO,MAAM,GAAG,KAAK,UAArB;AACD;;AAED,EAAA,0BAA0B,CAAC;AAAC,IAAA;AAAD,GAAD,EAAwB,KAAxB,EAAuC,GAAvC,EAAkD;AAC1E,SAAK,eAAL,CAAqB,GAAG,GAAG,KAA3B;;AAEA,YAAQ,KAAK,UAAb;AACE,WAAK,CAAL;AACE,eAAO,QAAQ,CAAC,QAAT,CAAkB,KAAlB,CAAP;;AACF,WAAK,CAAL;AACE,eAAO,QAAQ,CAAC,SAAT,CAAmB,KAAnB,EAA0B,IAA1B,CAAP;;AACF,WAAK,CAAL;AACE,eAAO,QAAQ,CAAC,SAAT,CAAmB,KAAnB,EAA0B,IAA1B,CAAP;;AACF,WAAK,CAAL;AAAQ;AACN,gBAAM,CAAC,GAAG,QAAQ,CAAC,SAAT,CAAmB,KAAnB,EAA0B,IAA1B,CAAV;AACA,gBAAM,CAAC,GAAG,QAAQ,CAAC,SAAT,CAAmB,KAAK,GAAG,CAA3B,EAA8B,IAA9B,CAAV;;AACA,cAAI,CAAC,KAAK,aAAN,IAAuB,CAAC,KAAK,aAA7B,IAA8C,KAAK,YAAvD,EAAqE;AACnE,mBAAO,QAAP;AACD,WAFD,MAEO;AACL,mBAAO,CAAC,GAAG,eAAJ,GAAsB,CAA7B;AACD;AACF;AAfH;AAiBD;;AAED,EAAA,qBAAqB,CAAC,MAAD,EAAoB,MAApB,EAAoC,IAApC,EAA8C;AACjE,UAAM,KAAK,GAAI,IAAiB,CAAC,OAAlB,CAA0B,KAAK,UAA/B,EAA2C,CAA3C,EAA8C,KAAK,YAAnD,CAAf;AACA,SAAK,sBAAL,CAA4B,MAA5B,EAAoC,MAApC,EAA4C,KAA5C;AACA,WAAO,MAAM,GAAG,KAAK,UAArB;AACD;;AAED,EAAA,yBAAyB,CAAC,IAAD,EAAkB,KAAlB,EAAiC,GAAjC,EAA4C;AACnE,SAAK,eAAL,CAAqB,GAAG,GAAG,KAA3B;AAEA,UAAM,KAAK,GAAG,KAAK,0BAAL,CAAgC,IAAhC,EAAsC,KAAtC,EAA6C,GAA7C,CAAd;AACA,UAAM,IAAI,GAAG,wBAAA,CAAA,QAAA,CAAS,QAAT,EAAb;AACA,IAAA,IAAI,CAAC,OAAL,CAAa,KAAK,UAAlB,EAA8B,CAA9B,EAAiC,KAAjC,EAAwC,KAAK,YAA7C;AACA,WAAO,IAAP;AACD,GA1GkD,CA4GnD;;;AAEA,EAAA,gBAAgB,CAAC,QAAD,EAAmB;AACjC,WAAO,QAAQ,CAAC,OAAT,CAAiB,KAAK,UAAtB,EAAkC,CAAlC,EAAqC,KAAK,YAA1C,CAAP;AACD;;AAED,EAAA,cAAc,CAAC,QAAD,EAAqB,KAArB,EAAkC;AAC9C,SAAK,oBAAL,CAA0B,QAA1B,EAAoC,CAApC,EAAuC,KAAvC;AACD;;AAED,EAAA,sBAAsB,CAAC,QAAD,EAAqB,KAArB,EAAkC;AACtD,UAAM,WAAW,GAAG,KAAK,UAAL,IAAmB,KAAK,GAAG,KAAK,aAAhC,CAApB;AACA,WAAO,QAAQ,CAAC,OAAT,CAAiB,KAAK,UAAtB,EAAkC,WAAlC,EAA+C,KAAK,YAApD,CAAP;AACD;;AAED,EAAA,oBAAoB,CAAC,QAAD,EAAqB,KAArB,EAAoC,KAApC,EAAiD;AACnE,UAAM,WAAW,GAAG,KAAK,UAAL,IAAmB,KAAK,GAAG,KAAK,aAAhC,CAApB,CADmE,CAGnE;;AACA,QAAI,KAAK,YAAT,EAAuB;AACrB,MAAA,QAAQ,CAAC,aAAT,CAAuB,KAAK,UAA5B,EAAwC,WAAxC,EAAqD,KAArD;AACD,KAFD,MAEO;AACL,MAAA,QAAQ,CAAC,OAAT,CAAiB,KAAK,UAAtB,EAAkC,WAAlC,EAA+C,KAA/C,EAAsD,KAAK,YAA3D;AACD;AACF,GApIkD,CAsInD;;;AAEA,EAAA,QAAQ,CAAC,IAAD,EAAc;AACpB,QAAI,OAAO,IAAP,KAAgB,QAApB,EAA8B;AAC5B,aAAO,IAAP;AACD,KAFD,MAEO,IAAI,OAAO,IAAP,KAAgB,QAApB,EAA8B;AACnC,UAAI,KAAK,YAAL,IAAqB,IAAI,KAAK,KAAK,aAAvC,EAAsD;AACpD;AACA,eAAO,QAAP;AACD,OAHD,MAGO;AACL,cAAM,GAAG,GAAG,QAAQ,CAAC,IAAD,EAAO,EAAP,CAApB;;AACA,YAAI,KAAK,CAAC,GAAD,CAAT,EAAgB;AACd,gBAAM,KAAK,CAAC,2BAAD,CAAX;AACD,SAFD,MAEO,IAAI,GAAG,GAAG,MAAM,CAAC,gBAAjB,EAAmC;AACxC;AACA,gBAAM,KAAK,CAAC,wCAAD,CAAX;AACD,SAHM,MAGA;AACL,iBAAO,GAAP;AACD;AACF;AACF,KAfM,MAeA,IAAI,OAAO,IAAP,KAAgB,QAApB,EAA8B;AACnC,UAAI,IAAI,GAAG,mBAAX,EAAgC;AAC9B;AACA,cAAM,KAAK,CAAC,2CAAD,CAAX;AACD,OAHD,MAGO;AACL,eAAO,MAAM,CAAC,IAAD,CAAb;AACD;AACF,KAPM,MAOA;AACL,YAAM,KAAK,CAAC,qBAAqB,OAAO,IAAI,kBAAjC,CAAX;AACD;AACF;;AAED,EAAA,MAAM,CAAC,KAAD,EAAc;AAClB,QAAI,KAAK,KAAK,QAAd,EAAwB;AACtB,aAAO,KAAK,aAAZ;AACD,KAFD,MAEO;AACL,aAAO,KAAK,CAAC,QAAN,CAAe,EAAf,CAAP;AACD;AACF;;AA5KkD;;AAArD,OAAA,CAAA,cAAA,GAAA,cAAA;AAmLA;;;;;;;;;;;AAWG;;AACH,MAAa,cAAb,SAAoC,OAAA,CAAA,SAApC,CAAqD;AAQnD,EAAA,WAAA,CAAqB,UAArB,EAAoD,IAApD,EAAyE;AACvE;AADmB,SAAA,UAAA,GAAA,UAAA;;AAGnB,QAAI,UAAU,GAAG,EAAjB,EAAqB;AACnB,YAAM,KAAK,CAAC,mCAAD,CAAX;AACD;;AACD,QAAI,IAAI,CAAC,IAAL,CAAU,UAAV,IAAwB,CAAxB,KAA8B,CAAlC,EAAqC;AACnC,YAAM,KAAK,CAAC,iCAAD,CAAX;AACD;;AAED,SAAK,QAAL,GAAgB,CAAA,IAAI,SAAJ,IAAA,IAAI,WAAJ,YAAA,IAAI,CAAE,QAAN,KAAkB,aAAa,UAAU,GAAG,CAAC,EAA7D;AACA,SAAK,UAAL,GAAkB,UAAlB;AACA,SAAK,aAAL,GAAqB,KAAK,KAAK,UAA/B;AACA,SAAK,SAAL,GAAiB,UAAjB;AACA,SAAK,OAAL,GAAe,UAAf;AACA,SAAK,OAAL,GAAe,UAAf;AACD;;AAEW,SAAL,KAAK,CAAC,UAAD,EAAgC,IAAhC,EAAyE;AACnF,WAAO,KAAK,OAAA,CAAA,UAAA,CAAW,cAAX,EAA2B,IAAI,CAAC,QAAhC,CAAL,EAAgD,UAAhD,EAA4D,IAA5D,CAAP;AACD;;AAED,EAAA,YAAY,GAAA;AACV,WAAO,MAAM,CAAC,CAAD,CAAb;AACD,GAhCkD,CAkCnD;;;AAEA,EAAA,sBAAsB,CAAC;AAAC,IAAA;AAAD,GAAD,EAAwB,MAAxB,EAAwC,KAAxC,EAAqD;AACzE,YAAQ,KAAK,UAAb;AACE,WAAK,CAAL;AACE,QAAA,QAAQ,CAAC,OAAT,CAAiB,MAAjB,EAAyB,MAAM,CAAC,KAAD,CAA/B;AACA;;AACF,WAAK,CAAL;AACE,QAAA,QAAQ,CAAC,SAAT,CAAmB,MAAnB,EAA2B,MAAM,CAAC,KAAD,CAAjC,EAA0C,IAA1C;AACA;;AACF,WAAK,CAAL;AACE,QAAA,QAAQ,CAAC,SAAT,CAAmB,MAAnB,EAA2B,MAAM,CAAC,KAAD,CAAjC,EAA0C,IAA1C;AACA;;AACF,WAAK,CAAL;AACE,QAAA,QAAQ,CAAC,YAAT,CAAsB,MAAtB,EAA8B,KAA9B,EAAqC,IAArC;AACA;;AACF;AAAS;AACP,eAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,KAAK,UAAzB,EAAqC,CAAC,IAAI,CAA1C,EAA6C;AAC3C,gBAAI,CAAC,GAAG,CAAR,EAAW,KAAK,GAAG,KAAK,GAAG,eAAhB;AACX,kBAAM,EAAE,GAAG,MAAM,CAAC,OAAP,CAAe,EAAf,EAAmB,KAAnB,CAAX;AACA,YAAA,QAAQ,CAAC,YAAT,CAAsB,MAAM,GAAG,CAA/B,EAAkC,EAAlC,EAAsC,IAAtC;AACD;AACF;AAnBH;;AAsBA,WAAO,MAAM,GAAG,KAAK,UAArB;AACD;;AAED,EAAA,0BAA0B,CAAC;AAAC,IAAA;AAAD,GAAD,EAAwB,KAAxB,EAAuC,GAAvC,EAAkD;AAC1E,UAAM,IAAI,GAAG,GAAG,GAAG,KAAnB;;AACA,QAAI,IAAI,KAAK,KAAK,UAAlB,EAA8B;AAC5B,YAAM,KAAK,CAAC,gBAAgB,IAAI,aAAa,KAAK,UAAU,EAAjD,CAAX;AACD,KAJyE,CAM1E;;;AACA,YAAQ,KAAK,UAAb;AACE,WAAK,CAAL;AACE,eAAO,MAAM,CAAC,QAAQ,CAAC,QAAT,CAAkB,KAAlB,CAAD,CAAb;;AACF,WAAK,CAAL;AACE,eAAO,MAAM,CAAC,QAAQ,CAAC,SAAT,CAAmB,KAAnB,EAA0B,IAA1B,CAAD,CAAb;;AACF,WAAK,CAAL;AACE,eAAO,MAAM,CAAC,QAAQ,CAAC,SAAT,CAAmB,KAAnB,EAA0B,IAA1B,CAAD,CAAb;;AACF,WAAK,CAAL;AACE,eAAO,QAAQ,CAAC,YAAT,CAAsB,KAAtB,EAA6B,IAA7B,CAAP;;AACF,WAAK,EAAL;AAAS;AACP,gBAAM,CAAC,GAAG,QAAQ,CAAC,YAAT,CAAsB,KAAtB,EAA6B,IAA7B,CAAV;AACA,gBAAM,CAAC,GAAG,QAAQ,CAAC,YAAT,CAAsB,KAAK,GAAG,CAA9B,EAAiC,IAAjC,CAAV;AACA,iBAAO,CAAC,GAAG,eAAJ,GAAsB,CAA7B;AACD;;AACD,WAAK,EAAL;AAAS;AACP,gBAAM,CAAC,GAAG,QAAQ,CAAC,YAAT,CAAsB,KAAtB,EAA6B,IAA7B,CAAV;AACA,gBAAM,CAAC,GAAG,QAAQ,CAAC,YAAT,CAAsB,KAAK,GAAG,CAA9B,EAAiC,IAAjC,CAAV;AACA,gBAAM,CAAC,GAAG,QAAQ,CAAC,YAAT,CAAsB,KAAK,GAAG,EAA9B,EAAkC,IAAlC,CAAV;AACA,gBAAM,CAAC,GAAG,QAAQ,CAAC,YAAT,CAAsB,KAAK,GAAG,EAA9B,EAAkC,IAAlC,CAAV;AACA,iBAAO,CAAC,GAAG,gBAAJ,GAAuB,CAAC,GAAG,gBAA3B,GAA8C,CAAC,GAAG,eAAlD,GAAoE,CAA3E;AACD;AApBH;AAsBD;;AAED,EAAA,qBAAqB,CAAC,MAAD,EAAoB,MAApB,EAAoC,IAApC,EAA8C;AACjE,UAAM,KAAK,GAAI,IAAiB,CAAC,aAAlB,CAAgC,KAAK,UAArC,EAAiD,CAAjD,CAAf;AACA,SAAK,sBAAL,CAA4B,MAA5B,EAAoC,MAApC,EAA4C,KAA5C;AACA,WAAO,MAAM,GAAG,KAAK,UAArB;AACD;;AAED,EAAA,yBAAyB,CAAC,IAAD,EAAkB,KAAlB,EAAiC,GAAjC,EAA4C;AACnE,UAAM,IAAI,GAAG,GAAG,GAAG,KAAnB;;AACA,QAAI,IAAI,KAAK,KAAK,UAAlB,EAA8B;AAC5B,YAAM,KAAK,CAAC,gBAAgB,IAAI,aAAa,KAAK,UAAU,EAAjD,CAAX;AACD;;AAED,UAAM,KAAK,GAAG,KAAK,0BAAL,CAAgC,IAAhC,EAAsC,KAAtC,EAA6C,GAA7C,CAAd;AACA,UAAM,IAAI,GAAG,wBAAA,CAAA,QAAA,CAAS,QAAT,EAAb;AACA,IAAA,IAAI,CAAC,aAAL,CAAmB,KAAK,UAAxB,EAAoC,CAApC,EAAuC,KAAvC;AACA,WAAO,IAAP;AACD,GA7GkD,CA+GnD;;;AAEA,EAAA,gBAAgB,CAAC,QAAD,EAAmB;AACjC,WAAO,QAAQ,CAAC,aAAT,CAAuB,KAAK,UAA5B,EAAwC,CAAxC,CAAP;AACD;AAED;;;AACA,EAAA,cAAc,CAAC,QAAD,EAAqB,KAArB,EAAkC;AAC9C,SAAK,oBAAL,CAA0B,QAA1B,EAAoC,CAApC,EAAuC,KAAvC;AACD;AAED;;;AACA,EAAA,sBAAsB,CAAC,QAAD,EAAqB,KAArB,EAAkC;AACtD,UAAM,WAAW,GAAG,KAAK,UAAL,IAAmB,KAAK,GAAG,KAAK,aAAhC,CAApB;AACA,WAAO,QAAQ,CAAC,aAAT,CAAuB,KAAK,UAA5B,EAAwC,WAAxC,CAAP;AACD;AAED;;;AACA,EAAA,oBAAoB,CAAC,QAAD,EAAqB,KAArB,EAAoC,KAApC,EAAiD;AACnE,UAAM,WAAW,GAAG,KAAK,UAAL,IAAmB,KAAK,GAAG,KAAK,aAAhC,CAApB,CADmE,CAEnE;;AACA,IAAA,QAAQ,CAAC,aAAT,CAAuB,KAAK,UAA5B,EAAwC,WAAxC,EAAqD,KAArD;AACD,GArIkD,CAuInD;;;AAEA,EAAA,QAAQ,CAAC,IAAD,EAAc;AACpB,QAAI,OAAO,IAAP,KAAgB,QAApB,EAA8B;AAC5B,aAAO,IAAP;AACD,KAFD,MAEO,IAAI,OAAO,IAAP,KAAgB,QAAhB,IAA4B,OAAO,IAAP,KAAgB,QAAhD,EAA0D;AAC/D,aAAO,MAAM,CAAC,IAAD,CAAb;AACD,KAFM,MAEA;AACL,YAAM,KAAK,CAAC,qBAAqB,OAAO,IAAI,kBAAjC,CAAX;AACD;AACF;;AAED,EAAA,MAAM,CAAC,KAAD,EAAc;AAClB,WAAO,KAAK,CAAC,QAAN,CAAe,EAAf,CAAP;AACD;;AArJkD;;AAArD,OAAA,CAAA,cAAA,GAAA,cAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.UintBigintType = exports.UintNumberType = exports.uintBigintByteLens = exports.uintNumberByteLens = void 0;\nconst persistent_merkle_tree_1 = require(\"@chainsafe/persistent-merkle-tree\");\nconst named_1 = require(\"../util/named\");\nconst basic_1 = require(\"./basic\");\n/* eslint-disable @typescript-eslint/member-ordering */\nconst MAX_SAFE_INTEGER_BN = BigInt(Number.MAX_SAFE_INTEGER);\nconst BIGINT_2_POW_64 = BigInt(2) ** BigInt(64);\nconst BIGINT_2_POW_128 = BigInt(2) ** BigInt(128);\nconst BIGINT_2_POW_192 = BigInt(2) ** BigInt(192);\n// const BIGINT_64_MAX = BigInt(\"0xffffffffffffffff\");\nconst NUMBER_2_POW_32 = 2 ** 32;\nconst NUMBER_32_MAX = 0xffffffff;\nexports.uintNumberByteLens = [1, 2, 4, 8];\nexports.uintBigintByteLens = [1, 2, 4, 8, 16, 32];\n/**\n * Uint: N-bit unsigned integer (where N in [8, 16, 32, 64, 128, 256])\n * - Notation: uintN\n *\n * UintNumber is represented as the Javascript primitive value 'Number'.\n *\n * The Number type is a double-precision 64-bit binary format IEEE 754 value (numbers between -(2^53 − 1) and\n * 2^53 − 1). It also has the symbolic value: +Infinity.\n *\n * As of 2021 performance of 'Number' is extremely faster than 'BigInt'. Some values are spec'ed as Uint64 but\n * practically they will never exceed 53 bits, such as any unit time or simple counters. This type is an optimization\n * for these cases, as UintNumber64 can represent any value between 0 and 2^53−1 as well as the max value 2^64-1.\n */\nclass UintNumberType extends basic_1.BasicType {\n    constructor(byteLength, opts) {\n        super();\n        this.byteLength = byteLength;\n        if (byteLength > 8) {\n            throw Error(\"UintNumber byteLength limit is 8\");\n        }\n        if (Math.log2(byteLength) % 1 !== 0) {\n            throw Error(\"byteLength must be a power of 2\");\n        }\n        this.typeName = opts?.typeName ?? `uint${byteLength * 8}`;\n        if (opts?.clipInfinity)\n            this.typeName += \"Inf\";\n        if (opts?.setBitwiseOR)\n            this.typeName += \"OR\";\n        this.itemsPerChunk = 32 / this.byteLength;\n        this.fixedSize = byteLength;\n        this.minSize = byteLength;\n        this.maxSize = byteLength;\n        this.maxDecimalStr = (BigInt(2) ** BigInt(this.byteLength * 8) - BigInt(1)).toString(10);\n        this.clipInfinity = opts?.clipInfinity === true;\n        this.setBitwiseOR = opts?.setBitwiseOR === true;\n    }\n    static named(byteLength, opts) {\n        return new (named_1.namedClass(UintNumberType, opts.typeName))(byteLength, opts);\n    }\n    defaultValue() {\n        return 0;\n    }\n    // Serialization + deserialization\n    value_serializeToBytes({ dataView }, offset, value) {\n        switch (this.byteLength) {\n            case 1:\n                dataView.setInt8(offset, value);\n                break;\n            case 2:\n                dataView.setUint16(offset, value, true);\n                break;\n            case 4:\n                dataView.setUint32(offset, value, true);\n                break;\n            case 8:\n                if (value === Infinity) {\n                    // TODO: Benchmark if it's faster to set BIGINT_64_MAX once\n                    dataView.setUint32(offset, 0xffffffff);\n                    dataView.setUint32(offset + 4, 0xffffffff);\n                }\n                else {\n                    dataView.setUint32(offset, value & 0xffffffff, true);\n                    dataView.setUint32(offset + 4, (value / NUMBER_2_POW_32) & 0xffffffff, true);\n                }\n                break;\n        }\n        return offset + this.byteLength;\n    }\n    value_deserializeFromBytes({ dataView }, start, end) {\n        this.assertValidSize(end - start);\n        switch (this.byteLength) {\n            case 1:\n                return dataView.getUint8(start);\n            case 2:\n                return dataView.getUint16(start, true);\n            case 4:\n                return dataView.getUint32(start, true);\n            case 8: {\n                const a = dataView.getUint32(start, true);\n                const b = dataView.getUint32(start + 4, true);\n                if (b === NUMBER_32_MAX && a === NUMBER_32_MAX && this.clipInfinity) {\n                    return Infinity;\n                }\n                else {\n                    return b * NUMBER_2_POW_32 + a;\n                }\n            }\n        }\n    }\n    tree_serializeToBytes(output, offset, node) {\n        const value = node.getUint(this.byteLength, 0, this.clipInfinity);\n        this.value_serializeToBytes(output, offset, value);\n        return offset + this.byteLength;\n    }\n    tree_deserializeFromBytes(data, start, end) {\n        this.assertValidSize(end - start);\n        const value = this.value_deserializeFromBytes(data, start, end);\n        const node = persistent_merkle_tree_1.LeafNode.fromZero();\n        node.setUint(this.byteLength, 0, value, this.clipInfinity);\n        return node;\n    }\n    // Fast Tree access\n    tree_getFromNode(leafNode) {\n        return leafNode.getUint(this.byteLength, 0, this.clipInfinity);\n    }\n    tree_setToNode(leafNode, value) {\n        this.tree_setToPackedNode(leafNode, 0, value);\n    }\n    tree_getFromPackedNode(leafNode, index) {\n        const offsetBytes = this.byteLength * (index % this.itemsPerChunk);\n        return leafNode.getUint(this.byteLength, offsetBytes, this.clipInfinity);\n    }\n    tree_setToPackedNode(leafNode, index, value) {\n        const offsetBytes = this.byteLength * (index % this.itemsPerChunk);\n        // TODO: Benchmark the cost of this if, and consider using a different class\n        if (this.setBitwiseOR) {\n            leafNode.bitwiseOrUint(this.byteLength, offsetBytes, value);\n        }\n        else {\n            leafNode.setUint(this.byteLength, offsetBytes, value, this.clipInfinity);\n        }\n    }\n    // JSON\n    fromJson(json) {\n        if (typeof json === \"number\") {\n            return json;\n        }\n        else if (typeof json === \"string\") {\n            if (this.clipInfinity && json === this.maxDecimalStr) {\n                // Allow to handle max possible number\n                return Infinity;\n            }\n            else {\n                const num = parseInt(json, 10);\n                if (isNaN(num)) {\n                    throw Error(\"JSON invalid number isNaN\");\n                }\n                else if (num > Number.MAX_SAFE_INTEGER) {\n                    // Throw to prevent decimal precision errors downstream\n                    throw Error(\"JSON invalid number > MAX_SAFE_INTEGER\");\n                }\n                else {\n                    return num;\n                }\n            }\n        }\n        else if (typeof json === \"bigint\") {\n            if (json > MAX_SAFE_INTEGER_BN) {\n                // Throw to prevent decimal precision errors downstream\n                throw Error(\"JSON invalid number > MAX_SAFE_INTEGER_BN\");\n            }\n            else {\n                return Number(json);\n            }\n        }\n        else {\n            throw Error(`JSON invalid type ${typeof json} expected number`);\n        }\n    }\n    toJson(value) {\n        if (value === Infinity) {\n            return this.maxDecimalStr;\n        }\n        else {\n            return value.toString(10);\n        }\n    }\n}\nexports.UintNumberType = UintNumberType;\n/**\n * Uint: N-bit unsigned integer (where N in [8, 16, 32, 64, 128, 256])\n * - Notation: uintN\n *\n * UintBigint is represented as the Javascript primitive value 'BigInt'.\n *\n * The BigInt type is a numeric primitive in JavaScript that can represent integers with arbitrary precision.\n * With BigInts, you can safely store and operate on large integers even beyond the safe integer limit for Numbers.\n *\n * As of 2021 performance of 'Number' is extremely faster than 'BigInt'. For Uint values under 53 bits use UintNumber.\n * For other values that may exceed 53 bits, use UintBigint.\n */\nclass UintBigintType extends basic_1.BasicType {\n    constructor(byteLength, opts) {\n        super();\n        this.byteLength = byteLength;\n        if (byteLength > 32) {\n            throw Error(\"UintBigint byteLength limit is 32\");\n        }\n        if (Math.log2(byteLength) % 1 !== 0) {\n            throw Error(\"byteLength must be a power of 2\");\n        }\n        this.typeName = opts?.typeName ?? `uintBigint${byteLength * 8}`;\n        this.byteLength = byteLength;\n        this.itemsPerChunk = 32 / this.byteLength;\n        this.fixedSize = byteLength;\n        this.minSize = byteLength;\n        this.maxSize = byteLength;\n    }\n    static named(byteLength, opts) {\n        return new (named_1.namedClass(UintBigintType, opts.typeName))(byteLength, opts);\n    }\n    defaultValue() {\n        return BigInt(0);\n    }\n    // Serialization + deserialization\n    value_serializeToBytes({ dataView }, offset, value) {\n        switch (this.byteLength) {\n            case 1:\n                dataView.setInt8(offset, Number(value));\n                break;\n            case 2:\n                dataView.setUint16(offset, Number(value), true);\n                break;\n            case 4:\n                dataView.setUint32(offset, Number(value), true);\n                break;\n            case 8:\n                dataView.setBigUint64(offset, value, true);\n                break;\n            default: {\n                for (let i = 0; i < this.byteLength; i += 8) {\n                    if (i > 0)\n                        value = value / BIGINT_2_POW_64;\n                    const lo = BigInt.asUintN(64, value);\n                    dataView.setBigUint64(offset + i, lo, true);\n                }\n            }\n        }\n        return offset + this.byteLength;\n    }\n    value_deserializeFromBytes({ dataView }, start, end) {\n        const size = end - start;\n        if (size !== this.byteLength) {\n            throw Error(`Invalid size ${size} expected ${this.byteLength}`);\n        }\n        // Note: pre-assigning the right function at the constructor to avoid this switch is not faster\n        switch (this.byteLength) {\n            case 1:\n                return BigInt(dataView.getUint8(start));\n            case 2:\n                return BigInt(dataView.getUint16(start, true));\n            case 4:\n                return BigInt(dataView.getUint32(start, true));\n            case 8:\n                return dataView.getBigUint64(start, true);\n            case 16: {\n                const a = dataView.getBigUint64(start, true);\n                const b = dataView.getBigUint64(start + 8, true);\n                return b * BIGINT_2_POW_64 + a;\n            }\n            case 32: {\n                const a = dataView.getBigUint64(start, true);\n                const b = dataView.getBigUint64(start + 8, true);\n                const c = dataView.getBigUint64(start + 16, true);\n                const d = dataView.getBigUint64(start + 24, true);\n                return d * BIGINT_2_POW_192 + c * BIGINT_2_POW_128 + b * BIGINT_2_POW_64 + a;\n            }\n        }\n    }\n    tree_serializeToBytes(output, offset, node) {\n        const value = node.getUintBigint(this.byteLength, 0);\n        this.value_serializeToBytes(output, offset, value);\n        return offset + this.byteLength;\n    }\n    tree_deserializeFromBytes(data, start, end) {\n        const size = end - start;\n        if (size !== this.byteLength) {\n            throw Error(`Invalid size ${size} expected ${this.byteLength}`);\n        }\n        const value = this.value_deserializeFromBytes(data, start, end);\n        const node = persistent_merkle_tree_1.LeafNode.fromZero();\n        node.setUintBigint(this.byteLength, 0, value);\n        return node;\n    }\n    // Fast Tree access\n    tree_getFromNode(leafNode) {\n        return leafNode.getUintBigint(this.byteLength, 0);\n    }\n    /** Mutates node to set value */\n    tree_setToNode(leafNode, value) {\n        this.tree_setToPackedNode(leafNode, 0, value);\n    }\n    /** EXAMPLE of `tree_getFromNode` */\n    tree_getFromPackedNode(leafNode, index) {\n        const offsetBytes = this.byteLength * (index % this.itemsPerChunk);\n        return leafNode.getUintBigint(this.byteLength, offsetBytes);\n    }\n    /** Mutates node to set value */\n    tree_setToPackedNode(leafNode, index, value) {\n        const offsetBytes = this.byteLength * (index % this.itemsPerChunk);\n        // TODO: Not-optimized, copy pasted from UintNumberType\n        leafNode.setUintBigint(this.byteLength, offsetBytes, value);\n    }\n    // JSON\n    fromJson(json) {\n        if (typeof json === \"bigint\") {\n            return json;\n        }\n        else if (typeof json === \"string\" || typeof json === \"number\") {\n            return BigInt(json);\n        }\n        else {\n            throw Error(`JSON invalid type ${typeof json} expected bigint`);\n        }\n    }\n    toJson(value) {\n        return value.toString(10);\n    }\n}\nexports.UintBigintType = UintBigintType;\n//# sourceMappingURL=uint.js.map"]},"metadata":{},"sourceType":"script"}