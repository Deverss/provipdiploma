{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createNodeFromSingleProof = exports.createSingleProof = exports.ERR_INVALID_NAV = void 0;\n\nconst node_1 = require(\"../node\");\n\nconst gindex_1 = require(\"../gindex\");\n\nexports.ERR_INVALID_NAV = \"Invalid tree navigation\";\n\nfunction createSingleProof(rootNode, index) {\n  const witnesses = [];\n  let node = rootNode;\n\n  for (const i of gindex_1.gindexIterator(index)) {\n    if (i) {\n      if (node.isLeaf()) throw new Error(exports.ERR_INVALID_NAV);\n      witnesses.push(node.left.root);\n      node = node.right;\n    } else {\n      if (node.isLeaf()) throw new Error(exports.ERR_INVALID_NAV);\n      witnesses.push(node.right.root);\n      node = node.left;\n    }\n  }\n\n  return [node.root, witnesses.reverse()];\n}\n\nexports.createSingleProof = createSingleProof;\n\nfunction createNodeFromSingleProof(gindex, leaf, witnesses) {\n  let node = node_1.LeafNode.fromRoot(leaf);\n  const w = witnesses.slice().reverse();\n\n  while (gindex > 1) {\n    const sibling = node_1.LeafNode.fromRoot(w.pop());\n\n    if (gindex % BigInt(2) === BigInt(0)) {\n      node = new node_1.BranchNode(node, sibling);\n    } else {\n      node = new node_1.BranchNode(sibling, node);\n    }\n\n    gindex = gindex / BigInt(2);\n  }\n\n  return node;\n}\n\nexports.createNodeFromSingleProof = createNodeFromSingleProof;","map":{"version":3,"sources":["/Users/dev3rs/provipdiploma/node_modules/@chainsafe/persistent-merkle-tree/lib/proof/single.js"],"names":["Object","defineProperty","exports","value","createNodeFromSingleProof","createSingleProof","ERR_INVALID_NAV","node_1","require","gindex_1","rootNode","index","witnesses","node","i","gindexIterator","isLeaf","Error","push","left","root","right","reverse","gindex","leaf","LeafNode","fromRoot","w","slice","sibling","pop","BigInt","BranchNode"],"mappings":"AAAA;;AACAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;AACAD,OAAO,CAACE,yBAAR,GAAoCF,OAAO,CAACG,iBAAR,GAA4BH,OAAO,CAACI,eAAR,GAA0B,KAAK,CAA/F;;AACA,MAAMC,MAAM,GAAGC,OAAO,CAAC,SAAD,CAAtB;;AACA,MAAMC,QAAQ,GAAGD,OAAO,CAAC,WAAD,CAAxB;;AACAN,OAAO,CAACI,eAAR,GAA0B,yBAA1B;;AACA,SAASD,iBAAT,CAA2BK,QAA3B,EAAqCC,KAArC,EAA4C;AACxC,QAAMC,SAAS,GAAG,EAAlB;AACA,MAAIC,IAAI,GAAGH,QAAX;;AACA,OAAK,MAAMI,CAAX,IAAgBL,QAAQ,CAACM,cAAT,CAAwBJ,KAAxB,CAAhB,EAAgD;AAC5C,QAAIG,CAAJ,EAAO;AACH,UAAID,IAAI,CAACG,MAAL,EAAJ,EACI,MAAM,IAAIC,KAAJ,CAAUf,OAAO,CAACI,eAAlB,CAAN;AACJM,MAAAA,SAAS,CAACM,IAAV,CAAeL,IAAI,CAACM,IAAL,CAAUC,IAAzB;AACAP,MAAAA,IAAI,GAAGA,IAAI,CAACQ,KAAZ;AACH,KALD,MAMK;AACD,UAAIR,IAAI,CAACG,MAAL,EAAJ,EACI,MAAM,IAAIC,KAAJ,CAAUf,OAAO,CAACI,eAAlB,CAAN;AACJM,MAAAA,SAAS,CAACM,IAAV,CAAeL,IAAI,CAACQ,KAAL,CAAWD,IAA1B;AACAP,MAAAA,IAAI,GAAGA,IAAI,CAACM,IAAZ;AACH;AACJ;;AACD,SAAO,CAACN,IAAI,CAACO,IAAN,EAAYR,SAAS,CAACU,OAAV,EAAZ,CAAP;AACH;;AACDpB,OAAO,CAACG,iBAAR,GAA4BA,iBAA5B;;AACA,SAASD,yBAAT,CAAmCmB,MAAnC,EAA2CC,IAA3C,EAAiDZ,SAAjD,EAA4D;AACxD,MAAIC,IAAI,GAAGN,MAAM,CAACkB,QAAP,CAAgBC,QAAhB,CAAyBF,IAAzB,CAAX;AACA,QAAMG,CAAC,GAAGf,SAAS,CAACgB,KAAV,GAAkBN,OAAlB,EAAV;;AACA,SAAOC,MAAM,GAAG,CAAhB,EAAmB;AACf,UAAMM,OAAO,GAAGtB,MAAM,CAACkB,QAAP,CAAgBC,QAAhB,CAAyBC,CAAC,CAACG,GAAF,EAAzB,CAAhB;;AACA,QAAIP,MAAM,GAAGQ,MAAM,CAAC,CAAD,CAAf,KAAuBA,MAAM,CAAC,CAAD,CAAjC,EAAsC;AAClClB,MAAAA,IAAI,GAAG,IAAIN,MAAM,CAACyB,UAAX,CAAsBnB,IAAtB,EAA4BgB,OAA5B,CAAP;AACH,KAFD,MAGK;AACDhB,MAAAA,IAAI,GAAG,IAAIN,MAAM,CAACyB,UAAX,CAAsBH,OAAtB,EAA+BhB,IAA/B,CAAP;AACH;;AACDU,IAAAA,MAAM,GAAGA,MAAM,GAAGQ,MAAM,CAAC,CAAD,CAAxB;AACH;;AACD,SAAOlB,IAAP;AACH;;AACDX,OAAO,CAACE,yBAAR,GAAoCA,yBAApC","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.createNodeFromSingleProof = exports.createSingleProof = exports.ERR_INVALID_NAV = void 0;\nconst node_1 = require(\"../node\");\nconst gindex_1 = require(\"../gindex\");\nexports.ERR_INVALID_NAV = \"Invalid tree navigation\";\nfunction createSingleProof(rootNode, index) {\n    const witnesses = [];\n    let node = rootNode;\n    for (const i of gindex_1.gindexIterator(index)) {\n        if (i) {\n            if (node.isLeaf())\n                throw new Error(exports.ERR_INVALID_NAV);\n            witnesses.push(node.left.root);\n            node = node.right;\n        }\n        else {\n            if (node.isLeaf())\n                throw new Error(exports.ERR_INVALID_NAV);\n            witnesses.push(node.right.root);\n            node = node.left;\n        }\n    }\n    return [node.root, witnesses.reverse()];\n}\nexports.createSingleProof = createSingleProof;\nfunction createNodeFromSingleProof(gindex, leaf, witnesses) {\n    let node = node_1.LeafNode.fromRoot(leaf);\n    const w = witnesses.slice().reverse();\n    while (gindex > 1) {\n        const sibling = node_1.LeafNode.fromRoot(w.pop());\n        if (gindex % BigInt(2) === BigInt(0)) {\n            node = new node_1.BranchNode(node, sibling);\n        }\n        else {\n            node = new node_1.BranchNode(sibling, node);\n        }\n        gindex = gindex / BigInt(2);\n    }\n    return node;\n}\nexports.createNodeFromSingleProof = createNodeFromSingleProof;\n"]},"metadata":{},"sourceType":"script"}