{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TreeView = void 0;\n\nconst persistent_merkle_tree_1 = require(\"@chainsafe/persistent-merkle-tree\");\n/**\n * A Tree View is a wrapper around a type and an SSZ Tree that contains:\n * - data merkleized\n * - a hook to its parent Tree to propagate changes upwards\n *\n * **View**\n * - Best for simple usage where performance is NOT important\n * - Applies changes immediately\n * - Has reference to parent tree\n * - Does NOT have caches for fast get / set ops\n */\n\n\nclass TreeView {\n  /** Serialize view to binary data */\n  serialize() {\n    const output = new Uint8Array(this.type.tree_serializedSize(this.node));\n    const dataView = new DataView(output.buffer, output.byteOffset, output.byteLength);\n    this.type.tree_serializeToBytes({\n      uint8Array: output,\n      dataView\n    }, 0, this.node);\n    return output;\n  }\n  /**\n   * Merkleize view and compute its hashTreeRoot.\n   *\n   * See spec for definition of hashTreeRoot:\n   * https://github.com/ethereum/consensus-specs/blob/dev/ssz/simple-serialize.md#merkleization\n   */\n\n\n  hashTreeRoot() {\n    return this.node.root;\n  }\n  /**\n   * Create a Merkle multiproof on this view's data.\n   * A `path` is an array of 'JSON' paths into the data\n   * @example\n   * ```ts\n   * state.createProof([\n   *   [\"validators\", 1234, \"slashed\"],\n   *   [\"genesisTime\"]\n   * ])\n   * ```\n   *\n   * See spec for definition of merkle multiproofs:\n   * https://github.com/ethereum/consensus-specs/blob/dev/ssz/merkle-proofs.md#merkle-multiproofs\n   */\n\n\n  createProof(paths) {\n    return this.type.tree_createProof(this.node, paths);\n  }\n  /**\n   * Transform the view into a value, from the current node instance.\n   * For ViewDU returns the value of the committed data, so call .commit() before if there are pending changes.\n   */\n\n\n  toValue() {\n    return this.type.tree_toValue(this.node);\n  }\n  /** Return a new Tree View instance referencing the same internal `Node`. Drops its existing `Tree` hook if any */\n\n\n  clone() {\n    return this.type.getView(new persistent_merkle_tree_1.Tree(this.node));\n  }\n\n}\n\nexports.TreeView = TreeView;","map":{"version":3,"sources":["../../src/view/abstract.ts"],"names":[],"mappings":";;;;;;;AAAA,MAAA,wBAAA,GAAA,OAAA,CAAA,mCAAA,CAAA;AAIA;;;;;;;;;;AAUG;;;AACH,MAAsB,QAAtB,CAA8B;AAM5B;AACA,EAAA,SAAS,GAAA;AACP,UAAM,MAAM,GAAG,IAAI,UAAJ,CAAe,KAAK,IAAL,CAAU,mBAAV,CAA8B,KAAK,IAAnC,CAAf,CAAf;AACA,UAAM,QAAQ,GAAG,IAAI,QAAJ,CAAa,MAAM,CAAC,MAApB,EAA4B,MAAM,CAAC,UAAnC,EAA+C,MAAM,CAAC,UAAtD,CAAjB;AACA,SAAK,IAAL,CAAU,qBAAV,CAAgC;AAAC,MAAA,UAAU,EAAE,MAAb;AAAqB,MAAA;AAArB,KAAhC,EAAgE,CAAhE,EAAmE,KAAK,IAAxE;AACA,WAAO,MAAP;AACD;AAED;;;;;AAKG;;;AACH,EAAA,YAAY,GAAA;AACV,WAAO,KAAK,IAAL,CAAU,IAAjB;AACD;AAED;;;;;;;;;;;;;AAaG;;;AACH,EAAA,WAAW,CAAC,KAAD,EAAkB;AAC3B,WAAO,KAAK,IAAL,CAAU,gBAAV,CAA2B,KAAK,IAAhC,EAAsC,KAAtC,CAAP;AACD;AAED;;;AAGG;;;AACH,EAAA,OAAO,GAAA;AACL,WAAO,KAAK,IAAL,CAAU,YAAV,CAAuB,KAAK,IAA5B,CAAP;AACD;AAED;;;AACA,EAAA,KAAK,GAAA;AACH,WAAO,KAAK,IAAL,CAAU,OAAV,CAAkB,IAAI,wBAAA,CAAA,IAAJ,CAAS,KAAK,IAAd,CAAlB,CAAP;AACD;;AArD2B;;AAA9B,OAAA,CAAA,QAAA,GAAA,QAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TreeView = void 0;\nconst persistent_merkle_tree_1 = require(\"@chainsafe/persistent-merkle-tree\");\n/**\n * A Tree View is a wrapper around a type and an SSZ Tree that contains:\n * - data merkleized\n * - a hook to its parent Tree to propagate changes upwards\n *\n * **View**\n * - Best for simple usage where performance is NOT important\n * - Applies changes immediately\n * - Has reference to parent tree\n * - Does NOT have caches for fast get / set ops\n */\nclass TreeView {\n    /** Serialize view to binary data */\n    serialize() {\n        const output = new Uint8Array(this.type.tree_serializedSize(this.node));\n        const dataView = new DataView(output.buffer, output.byteOffset, output.byteLength);\n        this.type.tree_serializeToBytes({ uint8Array: output, dataView }, 0, this.node);\n        return output;\n    }\n    /**\n     * Merkleize view and compute its hashTreeRoot.\n     *\n     * See spec for definition of hashTreeRoot:\n     * https://github.com/ethereum/consensus-specs/blob/dev/ssz/simple-serialize.md#merkleization\n     */\n    hashTreeRoot() {\n        return this.node.root;\n    }\n    /**\n     * Create a Merkle multiproof on this view's data.\n     * A `path` is an array of 'JSON' paths into the data\n     * @example\n     * ```ts\n     * state.createProof([\n     *   [\"validators\", 1234, \"slashed\"],\n     *   [\"genesisTime\"]\n     * ])\n     * ```\n     *\n     * See spec for definition of merkle multiproofs:\n     * https://github.com/ethereum/consensus-specs/blob/dev/ssz/merkle-proofs.md#merkle-multiproofs\n     */\n    createProof(paths) {\n        return this.type.tree_createProof(this.node, paths);\n    }\n    /**\n     * Transform the view into a value, from the current node instance.\n     * For ViewDU returns the value of the committed data, so call .commit() before if there are pending changes.\n     */\n    toValue() {\n        return this.type.tree_toValue(this.node);\n    }\n    /** Return a new Tree View instance referencing the same internal `Node`. Drops its existing `Tree` hook if any */\n    clone() {\n        return this.type.getView(new persistent_merkle_tree_1.Tree(this.node));\n    }\n}\nexports.TreeView = TreeView;\n//# sourceMappingURL=abstract.js.map"]},"metadata":{},"sourceType":"script"}