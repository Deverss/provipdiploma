{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.parseGethGenesis = void 0;\n\nconst util_1 = require(\"@ethereumjs/util\");\n\nconst enums_1 = require(\"./enums\");\n/**\n * Transforms Geth formatted nonce (i.e. hex string) to 8 byte 0x-prefixed string used internally\n * @param nonce string parsed from the Geth genesis file\n * @returns nonce as a 0x-prefixed 8 byte string\n */\n\n\nfunction formatNonce(nonce) {\n  if (!nonce || nonce === '0x0') {\n    return '0x0000000000000000';\n  }\n\n  if ((0, util_1.isHexPrefixed)(nonce)) {\n    return '0x' + (0, util_1.stripHexPrefix)(nonce).padStart(16, '0');\n  }\n\n  return '0x' + nonce.padStart(16, '0');\n}\n/**\n * Converts Geth genesis parameters to an EthereumJS compatible `CommonOpts` object\n * @param json object representing the Geth genesis file\n * @param optional mergeForkIdPostMerge which clarifies the placement of MergeForkIdTransition\n * hardfork, which by default is post merge as with the merged eth networks but could also come\n * before merge like in kiln genesis\n * @returns genesis parameters in a `CommonOpts` compliant object\n */\n\n\nfunction parseGethParams(json, mergeForkIdPostMerge = true) {\n  const {\n    name,\n    config,\n    difficulty,\n    mixHash,\n    gasLimit,\n    coinbase,\n    baseFeePerGas\n  } = json;\n  let {\n    extraData,\n    timestamp,\n    nonce\n  } = json;\n  const genesisTimestamp = Number(timestamp);\n  const {\n    chainId\n  } = config; // geth is not strictly putting empty fields with a 0x prefix\n\n  if (extraData === '') {\n    extraData = '0x';\n  } // geth may use number for timestamp\n\n\n  if (!(0, util_1.isHexPrefixed)(timestamp)) {\n    timestamp = (0, util_1.intToHex)(parseInt(timestamp));\n  } // geth may not give us a nonce strictly formatted to an 8 byte hex string\n\n\n  if (nonce.length !== 18) {\n    nonce = formatNonce(nonce);\n  } // EIP155 and EIP158 are both part of Spurious Dragon hardfork and must occur at the same time\n  // but have different configuration parameters in geth genesis parameters\n\n\n  if (config.eip155Block !== config.eip158Block) {\n    throw new Error('EIP155 block number must equal EIP 158 block number since both are part of SpuriousDragon hardfork and the client only supports activating the full hardfork');\n  }\n\n  const params = {\n    name,\n    chainId,\n    networkId: chainId,\n    genesis: {\n      timestamp,\n      gasLimit: parseInt(gasLimit),\n      difficulty: parseInt(difficulty),\n      nonce,\n      extraData,\n      mixHash,\n      coinbase,\n      baseFeePerGas\n    },\n    hardfork: undefined,\n    hardforks: [],\n    bootstrapNodes: [],\n    consensus: config.clique !== undefined ? {\n      type: 'poa',\n      algorithm: 'clique',\n      clique: {\n        // The recent geth genesis seems to be using blockperiodseconds\n        // and epochlength for clique specification\n        // see: https://hackmd.io/PqZgMpnkSWCWv5joJoFymQ\n        period: config.clique.period ?? config.clique.blockperiodseconds,\n        epoch: config.clique.epoch ?? config.clique.epochlength\n      }\n    } : {\n      type: 'pow',\n      algorithm: 'ethash',\n      ethash: {}\n    }\n  };\n  const forkMap = {\n    [enums_1.Hardfork.Homestead]: {\n      name: 'homesteadBlock'\n    },\n    [enums_1.Hardfork.Dao]: {\n      name: 'daoForkBlock'\n    },\n    [enums_1.Hardfork.TangerineWhistle]: {\n      name: 'eip150Block'\n    },\n    [enums_1.Hardfork.SpuriousDragon]: {\n      name: 'eip155Block'\n    },\n    [enums_1.Hardfork.Byzantium]: {\n      name: 'byzantiumBlock'\n    },\n    [enums_1.Hardfork.Constantinople]: {\n      name: 'constantinopleBlock'\n    },\n    [enums_1.Hardfork.Petersburg]: {\n      name: 'petersburgBlock'\n    },\n    [enums_1.Hardfork.Istanbul]: {\n      name: 'istanbulBlock'\n    },\n    [enums_1.Hardfork.MuirGlacier]: {\n      name: 'muirGlacierBlock'\n    },\n    [enums_1.Hardfork.Berlin]: {\n      name: 'berlinBlock'\n    },\n    [enums_1.Hardfork.London]: {\n      name: 'londonBlock'\n    },\n    [enums_1.Hardfork.MergeForkIdTransition]: {\n      name: 'mergeForkBlock',\n      postMerge: mergeForkIdPostMerge\n    },\n    [enums_1.Hardfork.Shanghai]: {\n      name: 'shanghaiTime',\n      postMerge: true,\n      isTimestamp: true\n    },\n    [enums_1.Hardfork.ShardingForkDev]: {\n      name: 'shardingForkTime',\n      postMerge: true,\n      isTimestamp: true\n    }\n  }; // forkMapRev is the map from config field name to Hardfork\n\n  const forkMapRev = Object.keys(forkMap).reduce((acc, elem) => {\n    acc[forkMap[elem].name] = elem;\n    return acc;\n  }, {});\n  const configHardforkNames = Object.keys(config).filter(key => forkMapRev[key] !== undefined && config[key] !== undefined && config[key] !== null);\n  params.hardforks = configHardforkNames.map(nameBlock => ({\n    name: forkMapRev[nameBlock],\n    block: forkMap[forkMapRev[nameBlock]].isTimestamp === true || typeof config[nameBlock] !== 'number' ? null : config[nameBlock],\n    timestamp: forkMap[forkMapRev[nameBlock]].isTimestamp === true && typeof config[nameBlock] === 'number' ? config[nameBlock] : undefined\n  })).filter(fork => fork.block !== null || fork.timestamp !== undefined);\n  params.hardforks.sort(function (a, b) {\n    return (a.block ?? Infinity) - (b.block ?? Infinity);\n  });\n  params.hardforks.sort(function (a, b) {\n    return (a.timestamp ?? genesisTimestamp) - (b.timestamp ?? genesisTimestamp);\n  });\n\n  if (config.terminalTotalDifficulty !== undefined) {\n    // Following points need to be considered for placement of merge hf\n    // - Merge hardfork can't be placed at genesis\n    // - Place merge hf before any hardforks that require CL participation for e.g. withdrawals\n    // - Merge hardfork has to be placed just after genesis if any of the genesis hardforks make CL\n    //   necessary for e.g. withdrawals\n    const mergeConfig = {\n      name: enums_1.Hardfork.Merge,\n      ttd: config.terminalTotalDifficulty,\n      block: null\n    }; // Merge hardfork has to be placed before first hardfork that is dependent on merge\n\n    const postMergeIndex = params.hardforks.findIndex(hf => {\n      var _forkMap$hf$name;\n\n      return ((_forkMap$hf$name = forkMap[hf.name]) === null || _forkMap$hf$name === void 0 ? void 0 : _forkMap$hf$name.postMerge) === true;\n    });\n\n    if (postMergeIndex !== -1) {\n      params.hardforks.splice(postMergeIndex, 0, mergeConfig);\n    } else {\n      params.hardforks.push(mergeConfig);\n    }\n  }\n\n  const latestHardfork = params.hardforks.length > 0 ? params.hardforks.slice(-1)[0] : undefined;\n  params.hardfork = latestHardfork === null || latestHardfork === void 0 ? void 0 : latestHardfork.name;\n  params.hardforks.unshift({\n    name: enums_1.Hardfork.Chainstart,\n    block: 0\n  });\n  return params;\n}\n/**\n * Parses a genesis.json exported from Geth into parameters for Common instance\n * @param json representing the Geth genesis file\n * @param name optional chain name\n * @returns parsed params\n */\n\n\nfunction parseGethGenesis(json, name, mergeForkIdPostMerge) {\n  try {\n    if (['config', 'difficulty', 'gasLimit', 'alloc'].some(field => !(field in json))) {\n      throw new Error('Invalid format, expected geth genesis fields missing');\n    }\n\n    if (name !== undefined) {\n      json.name = name;\n    }\n\n    return parseGethParams(json, mergeForkIdPostMerge);\n  } catch (e) {\n    throw new Error(`Error parsing parameters file: ${e.message}`);\n  }\n}\n\nexports.parseGethGenesis = parseGethGenesis;","map":{"version":3,"sources":["../src/utils.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.parseGethGenesis = void 0;\nconst util_1 = require(\"@ethereumjs/util\");\nconst enums_1 = require(\"./enums\");\n/**\n * Transforms Geth formatted nonce (i.e. hex string) to 8 byte 0x-prefixed string used internally\n * @param nonce string parsed from the Geth genesis file\n * @returns nonce as a 0x-prefixed 8 byte string\n */\nfunction formatNonce(nonce) {\n    if (!nonce || nonce === '0x0') {\n        return '0x0000000000000000';\n    }\n    if ((0, util_1.isHexPrefixed)(nonce)) {\n        return '0x' + (0, util_1.stripHexPrefix)(nonce).padStart(16, '0');\n    }\n    return '0x' + nonce.padStart(16, '0');\n}\n/**\n * Converts Geth genesis parameters to an EthereumJS compatible `CommonOpts` object\n * @param json object representing the Geth genesis file\n * @param optional mergeForkIdPostMerge which clarifies the placement of MergeForkIdTransition\n * hardfork, which by default is post merge as with the merged eth networks but could also come\n * before merge like in kiln genesis\n * @returns genesis parameters in a `CommonOpts` compliant object\n */\nfunction parseGethParams(json, mergeForkIdPostMerge = true) {\n    const { name, config, difficulty, mixHash, gasLimit, coinbase, baseFeePerGas, } = json;\n    let { extraData, timestamp, nonce } = json;\n    const genesisTimestamp = Number(timestamp);\n    const { chainId } = config;\n    // geth is not strictly putting empty fields with a 0x prefix\n    if (extraData === '') {\n        extraData = '0x';\n    }\n    // geth may use number for timestamp\n    if (!(0, util_1.isHexPrefixed)(timestamp)) {\n        timestamp = (0, util_1.intToHex)(parseInt(timestamp));\n    }\n    // geth may not give us a nonce strictly formatted to an 8 byte hex string\n    if (nonce.length !== 18) {\n        nonce = formatNonce(nonce);\n    }\n    // EIP155 and EIP158 are both part of Spurious Dragon hardfork and must occur at the same time\n    // but have different configuration parameters in geth genesis parameters\n    if (config.eip155Block !== config.eip158Block) {\n        throw new Error('EIP155 block number must equal EIP 158 block number since both are part of SpuriousDragon hardfork and the client only supports activating the full hardfork');\n    }\n    const params = {\n        name,\n        chainId,\n        networkId: chainId,\n        genesis: {\n            timestamp,\n            gasLimit: parseInt(gasLimit),\n            difficulty: parseInt(difficulty),\n            nonce,\n            extraData,\n            mixHash,\n            coinbase,\n            baseFeePerGas,\n        },\n        hardfork: undefined,\n        hardforks: [],\n        bootstrapNodes: [],\n        consensus: config.clique !== undefined\n            ? {\n                type: 'poa',\n                algorithm: 'clique',\n                clique: {\n                    // The recent geth genesis seems to be using blockperiodseconds\n                    // and epochlength for clique specification\n                    // see: https://hackmd.io/PqZgMpnkSWCWv5joJoFymQ\n                    period: config.clique.period ?? config.clique.blockperiodseconds,\n                    epoch: config.clique.epoch ?? config.clique.epochlength,\n                },\n            }\n            : {\n                type: 'pow',\n                algorithm: 'ethash',\n                ethash: {},\n            },\n    };\n    const forkMap = {\n        [enums_1.Hardfork.Homestead]: { name: 'homesteadBlock' },\n        [enums_1.Hardfork.Dao]: { name: 'daoForkBlock' },\n        [enums_1.Hardfork.TangerineWhistle]: { name: 'eip150Block' },\n        [enums_1.Hardfork.SpuriousDragon]: { name: 'eip155Block' },\n        [enums_1.Hardfork.Byzantium]: { name: 'byzantiumBlock' },\n        [enums_1.Hardfork.Constantinople]: { name: 'constantinopleBlock' },\n        [enums_1.Hardfork.Petersburg]: { name: 'petersburgBlock' },\n        [enums_1.Hardfork.Istanbul]: { name: 'istanbulBlock' },\n        [enums_1.Hardfork.MuirGlacier]: { name: 'muirGlacierBlock' },\n        [enums_1.Hardfork.Berlin]: { name: 'berlinBlock' },\n        [enums_1.Hardfork.London]: { name: 'londonBlock' },\n        [enums_1.Hardfork.MergeForkIdTransition]: { name: 'mergeForkBlock', postMerge: mergeForkIdPostMerge },\n        [enums_1.Hardfork.Shanghai]: { name: 'shanghaiTime', postMerge: true, isTimestamp: true },\n        [enums_1.Hardfork.ShardingForkDev]: { name: 'shardingForkTime', postMerge: true, isTimestamp: true },\n    };\n    // forkMapRev is the map from config field name to Hardfork\n    const forkMapRev = Object.keys(forkMap).reduce((acc, elem) => {\n        acc[forkMap[elem].name] = elem;\n        return acc;\n    }, {});\n    const configHardforkNames = Object.keys(config).filter((key) => forkMapRev[key] !== undefined && config[key] !== undefined && config[key] !== null);\n    params.hardforks = configHardforkNames\n        .map((nameBlock) => ({\n        name: forkMapRev[nameBlock],\n        block: forkMap[forkMapRev[nameBlock]].isTimestamp === true || typeof config[nameBlock] !== 'number'\n            ? null\n            : config[nameBlock],\n        timestamp: forkMap[forkMapRev[nameBlock]].isTimestamp === true && typeof config[nameBlock] === 'number'\n            ? config[nameBlock]\n            : undefined,\n    }))\n        .filter((fork) => fork.block !== null || fork.timestamp !== undefined);\n    params.hardforks.sort(function (a, b) {\n        return (a.block ?? Infinity) - (b.block ?? Infinity);\n    });\n    params.hardforks.sort(function (a, b) {\n        return (a.timestamp ?? genesisTimestamp) - (b.timestamp ?? genesisTimestamp);\n    });\n    if (config.terminalTotalDifficulty !== undefined) {\n        // Following points need to be considered for placement of merge hf\n        // - Merge hardfork can't be placed at genesis\n        // - Place merge hf before any hardforks that require CL participation for e.g. withdrawals\n        // - Merge hardfork has to be placed just after genesis if any of the genesis hardforks make CL\n        //   necessary for e.g. withdrawals\n        const mergeConfig = {\n            name: enums_1.Hardfork.Merge,\n            ttd: config.terminalTotalDifficulty,\n            block: null,\n        };\n        // Merge hardfork has to be placed before first hardfork that is dependent on merge\n        const postMergeIndex = params.hardforks.findIndex((hf) => forkMap[hf.name]?.postMerge === true);\n        if (postMergeIndex !== -1) {\n            params.hardforks.splice(postMergeIndex, 0, mergeConfig);\n        }\n        else {\n            params.hardforks.push(mergeConfig);\n        }\n    }\n    const latestHardfork = params.hardforks.length > 0 ? params.hardforks.slice(-1)[0] : undefined;\n    params.hardfork = latestHardfork?.name;\n    params.hardforks.unshift({ name: enums_1.Hardfork.Chainstart, block: 0 });\n    return params;\n}\n/**\n * Parses a genesis.json exported from Geth into parameters for Common instance\n * @param json representing the Geth genesis file\n * @param name optional chain name\n * @returns parsed params\n */\nfunction parseGethGenesis(json, name, mergeForkIdPostMerge) {\n    try {\n        if (['config', 'difficulty', 'gasLimit', 'alloc'].some((field) => !(field in json))) {\n            throw new Error('Invalid format, expected geth genesis fields missing');\n        }\n        if (name !== undefined) {\n            json.name = name;\n        }\n        return parseGethParams(json, mergeForkIdPostMerge);\n    }\n    catch (e) {\n        throw new Error(`Error parsing parameters file: ${e.message}`);\n    }\n}\nexports.parseGethGenesis = parseGethGenesis;\n//# sourceMappingURL=utils.js.map"]},"metadata":{},"sourceType":"script"}