{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.digest64HashObjects = exports.digest2Bytes32 = exports.digest64 = exports.digest = exports.SHA256 = exports.hashObjectToByteArray = exports.byteArrayToHashObject = void 0;\n\nconst wasm_1 = require(\"./wasm\");\n\nconst hashObject_1 = require(\"./hashObject\");\n\nObject.defineProperty(exports, \"byteArrayToHashObject\", {\n  enumerable: true,\n  get: function () {\n    return hashObject_1.byteArrayToHashObject;\n  }\n});\nObject.defineProperty(exports, \"hashObjectToByteArray\", {\n  enumerable: true,\n  get: function () {\n    return hashObject_1.hashObjectToByteArray;\n  }\n});\n\nconst sha256_1 = __importDefault(require(\"./sha256\"));\n\nexports.SHA256 = sha256_1.default;\nconst ctx = wasm_1.newInstance();\nconst wasmInputValue = ctx.input.value;\nconst wasmOutputValue = ctx.output.value;\nconst inputUint8Array = new Uint8Array(ctx.memory.buffer, wasmInputValue, ctx.INPUT_LENGTH);\nconst outputUint8Array = new Uint8Array(ctx.memory.buffer, wasmOutputValue, 32);\nconst inputUint32Array = new Uint32Array(ctx.memory.buffer, wasmInputValue, ctx.INPUT_LENGTH);\n\nfunction digest(data) {\n  if (data.length === 64) {\n    return digest64(data);\n  }\n\n  if (data.length <= ctx.INPUT_LENGTH) {\n    inputUint8Array.set(data);\n    ctx.digest(data.length);\n    const output = new Uint8Array(32);\n    output.set(outputUint8Array);\n    return output;\n  }\n\n  ctx.init();\n  update(data);\n  return final();\n}\n\nexports.digest = digest;\n\nfunction digest64(data) {\n  if (data.length === 64) {\n    inputUint8Array.set(data);\n    ctx.digest64(wasmInputValue, wasmOutputValue);\n    const output = new Uint8Array(32);\n    output.set(outputUint8Array);\n    return output;\n  }\n\n  throw new Error(\"InvalidLengthForDigest64\");\n}\n\nexports.digest64 = digest64;\n\nfunction digest2Bytes32(bytes1, bytes2) {\n  if (bytes1.length === 32 && bytes2.length === 32) {\n    inputUint8Array.set(bytes1);\n    inputUint8Array.set(bytes2, 32);\n    ctx.digest64(wasmInputValue, wasmOutputValue);\n    const output = new Uint8Array(32);\n    output.set(outputUint8Array);\n    return output;\n  }\n\n  throw new Error(\"InvalidLengthForDigest64\");\n}\n\nexports.digest2Bytes32 = digest2Bytes32;\n/**\n * Digest 2 objects, each has 8 properties from h0 to h7.\n * The performance is a little bit better than digest64 due to the use of Uint32Array\n * and the memory is a little bit better than digest64 due to no temporary Uint8Array.\n * @returns\n */\n\nfunction digest64HashObjects(obj1, obj2) {\n  // TODO: expect obj1 and obj2 as HashObject\n  inputUint32Array[0] = obj1.h0;\n  inputUint32Array[1] = obj1.h1;\n  inputUint32Array[2] = obj1.h2;\n  inputUint32Array[3] = obj1.h3;\n  inputUint32Array[4] = obj1.h4;\n  inputUint32Array[5] = obj1.h5;\n  inputUint32Array[6] = obj1.h6;\n  inputUint32Array[7] = obj1.h7;\n  inputUint32Array[8] = obj2.h0;\n  inputUint32Array[9] = obj2.h1;\n  inputUint32Array[10] = obj2.h2;\n  inputUint32Array[11] = obj2.h3;\n  inputUint32Array[12] = obj2.h4;\n  inputUint32Array[13] = obj2.h5;\n  inputUint32Array[14] = obj2.h6;\n  inputUint32Array[15] = obj2.h7;\n  ctx.digest64(wasmInputValue, wasmOutputValue); // extracting numbers from Uint32Array causes more memory\n\n  return hashObject_1.byteArrayToHashObject(outputUint8Array);\n}\n\nexports.digest64HashObjects = digest64HashObjects;\n\nfunction update(data) {\n  const INPUT_LENGTH = ctx.INPUT_LENGTH;\n\n  if (data.length > INPUT_LENGTH) {\n    for (let i = 0; i < data.length; i += INPUT_LENGTH) {\n      const sliced = data.slice(i, i + INPUT_LENGTH);\n      inputUint8Array.set(sliced);\n      ctx.update(wasmInputValue, sliced.length);\n    }\n  } else {\n    inputUint8Array.set(data);\n    ctx.update(wasmInputValue, data.length);\n  }\n}\n\nfunction final() {\n  ctx.final(wasmOutputValue);\n  const output = new Uint8Array(32);\n  output.set(outputUint8Array);\n  return output;\n}","map":{"version":3,"sources":["../src/index.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.digest64HashObjects = exports.digest2Bytes32 = exports.digest64 = exports.digest = exports.SHA256 = exports.hashObjectToByteArray = exports.byteArrayToHashObject = void 0;\nconst wasm_1 = require(\"./wasm\");\nconst hashObject_1 = require(\"./hashObject\");\nObject.defineProperty(exports, \"byteArrayToHashObject\", { enumerable: true, get: function () { return hashObject_1.byteArrayToHashObject; } });\nObject.defineProperty(exports, \"hashObjectToByteArray\", { enumerable: true, get: function () { return hashObject_1.hashObjectToByteArray; } });\nconst sha256_1 = __importDefault(require(\"./sha256\"));\nexports.SHA256 = sha256_1.default;\nconst ctx = wasm_1.newInstance();\nconst wasmInputValue = ctx.input.value;\nconst wasmOutputValue = ctx.output.value;\nconst inputUint8Array = new Uint8Array(ctx.memory.buffer, wasmInputValue, ctx.INPUT_LENGTH);\nconst outputUint8Array = new Uint8Array(ctx.memory.buffer, wasmOutputValue, 32);\nconst inputUint32Array = new Uint32Array(ctx.memory.buffer, wasmInputValue, ctx.INPUT_LENGTH);\nfunction digest(data) {\n    if (data.length === 64) {\n        return digest64(data);\n    }\n    if (data.length <= ctx.INPUT_LENGTH) {\n        inputUint8Array.set(data);\n        ctx.digest(data.length);\n        const output = new Uint8Array(32);\n        output.set(outputUint8Array);\n        return output;\n    }\n    ctx.init();\n    update(data);\n    return final();\n}\nexports.digest = digest;\nfunction digest64(data) {\n    if (data.length === 64) {\n        inputUint8Array.set(data);\n        ctx.digest64(wasmInputValue, wasmOutputValue);\n        const output = new Uint8Array(32);\n        output.set(outputUint8Array);\n        return output;\n    }\n    throw new Error(\"InvalidLengthForDigest64\");\n}\nexports.digest64 = digest64;\nfunction digest2Bytes32(bytes1, bytes2) {\n    if (bytes1.length === 32 && bytes2.length === 32) {\n        inputUint8Array.set(bytes1);\n        inputUint8Array.set(bytes2, 32);\n        ctx.digest64(wasmInputValue, wasmOutputValue);\n        const output = new Uint8Array(32);\n        output.set(outputUint8Array);\n        return output;\n    }\n    throw new Error(\"InvalidLengthForDigest64\");\n}\nexports.digest2Bytes32 = digest2Bytes32;\n/**\n * Digest 2 objects, each has 8 properties from h0 to h7.\n * The performance is a little bit better than digest64 due to the use of Uint32Array\n * and the memory is a little bit better than digest64 due to no temporary Uint8Array.\n * @returns\n */\nfunction digest64HashObjects(obj1, obj2) {\n    // TODO: expect obj1 and obj2 as HashObject\n    inputUint32Array[0] = obj1.h0;\n    inputUint32Array[1] = obj1.h1;\n    inputUint32Array[2] = obj1.h2;\n    inputUint32Array[3] = obj1.h3;\n    inputUint32Array[4] = obj1.h4;\n    inputUint32Array[5] = obj1.h5;\n    inputUint32Array[6] = obj1.h6;\n    inputUint32Array[7] = obj1.h7;\n    inputUint32Array[8] = obj2.h0;\n    inputUint32Array[9] = obj2.h1;\n    inputUint32Array[10] = obj2.h2;\n    inputUint32Array[11] = obj2.h3;\n    inputUint32Array[12] = obj2.h4;\n    inputUint32Array[13] = obj2.h5;\n    inputUint32Array[14] = obj2.h6;\n    inputUint32Array[15] = obj2.h7;\n    ctx.digest64(wasmInputValue, wasmOutputValue);\n    // extracting numbers from Uint32Array causes more memory\n    return hashObject_1.byteArrayToHashObject(outputUint8Array);\n}\nexports.digest64HashObjects = digest64HashObjects;\nfunction update(data) {\n    const INPUT_LENGTH = ctx.INPUT_LENGTH;\n    if (data.length > INPUT_LENGTH) {\n        for (let i = 0; i < data.length; i += INPUT_LENGTH) {\n            const sliced = data.slice(i, i + INPUT_LENGTH);\n            inputUint8Array.set(sliced);\n            ctx.update(wasmInputValue, sliced.length);\n        }\n    }\n    else {\n        inputUint8Array.set(data);\n        ctx.update(wasmInputValue, data.length);\n    }\n}\nfunction final() {\n    ctx.final(wasmOutputValue);\n    const output = new Uint8Array(32);\n    output.set(outputUint8Array);\n    return output;\n}\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"script"}