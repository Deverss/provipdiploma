{"ast":null,"code":"import _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport { setAPIKey, setEmbedHost, post } from '@toruslabs/http-helpers';\nimport stringify from 'json-stable-stringify';\nimport { ec as ec$1 } from 'elliptic';\nimport createKeccakHash from 'keccak';\nimport { encrypt, getPublic, decrypt } from '@toruslabs/eccrypto';\n\nfunction keccak256(a) {\n  return createKeccakHash(\"keccak256\").update(a).digest();\n}\n\nconst ec = new ec$1(\"secp256k1\");\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n}\n\nclass MetadataStorageLayer {\n  // ms\n  constructor() {\n    let metadataHost = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"https://metadata.tor.us\";\n    let serverTimeOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n    _defineProperty(this, \"metadataHost\", void 0);\n\n    _defineProperty(this, \"serverTimeOffset\", void 0);\n\n    this.metadataHost = metadataHost;\n    this.serverTimeOffset = serverTimeOffset;\n  }\n\n  static setAPIKey(apiKey) {\n    setAPIKey(apiKey);\n  }\n\n  static setEmbedHost(embedHost) {\n    setEmbedHost(embedHost);\n  }\n\n  generateMetadataParams(message, privateKeyHex) {\n    var _sig$recoveryParam;\n\n    const key = ec.keyFromPrivate(privateKeyHex, \"hex\");\n    const setData = {\n      data: message,\n      timestamp: Math.floor(this.serverTimeOffset + Date.now() / 1000).toString(16)\n    };\n    const sig = key.sign(keccak256(stringify(setData)));\n    return {\n      pub_key_X: key.getPublic().getX().toString(\"hex\"),\n      pub_key_Y: key.getPublic().getY().toString(\"hex\"),\n      set_data: setData,\n      signature: Buffer.from(sig.r.toString(16, 64) + sig.s.toString(16, 64) + (((_sig$recoveryParam = sig.recoveryParam) === null || _sig$recoveryParam === void 0 ? void 0 : _sig$recoveryParam.toString(16).padStart(2, \"0\").slice(-2)) ?? \"00\"), \"hex\").toString(\"base64\")\n    };\n  }\n\n  generatePubKeyParams(privateKeyHex) {\n    const key = ec.keyFromPrivate(privateKeyHex, \"hex\");\n    return {\n      pub_key_X: key.getPublic().getX().toString(\"hex\"),\n      pub_key_Y: key.getPublic().getY().toString(\"hex\")\n    };\n  }\n\n  async setMetadata(data, namespace, options) {\n    const params = namespace !== null ? _objectSpread(_objectSpread({}, data), {}, {\n      namespace\n    }) : data;\n    const metadataResponse = await post(`${this.metadataHost}/set`, params, options, {\n      useAPIKey: true\n    });\n    return metadataResponse.message;\n  }\n\n  async getMetadata(pubKey, namespace, options) {\n    const params = namespace !== null ? _objectSpread(_objectSpread({}, pubKey), {}, {\n      namespace\n    }) : pubKey;\n    const metadataResponse = await post(`${this.metadataHost}/get`, params, options, {\n      useAPIKey: true\n    });\n    return metadataResponse.message;\n  }\n\n}\n\nconst WEBAUTHN_TORUS_SHARE = \"webauthn_torus_share\";\nconst WEBAUTHN_DEVICE_SHARE = \"webauthn_device_share\";\n\nfunction encParamsHexToBuf(encParamsHex) {\n  return {\n    iv: Buffer.from(encParamsHex.iv, \"hex\"),\n    ephemPublicKey: Buffer.from(encParamsHex.ephemPublicKey, \"hex\"),\n    ciphertext: Buffer.from(encParamsHex.ciphertext, \"hex\"),\n    mac: Buffer.from(encParamsHex.mac, \"hex\")\n  };\n}\n\nfunction encParamsBufToHex(encParams) {\n  return {\n    iv: Buffer.from(encParams.iv).toString(\"hex\"),\n    ephemPublicKey: Buffer.from(encParams.ephemPublicKey).toString(\"hex\"),\n    ciphertext: Buffer.from(encParams.ciphertext).toString(\"hex\"),\n    mac: Buffer.from(encParams.mac).toString(\"hex\")\n  };\n}\n\nasync function encryptData(privKeyHex, d) {\n  const serializedDec = JSON.stringify(d);\n  const serializedBuf = Buffer.from(serializedDec, \"utf-8\");\n  const encParams = await encrypt(getPublic(Buffer.from(privKeyHex, \"hex\")), serializedBuf);\n  const encParamsHex = encParamsBufToHex(encParams);\n  const sData = JSON.stringify(encParamsHex);\n  return sData;\n}\n\nasync function decryptData(privKeyHex, d) {\n  const encParamsHex = JSON.parse(d);\n  const encParams = encParamsHexToBuf(encParamsHex);\n  const keyPair = ec.keyFromPrivate(privKeyHex);\n  const serializedBuf = await decrypt(Buffer.from(keyPair.getPrivate().toString(\"hex\", 64), \"hex\"), encParams);\n  const serializedDec = serializedBuf.toString(\"utf-8\");\n  const data = JSON.parse(serializedDec);\n  return data;\n}\n\nasync function getAndDecryptData(m, privKeyHex, namespace) {\n  const keyPair = ec.keyFromPrivate(privKeyHex);\n  const pubKey = keyPair.getPublic();\n  const serializedData = await m.getMetadata({\n    pub_key_X: pubKey.getX().toString(16),\n    pub_key_Y: pubKey.getY().toString(16)\n  }, namespace);\n\n  if (!serializedData) {\n    return null;\n  }\n\n  const data = await decryptData(privKeyHex, serializedData);\n  return data;\n}\n\nasync function encryptAndSetData(m, privKeyHex, d, namespace) {\n  const sData = await encryptData(privKeyHex, d);\n  const metadataParams = m.generateMetadataParams(sData, privKeyHex);\n  await m.setMetadata(metadataParams, namespace);\n}\n\nasync function setTorusShare(m, webAuthnPubKey, webAuthnRefHex, subspace, subspaceData) {\n  const refKeyPair = ec.keyFromPrivate(webAuthnRefHex);\n  const privKey = refKeyPair.getPrivate();\n  const pubKey = ec.keyFromPublic({\n    x: webAuthnPubKey.pub_key_X,\n    y: webAuthnPubKey.pub_key_Y\n  });\n  const data = await getAndDecryptData(m, webAuthnRefHex, WEBAUTHN_TORUS_SHARE);\n  let d = {};\n  if (data) d = data;\n  const serializedSubspaceData = JSON.stringify(subspaceData);\n  const serializedSubspaceDataBuf = Buffer.from(serializedSubspaceData, \"utf-8\");\n  const encSubspaceData = await encrypt(Buffer.from(pubKey.getPublic(\"hex\"), \"hex\"), serializedSubspaceDataBuf);\n  const encSubspaceDataHex = encParamsBufToHex(encSubspaceData);\n  d[subspace] = encSubspaceDataHex;\n  await encryptAndSetData(m, privKey.toString(\"hex\", 64), d, WEBAUTHN_TORUS_SHARE);\n}\n\nasync function setDeviceShare(m, webAuthnRefHex, subspace, subspaceData) {\n  const keyPair = ec.keyFromPrivate(webAuthnRefHex);\n  const privKey = keyPair.getPrivate();\n  const data = await getAndDecryptData(m, webAuthnRefHex, WEBAUTHN_DEVICE_SHARE);\n  let d = {};\n  if (data) d = data;\n  d[subspace] = subspaceData;\n  await encryptAndSetData(m, privKey.toString(\"hex\", 64), d, WEBAUTHN_DEVICE_SHARE);\n}\n\nasync function getTorusShare(m, webAuthnKeyHex, webAuthnRefHex, subspace) {\n  const data = await getAndDecryptData(m, webAuthnRefHex, WEBAUTHN_TORUS_SHARE);\n  if (!data) return null;\n  const encParamsHex = data[subspace];\n  if (!encParamsHex) return null;\n  const encParams = encParamsHexToBuf(encParamsHex);\n  const keyPair = ec.keyFromPrivate(webAuthnKeyHex);\n  const privKey = keyPair.getPrivate();\n  const serializedSubspaceDataBuf = await decrypt(Buffer.from(privKey.toString(\"hex\", 64), \"hex\"), encParams);\n  const serializedSubspaceData = serializedSubspaceDataBuf.toString(\"utf-8\");\n  const subspaceData = JSON.parse(serializedSubspaceData);\n  return subspaceData;\n}\n\nasync function getDeviceShare(m, webAuthnRefHex, subspace) {\n  const data = await getAndDecryptData(m, webAuthnRefHex, WEBAUTHN_DEVICE_SHARE);\n  if (data) return data[subspace];\n  return null;\n}\n\nexport { decryptData, MetadataStorageLayer as default, ec, encParamsBufToHex, encParamsHexToBuf, encryptAndSetData, encryptData, getAndDecryptData, getDeviceShare, getTorusShare, keccak256, setDeviceShare, setTorusShare };","map":{"version":3,"sources":["../src/utils.ts","../src/MetadataStorageLayer.ts","../src/webAuthnShareResolver.ts"],"names":["keccak256","a","createKeccakHash","update","digest","ec","EC","MetadataStorageLayer","constructor","metadataHost","serverTimeOffset","setAPIKey","apiKey","setEmbedHost","embedHost","generateMetadataParams","message","privateKeyHex","key","keyFromPrivate","setData","data","timestamp","Math","floor","Date","now","toString","sig","sign","stringify","pub_key_X","getPublic","getX","pub_key_Y","getY","set_data","signature","Buffer","from","r","s","recoveryParam","padStart","slice","generatePubKeyParams","setMetadata","namespace","options","params","metadataResponse","post","useAPIKey","getMetadata","pubKey","WEBAUTHN_TORUS_SHARE","WEBAUTHN_DEVICE_SHARE","encParamsHexToBuf","encParamsHex","iv","ephemPublicKey","ciphertext","mac","encParamsBufToHex","encParams","encryptData","privKeyHex","d","serializedDec","JSON","serializedBuf","encrypt","sData","decryptData","parse","keyPair","decrypt","getPrivate","getAndDecryptData","m","serializedData","encryptAndSetData","metadataParams","setTorusShare","webAuthnPubKey","webAuthnRefHex","subspace","subspaceData","refKeyPair","privKey","keyFromPublic","x","y","serializedSubspaceData","serializedSubspaceDataBuf","encSubspaceData","encSubspaceDataHex","setDeviceShare","getTorusShare","webAuthnKeyHex","getDeviceShare"],"mappings":"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","sourcesContent":["import _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport { setAPIKey, setEmbedHost, post } from '@toruslabs/http-helpers';\nimport stringify from 'json-stable-stringify';\nimport { ec as ec$1 } from 'elliptic';\nimport createKeccakHash from 'keccak';\nimport { encrypt, getPublic, decrypt } from '@toruslabs/eccrypto';\n\nfunction keccak256(a) {\n  return createKeccakHash(\"keccak256\").update(a).digest();\n}\nconst ec = new ec$1(\"secp256k1\");\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nclass MetadataStorageLayer {\n  // ms\n  constructor() {\n    let metadataHost = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"https://metadata.tor.us\";\n    let serverTimeOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    _defineProperty(this, \"metadataHost\", void 0);\n    _defineProperty(this, \"serverTimeOffset\", void 0);\n    this.metadataHost = metadataHost;\n    this.serverTimeOffset = serverTimeOffset;\n  }\n  static setAPIKey(apiKey) {\n    setAPIKey(apiKey);\n  }\n  static setEmbedHost(embedHost) {\n    setEmbedHost(embedHost);\n  }\n  generateMetadataParams(message, privateKeyHex) {\n    const key = ec.keyFromPrivate(privateKeyHex, \"hex\");\n    const setData = {\n      data: message,\n      timestamp: Math.floor(this.serverTimeOffset + Date.now() / 1000).toString(16)\n    };\n    const sig = key.sign(keccak256(stringify(setData)));\n    return {\n      pub_key_X: key.getPublic().getX().toString(\"hex\"),\n      pub_key_Y: key.getPublic().getY().toString(\"hex\"),\n      set_data: setData,\n      signature: Buffer.from(sig.r.toString(16, 64) + sig.s.toString(16, 64) + (sig.recoveryParam?.toString(16).padStart(2, \"0\").slice(-2) ?? \"00\"), \"hex\").toString(\"base64\")\n    };\n  }\n  generatePubKeyParams(privateKeyHex) {\n    const key = ec.keyFromPrivate(privateKeyHex, \"hex\");\n    return {\n      pub_key_X: key.getPublic().getX().toString(\"hex\"),\n      pub_key_Y: key.getPublic().getY().toString(\"hex\")\n    };\n  }\n  async setMetadata(data, namespace, options) {\n    const params = namespace !== null ? _objectSpread(_objectSpread({}, data), {}, {\n      namespace\n    }) : data;\n    const metadataResponse = await post(`${this.metadataHost}/set`, params, options, {\n      useAPIKey: true\n    });\n    return metadataResponse.message;\n  }\n  async getMetadata(pubKey, namespace, options) {\n    const params = namespace !== null ? _objectSpread(_objectSpread({}, pubKey), {}, {\n      namespace\n    }) : pubKey;\n    const metadataResponse = await post(`${this.metadataHost}/get`, params, options, {\n      useAPIKey: true\n    });\n    return metadataResponse.message;\n  }\n}\n\nconst WEBAUTHN_TORUS_SHARE = \"webauthn_torus_share\";\nconst WEBAUTHN_DEVICE_SHARE = \"webauthn_device_share\";\nfunction encParamsHexToBuf(encParamsHex) {\n  return {\n    iv: Buffer.from(encParamsHex.iv, \"hex\"),\n    ephemPublicKey: Buffer.from(encParamsHex.ephemPublicKey, \"hex\"),\n    ciphertext: Buffer.from(encParamsHex.ciphertext, \"hex\"),\n    mac: Buffer.from(encParamsHex.mac, \"hex\")\n  };\n}\nfunction encParamsBufToHex(encParams) {\n  return {\n    iv: Buffer.from(encParams.iv).toString(\"hex\"),\n    ephemPublicKey: Buffer.from(encParams.ephemPublicKey).toString(\"hex\"),\n    ciphertext: Buffer.from(encParams.ciphertext).toString(\"hex\"),\n    mac: Buffer.from(encParams.mac).toString(\"hex\")\n  };\n}\nasync function encryptData(privKeyHex, d) {\n  const serializedDec = JSON.stringify(d);\n  const serializedBuf = Buffer.from(serializedDec, \"utf-8\");\n  const encParams = await encrypt(getPublic(Buffer.from(privKeyHex, \"hex\")), serializedBuf);\n  const encParamsHex = encParamsBufToHex(encParams);\n  const sData = JSON.stringify(encParamsHex);\n  return sData;\n}\nasync function decryptData(privKeyHex, d) {\n  const encParamsHex = JSON.parse(d);\n  const encParams = encParamsHexToBuf(encParamsHex);\n  const keyPair = ec.keyFromPrivate(privKeyHex);\n  const serializedBuf = await decrypt(Buffer.from(keyPair.getPrivate().toString(\"hex\", 64), \"hex\"), encParams);\n  const serializedDec = serializedBuf.toString(\"utf-8\");\n  const data = JSON.parse(serializedDec);\n  return data;\n}\nasync function getAndDecryptData(m, privKeyHex, namespace) {\n  const keyPair = ec.keyFromPrivate(privKeyHex);\n  const pubKey = keyPair.getPublic();\n  const serializedData = await m.getMetadata({\n    pub_key_X: pubKey.getX().toString(16),\n    pub_key_Y: pubKey.getY().toString(16)\n  }, namespace);\n  if (!serializedData) {\n    return null;\n  }\n  const data = await decryptData(privKeyHex, serializedData);\n  return data;\n}\nasync function encryptAndSetData(m, privKeyHex, d, namespace) {\n  const sData = await encryptData(privKeyHex, d);\n  const metadataParams = m.generateMetadataParams(sData, privKeyHex);\n  await m.setMetadata(metadataParams, namespace);\n}\nasync function setTorusShare(m, webAuthnPubKey, webAuthnRefHex, subspace, subspaceData) {\n  const refKeyPair = ec.keyFromPrivate(webAuthnRefHex);\n  const privKey = refKeyPair.getPrivate();\n  const pubKey = ec.keyFromPublic({\n    x: webAuthnPubKey.pub_key_X,\n    y: webAuthnPubKey.pub_key_Y\n  });\n  const data = await getAndDecryptData(m, webAuthnRefHex, WEBAUTHN_TORUS_SHARE);\n  let d = {};\n  if (data) d = data;\n  const serializedSubspaceData = JSON.stringify(subspaceData);\n  const serializedSubspaceDataBuf = Buffer.from(serializedSubspaceData, \"utf-8\");\n  const encSubspaceData = await encrypt(Buffer.from(pubKey.getPublic(\"hex\"), \"hex\"), serializedSubspaceDataBuf);\n  const encSubspaceDataHex = encParamsBufToHex(encSubspaceData);\n  d[subspace] = encSubspaceDataHex;\n  await encryptAndSetData(m, privKey.toString(\"hex\", 64), d, WEBAUTHN_TORUS_SHARE);\n}\nasync function setDeviceShare(m, webAuthnRefHex, subspace, subspaceData) {\n  const keyPair = ec.keyFromPrivate(webAuthnRefHex);\n  const privKey = keyPair.getPrivate();\n  const data = await getAndDecryptData(m, webAuthnRefHex, WEBAUTHN_DEVICE_SHARE);\n  let d = {};\n  if (data) d = data;\n  d[subspace] = subspaceData;\n  await encryptAndSetData(m, privKey.toString(\"hex\", 64), d, WEBAUTHN_DEVICE_SHARE);\n}\nasync function getTorusShare(m, webAuthnKeyHex, webAuthnRefHex, subspace) {\n  const data = await getAndDecryptData(m, webAuthnRefHex, WEBAUTHN_TORUS_SHARE);\n  if (!data) return null;\n  const encParamsHex = data[subspace];\n  if (!encParamsHex) return null;\n  const encParams = encParamsHexToBuf(encParamsHex);\n  const keyPair = ec.keyFromPrivate(webAuthnKeyHex);\n  const privKey = keyPair.getPrivate();\n  const serializedSubspaceDataBuf = await decrypt(Buffer.from(privKey.toString(\"hex\", 64), \"hex\"), encParams);\n  const serializedSubspaceData = serializedSubspaceDataBuf.toString(\"utf-8\");\n  const subspaceData = JSON.parse(serializedSubspaceData);\n  return subspaceData;\n}\nasync function getDeviceShare(m, webAuthnRefHex, subspace) {\n  const data = await getAndDecryptData(m, webAuthnRefHex, WEBAUTHN_DEVICE_SHARE);\n  if (data) return data[subspace];\n  return null;\n}\n\nexport { decryptData, MetadataStorageLayer as default, ec, encParamsBufToHex, encParamsHexToBuf, encryptAndSetData, encryptData, getAndDecryptData, getDeviceShare, getTorusShare, keccak256, setDeviceShare, setTorusShare };\n//# sourceMappingURL=metadataHelpers.esm.js.map\n"]},"metadata":{},"sourceType":"module"}