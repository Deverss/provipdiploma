{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.extractPublicKey = exports.recoverPersonalSignature = exports.personalSign = void 0;\n\nconst util_1 = require(\"@ethereumjs/util\");\n\nconst utils_1 = require(\"./utils\");\n/**\n * Create an Ethereum-specific signature for a message.\n *\n * This function is equivalent to the `eth_sign` Ethereum JSON-RPC method as specified in EIP-1417,\n * as well as the MetaMask's `personal_sign` method.\n *\n * @param options - The personal sign options.\n * @param options.privateKey - The key to sign with.\n * @param options.data - The hex data to sign.\n * @returns The '0x'-prefixed hex encoded signature.\n */\n\n\nfunction personalSign({\n  privateKey,\n  data\n}) {\n  if ((0, utils_1.isNullish)(data)) {\n    throw new Error('Missing data parameter');\n  } else if ((0, utils_1.isNullish)(privateKey)) {\n    throw new Error('Missing privateKey parameter');\n  }\n\n  const message = (0, utils_1.legacyToBuffer)(data);\n  const msgHash = (0, util_1.hashPersonalMessage)(message);\n  const sig = (0, util_1.ecsign)(msgHash, privateKey);\n  const serialized = (0, utils_1.concatSig)((0, util_1.toBuffer)(sig.v), sig.r, sig.s);\n  return serialized;\n}\n\nexports.personalSign = personalSign;\n/**\n * Recover the address of the account used to create the given Ethereum signature. The message\n * must have been signed using the `personalSign` function, or an equivalent function.\n *\n * @param options - The signature recovery options.\n * @param options.data - The hex data that was signed.\n * @param options.signature - The '0x'-prefixed hex encoded message signature.\n * @returns The '0x'-prefixed hex encoded address of the message signer.\n */\n\nfunction recoverPersonalSignature({\n  data,\n  signature\n}) {\n  if ((0, utils_1.isNullish)(data)) {\n    throw new Error('Missing data parameter');\n  } else if ((0, utils_1.isNullish)(signature)) {\n    throw new Error('Missing signature parameter');\n  }\n\n  const publicKey = getPublicKeyFor(data, signature);\n  const sender = (0, util_1.publicToAddress)(publicKey);\n  const senderHex = (0, util_1.bufferToHex)(sender);\n  return senderHex;\n}\n\nexports.recoverPersonalSignature = recoverPersonalSignature;\n/**\n * Recover the public key of the account used to create the given Ethereum signature. The message\n * must have been signed using the `personalSign` function, or an equivalent function.\n *\n * @param options - The public key recovery options.\n * @param options.data - The hex data that was signed.\n * @param options.signature - The '0x'-prefixed hex encoded message signature.\n * @returns The '0x'-prefixed hex encoded public key of the message signer.\n */\n\nfunction extractPublicKey({\n  data,\n  signature\n}) {\n  if ((0, utils_1.isNullish)(data)) {\n    throw new Error('Missing data parameter');\n  } else if ((0, utils_1.isNullish)(signature)) {\n    throw new Error('Missing signature parameter');\n  }\n\n  const publicKey = getPublicKeyFor(data, signature);\n  return `0x${publicKey.toString('hex')}`;\n}\n\nexports.extractPublicKey = extractPublicKey;\n/**\n * Get the public key for the given signature and message.\n *\n * @param message - The message that was signed.\n * @param signature - The '0x'-prefixed hex encoded message signature.\n * @returns The public key of the signer.\n */\n\nfunction getPublicKeyFor(message, signature) {\n  const messageHash = (0, util_1.hashPersonalMessage)((0, utils_1.legacyToBuffer)(message));\n  return (0, utils_1.recoverPublicKey)(messageHash, signature);\n}","map":{"version":3,"sources":["../src/personal-sign.ts"],"names":[],"mappings":";;;;;;;AAAA,MAAA,MAAA,GAAA,OAAA,CAAA,kBAAA,CAAA;;AASA,MAAA,OAAA,GAAA,OAAA,CAAA,SAAA,CAAA;AAOA;;;;;;;;;;AAUG;;;AACH,SAAgB,YAAhB,CAA6B;AAC3B,EAAA,UAD2B;AAE3B,EAAA;AAF2B,CAA7B,EAMC;AACC,MAAI,CAAA,GAAA,OAAA,CAAA,SAAA,EAAU,IAAV,CAAJ,EAAqB;AACnB,UAAM,IAAI,KAAJ,CAAU,wBAAV,CAAN;AACD,GAFD,MAEO,IAAI,CAAA,GAAA,OAAA,CAAA,SAAA,EAAU,UAAV,CAAJ,EAA2B;AAChC,UAAM,IAAI,KAAJ,CAAU,8BAAV,CAAN;AACD;;AAED,QAAM,OAAO,GAAG,CAAA,GAAA,OAAA,CAAA,cAAA,EAAe,IAAf,CAAhB;AACA,QAAM,OAAO,GAAG,CAAA,GAAA,MAAA,CAAA,mBAAA,EAAoB,OAApB,CAAhB;AACA,QAAM,GAAG,GAAG,CAAA,GAAA,MAAA,CAAA,MAAA,EAAO,OAAP,EAAgB,UAAhB,CAAZ;AACA,QAAM,UAAU,GAAG,CAAA,GAAA,OAAA,CAAA,SAAA,EAAU,CAAA,GAAA,MAAA,CAAA,QAAA,EAAS,GAAG,CAAC,CAAb,CAAV,EAA2B,GAAG,CAAC,CAA/B,EAAkC,GAAG,CAAC,CAAtC,CAAnB;AACA,SAAO,UAAP;AACD;;AAlBD,OAAA,CAAA,YAAA,GAAA,YAAA;AAoBA;;;;;;;;AAQG;;AACH,SAAgB,wBAAhB,CAAyC;AACvC,EAAA,IADuC;AAEvC,EAAA;AAFuC,CAAzC,EAMC;AACC,MAAI,CAAA,GAAA,OAAA,CAAA,SAAA,EAAU,IAAV,CAAJ,EAAqB;AACnB,UAAM,IAAI,KAAJ,CAAU,wBAAV,CAAN;AACD,GAFD,MAEO,IAAI,CAAA,GAAA,OAAA,CAAA,SAAA,EAAU,SAAV,CAAJ,EAA0B;AAC/B,UAAM,IAAI,KAAJ,CAAU,6BAAV,CAAN;AACD;;AAED,QAAM,SAAS,GAAG,eAAe,CAAC,IAAD,EAAO,SAAP,CAAjC;AACA,QAAM,MAAM,GAAG,CAAA,GAAA,MAAA,CAAA,eAAA,EAAgB,SAAhB,CAAf;AACA,QAAM,SAAS,GAAG,CAAA,GAAA,MAAA,CAAA,WAAA,EAAY,MAAZ,CAAlB;AACA,SAAO,SAAP;AACD;;AAjBD,OAAA,CAAA,wBAAA,GAAA,wBAAA;AAmBA;;;;;;;;AAQG;;AACH,SAAgB,gBAAhB,CAAiC;AAC/B,EAAA,IAD+B;AAE/B,EAAA;AAF+B,CAAjC,EAMC;AACC,MAAI,CAAA,GAAA,OAAA,CAAA,SAAA,EAAU,IAAV,CAAJ,EAAqB;AACnB,UAAM,IAAI,KAAJ,CAAU,wBAAV,CAAN;AACD,GAFD,MAEO,IAAI,CAAA,GAAA,OAAA,CAAA,SAAA,EAAU,SAAV,CAAJ,EAA0B;AAC/B,UAAM,IAAI,KAAJ,CAAU,6BAAV,CAAN;AACD;;AAED,QAAM,SAAS,GAAG,eAAe,CAAC,IAAD,EAAO,SAAP,CAAjC;AACA,SAAO,KAAK,SAAS,CAAC,QAAV,CAAmB,KAAnB,CAAyB,EAArC;AACD;;AAfD,OAAA,CAAA,gBAAA,GAAA,gBAAA;AAiBA;;;;;;AAMG;;AACH,SAAS,eAAT,CACE,OADF,EAEE,SAFF,EAEmB;AAEjB,QAAM,WAAW,GAAG,CAAA,GAAA,MAAA,CAAA,mBAAA,EAAoB,CAAA,GAAA,OAAA,CAAA,cAAA,EAAe,OAAf,CAApB,CAApB;AACA,SAAO,CAAA,GAAA,OAAA,CAAA,gBAAA,EAAiB,WAAjB,EAA8B,SAA9B,CAAP;AACD","sourcesContent":["import {\n  bufferToHex,\n  ecsign,\n  hashPersonalMessage,\n  publicToAddress,\n  toBuffer,\n  ToBufferInputTypes,\n} from '@ethereumjs/util';\n\nimport {\n  concatSig,\n  isNullish,\n  legacyToBuffer,\n  recoverPublicKey,\n} from './utils';\n\n/**\n * Create an Ethereum-specific signature for a message.\n *\n * This function is equivalent to the `eth_sign` Ethereum JSON-RPC method as specified in EIP-1417,\n * as well as the MetaMask's `personal_sign` method.\n *\n * @param options - The personal sign options.\n * @param options.privateKey - The key to sign with.\n * @param options.data - The hex data to sign.\n * @returns The '0x'-prefixed hex encoded signature.\n */\nexport function personalSign({\n  privateKey,\n  data,\n}: {\n  privateKey: Buffer;\n  data: ToBufferInputTypes;\n}): string {\n  if (isNullish(data)) {\n    throw new Error('Missing data parameter');\n  } else if (isNullish(privateKey)) {\n    throw new Error('Missing privateKey parameter');\n  }\n\n  const message = legacyToBuffer(data);\n  const msgHash = hashPersonalMessage(message);\n  const sig = ecsign(msgHash, privateKey);\n  const serialized = concatSig(toBuffer(sig.v), sig.r, sig.s);\n  return serialized;\n}\n\n/**\n * Recover the address of the account used to create the given Ethereum signature. The message\n * must have been signed using the `personalSign` function, or an equivalent function.\n *\n * @param options - The signature recovery options.\n * @param options.data - The hex data that was signed.\n * @param options.signature - The '0x'-prefixed hex encoded message signature.\n * @returns The '0x'-prefixed hex encoded address of the message signer.\n */\nexport function recoverPersonalSignature({\n  data,\n  signature,\n}: {\n  data: ToBufferInputTypes;\n  signature: string;\n}): string {\n  if (isNullish(data)) {\n    throw new Error('Missing data parameter');\n  } else if (isNullish(signature)) {\n    throw new Error('Missing signature parameter');\n  }\n\n  const publicKey = getPublicKeyFor(data, signature);\n  const sender = publicToAddress(publicKey);\n  const senderHex = bufferToHex(sender);\n  return senderHex;\n}\n\n/**\n * Recover the public key of the account used to create the given Ethereum signature. The message\n * must have been signed using the `personalSign` function, or an equivalent function.\n *\n * @param options - The public key recovery options.\n * @param options.data - The hex data that was signed.\n * @param options.signature - The '0x'-prefixed hex encoded message signature.\n * @returns The '0x'-prefixed hex encoded public key of the message signer.\n */\nexport function extractPublicKey({\n  data,\n  signature,\n}: {\n  data: ToBufferInputTypes;\n  signature: string;\n}): string {\n  if (isNullish(data)) {\n    throw new Error('Missing data parameter');\n  } else if (isNullish(signature)) {\n    throw new Error('Missing signature parameter');\n  }\n\n  const publicKey = getPublicKeyFor(data, signature);\n  return `0x${publicKey.toString('hex')}`;\n}\n\n/**\n * Get the public key for the given signature and message.\n *\n * @param message - The message that was signed.\n * @param signature - The '0x'-prefixed hex encoded message signature.\n * @returns The public key of the signer.\n */\nfunction getPublicKeyFor(\n  message: ToBufferInputTypes,\n  signature: string,\n): Buffer {\n  const messageHash = hashPersonalMessage(legacyToBuffer(message));\n  return recoverPublicKey(messageHash, signature);\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}