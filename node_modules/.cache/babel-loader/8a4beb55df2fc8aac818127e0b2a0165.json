{"ast":null,"code":"\"use strict\";\n/**\n * Ported to Typescript from original implementation below:\n * https://github.com/ahultgren/async-eventemitter -- MIT licensed\n *\n * Type Definitions based on work by: patarapolw <https://github.com/patarapolw> -- MIT licensed\n * that was contributed to Definitely Typed below:\n * https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/async-eventemitter\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.AsyncEventEmitter = void 0;\n\nconst events_1 = require(\"events\");\n\nasync function runInSeries(context, tasks, data) {\n  let error;\n\n  for await (const task of tasks) {\n    try {\n      if (task.length < 2) {\n        //sync\n        task.call(context, data);\n      } else {\n        await new Promise((resolve, reject) => {\n          task.call(context, data, error => {\n            if (error) {\n              reject(error);\n            } else {\n              resolve();\n            }\n          });\n        });\n      }\n    } catch (e) {\n      error = e;\n    }\n  }\n\n  if (error) {\n    throw error;\n  }\n}\n\nclass AsyncEventEmitter extends events_1.EventEmitter {\n  emit(event, ...args) {\n    let [data, callback] = args;\n    const self = this;\n    let listeners = self._events[event] ?? []; // Optional data argument\n\n    if (callback === undefined && typeof data === 'function') {\n      callback = data;\n      data = undefined;\n    } // Special treatment of internal newListener and removeListener events\n\n\n    if (event === 'newListener' || event === 'removeListener') {\n      data = {\n        event: data,\n        fn: callback\n      };\n      callback = undefined;\n    } // A single listener is just a function not an array...\n\n\n    listeners = Array.isArray(listeners) ? listeners : [listeners];\n    runInSeries(self, listeners.slice(), data).then(callback).catch(callback);\n    return self.listenerCount(event) > 0;\n  }\n\n  once(event, listener) {\n    const self = this;\n    let g;\n\n    if (typeof listener !== 'function') {\n      throw new TypeError('listener must be a function');\n    } // Hack to support set arity\n\n\n    if (listener.length >= 2) {\n      g = function (e, next) {\n        self.removeListener(event, g);\n        void listener(e, next);\n      };\n    } else {\n      g = function (e) {\n        self.removeListener(event, g);\n        void listener(e, g);\n      };\n    }\n\n    self.on(event, g);\n    return self;\n  }\n\n  first(event, listener) {\n    let listeners = this._events[event] ?? []; // Contract\n\n    if (typeof listener !== 'function') {\n      throw new TypeError('listener must be a function');\n    } // Listeners are not always an array\n\n\n    if (!Array.isArray(listeners)) {\n      ;\n      this._events[event] = listeners = [listeners];\n    }\n\n    listeners.unshift(listener);\n    return this;\n  }\n\n  before(event, target, listener) {\n    return this.beforeOrAfter(event, target, listener);\n  }\n\n  after(event, target, listener) {\n    return this.beforeOrAfter(event, target, listener, 'after');\n  }\n\n  beforeOrAfter(event, target, listener, beforeOrAfter) {\n    let listeners = this._events[event] ?? [];\n    let i;\n    let index;\n    const add = beforeOrAfter === 'after' ? 1 : 0; // Contract\n\n    if (typeof listener !== 'function') {\n      throw new TypeError('listener must be a function');\n    }\n\n    if (typeof target !== 'function') {\n      throw new TypeError('target must be a function');\n    } // Listeners are not always an array\n\n\n    if (!Array.isArray(listeners)) {\n      ;\n      this._events[event] = listeners = [listeners];\n    }\n\n    index = listeners.length;\n\n    for (i = listeners.length; i--;) {\n      if (listeners[i] === target) {\n        index = i + add;\n        break;\n      }\n    }\n\n    listeners.splice(index, 0, listener);\n    return this;\n  }\n\n  on(event, listener) {\n    return super.on(event, listener);\n  }\n\n  addListener(event, listener) {\n    return super.addListener(event, listener);\n  }\n\n  prependListener(event, listener) {\n    return super.prependListener(event, listener);\n  }\n\n  prependOnceListener(event, listener) {\n    return super.prependOnceListener(event, listener);\n  }\n\n  removeAllListeners(event) {\n    return super.removeAllListeners(event);\n  }\n\n  removeListener(event, listener) {\n    return super.removeListener(event, listener);\n  }\n\n  eventNames() {\n    return super.eventNames();\n  }\n\n  listeners(event) {\n    return super.listeners(event);\n  }\n\n  listenerCount(event) {\n    return super.listenerCount(event);\n  }\n\n  getMaxListeners() {\n    return super.getMaxListeners();\n  }\n\n  setMaxListeners(maxListeners) {\n    return super.setMaxListeners(maxListeners);\n  }\n\n}\n\nexports.AsyncEventEmitter = AsyncEventEmitter;","map":{"version":3,"sources":["../src/asyncEventEmitter.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n/**\n * Ported to Typescript from original implementation below:\n * https://github.com/ahultgren/async-eventemitter -- MIT licensed\n *\n * Type Definitions based on work by: patarapolw <https://github.com/patarapolw> -- MIT licensed\n * that was contributed to Definitely Typed below:\n * https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/async-eventemitter\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.AsyncEventEmitter = void 0;\nconst events_1 = require(\"events\");\nasync function runInSeries(context, tasks, data) {\n    let error;\n    for await (const task of tasks) {\n        try {\n            if (task.length < 2) {\n                //sync\n                task.call(context, data);\n            }\n            else {\n                await new Promise((resolve, reject) => {\n                    task.call(context, data, (error) => {\n                        if (error) {\n                            reject(error);\n                        }\n                        else {\n                            resolve();\n                        }\n                    });\n                });\n            }\n        }\n        catch (e) {\n            error = e;\n        }\n    }\n    if (error) {\n        throw error;\n    }\n}\nclass AsyncEventEmitter extends events_1.EventEmitter {\n    emit(event, ...args) {\n        let [data, callback] = args;\n        const self = this;\n        let listeners = self._events[event] ?? [];\n        // Optional data argument\n        if (callback === undefined && typeof data === 'function') {\n            callback = data;\n            data = undefined;\n        }\n        // Special treatment of internal newListener and removeListener events\n        if (event === 'newListener' || event === 'removeListener') {\n            data = {\n                event: data,\n                fn: callback,\n            };\n            callback = undefined;\n        }\n        // A single listener is just a function not an array...\n        listeners = Array.isArray(listeners) ? listeners : [listeners];\n        runInSeries(self, listeners.slice(), data).then(callback).catch(callback);\n        return self.listenerCount(event) > 0;\n    }\n    once(event, listener) {\n        const self = this;\n        let g;\n        if (typeof listener !== 'function') {\n            throw new TypeError('listener must be a function');\n        }\n        // Hack to support set arity\n        if (listener.length >= 2) {\n            g = function (e, next) {\n                self.removeListener(event, g);\n                void listener(e, next);\n            };\n        }\n        else {\n            g = function (e) {\n                self.removeListener(event, g);\n                void listener(e, g);\n            };\n        }\n        self.on(event, g);\n        return self;\n    }\n    first(event, listener) {\n        let listeners = this._events[event] ?? [];\n        // Contract\n        if (typeof listener !== 'function') {\n            throw new TypeError('listener must be a function');\n        }\n        // Listeners are not always an array\n        if (!Array.isArray(listeners)) {\n            ;\n            this._events[event] = listeners = [listeners];\n        }\n        listeners.unshift(listener);\n        return this;\n    }\n    before(event, target, listener) {\n        return this.beforeOrAfter(event, target, listener);\n    }\n    after(event, target, listener) {\n        return this.beforeOrAfter(event, target, listener, 'after');\n    }\n    beforeOrAfter(event, target, listener, beforeOrAfter) {\n        let listeners = this._events[event] ?? [];\n        let i;\n        let index;\n        const add = beforeOrAfter === 'after' ? 1 : 0;\n        // Contract\n        if (typeof listener !== 'function') {\n            throw new TypeError('listener must be a function');\n        }\n        if (typeof target !== 'function') {\n            throw new TypeError('target must be a function');\n        }\n        // Listeners are not always an array\n        if (!Array.isArray(listeners)) {\n            ;\n            this._events[event] = listeners = [listeners];\n        }\n        index = listeners.length;\n        for (i = listeners.length; i--;) {\n            if (listeners[i] === target) {\n                index = i + add;\n                break;\n            }\n        }\n        listeners.splice(index, 0, listener);\n        return this;\n    }\n    on(event, listener) {\n        return super.on(event, listener);\n    }\n    addListener(event, listener) {\n        return super.addListener(event, listener);\n    }\n    prependListener(event, listener) {\n        return super.prependListener(event, listener);\n    }\n    prependOnceListener(event, listener) {\n        return super.prependOnceListener(event, listener);\n    }\n    removeAllListeners(event) {\n        return super.removeAllListeners(event);\n    }\n    removeListener(event, listener) {\n        return super.removeListener(event, listener);\n    }\n    eventNames() {\n        return super.eventNames();\n    }\n    listeners(event) {\n        return super.listeners(event);\n    }\n    listenerCount(event) {\n        return super.listenerCount(event);\n    }\n    getMaxListeners() {\n        return super.getMaxListeners();\n    }\n    setMaxListeners(maxListeners) {\n        return super.setMaxListeners(maxListeners);\n    }\n}\nexports.AsyncEventEmitter = AsyncEventEmitter;\n//# sourceMappingURL=asyncEventEmitter.js.map"]},"metadata":{},"sourceType":"script"}