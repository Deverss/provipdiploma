{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Common = void 0;\n\nconst util_1 = require(\"@ethereumjs/util\");\n\nconst crc_32_1 = require(\"crc-32\");\n\nconst events_1 = require(\"events\");\n\nconst goerli = require(\"./chains/goerli.json\");\n\nconst mainnet = require(\"./chains/mainnet.json\");\n\nconst rinkeby = require(\"./chains/rinkeby.json\");\n\nconst ropsten = require(\"./chains/ropsten.json\");\n\nconst sepolia = require(\"./chains/sepolia.json\");\n\nconst eips_1 = require(\"./eips\");\n\nconst enums_1 = require(\"./enums\");\n\nconst hardforks_1 = require(\"./hardforks\");\n\nconst utils_1 = require(\"./utils\");\n/**\n * Common class to access chain and hardfork parameters and to provide\n * a unified and shared view on the network and hardfork state.\n *\n * Use the {@link Common.custom} static constructor for creating simple\n * custom chain {@link Common} objects (more complete custom chain setups\n * can be created via the main constructor and the {@link CommonOpts.customChains} parameter).\n */\n\n\nclass Common extends events_1.EventEmitter {\n  constructor(opts) {\n    super();\n    this._eips = [];\n    this._customChains = opts.customChains ?? [];\n    this._chainParams = this.setChain(opts.chain);\n    this.DEFAULT_HARDFORK = this._chainParams.defaultHardfork ?? enums_1.Hardfork.Merge; // Assign hardfork changes in the sequence of the applied hardforks\n\n    this.HARDFORK_CHANGES = this.hardforks().map(hf => [hf.name, hardforks_1.hardforks[hf.name]]);\n    this._hardfork = this.DEFAULT_HARDFORK;\n\n    if (opts.hardfork !== undefined) {\n      this.setHardfork(opts.hardfork);\n    }\n\n    if (opts.eips) {\n      this.setEIPs(opts.eips);\n    }\n  }\n  /**\n   * Creates a {@link Common} object for a custom chain, based on a standard one.\n   *\n   * It uses all the {@link Chain} parameters from the {@link baseChain} option except the ones overridden\n   * in a provided {@link chainParamsOrName} dictionary. Some usage example:\n   *\n   * ```javascript\n   * Common.custom({chainId: 123})\n   * ```\n   *\n   * There are also selected supported custom chains which can be initialized by using one of the\n   * {@link CustomChains} for {@link chainParamsOrName}, e.g.:\n   *\n   * ```javascript\n   * Common.custom(CustomChains.MaticMumbai)\n   * ```\n   *\n   * Note that these supported custom chains only provide some base parameters (usually the chain and\n   * network ID and a name) and can only be used for selected use cases (e.g. sending a tx with\n   * the `@ethereumjs/tx` library to a Layer-2 chain).\n   *\n   * @param chainParamsOrName Custom parameter dict (`name` will default to `custom-chain`) or string with name of a supported custom chain\n   * @param opts Custom chain options to set the {@link CustomCommonOpts.baseChain}, selected {@link CustomCommonOpts.hardfork} and others\n   */\n\n\n  static custom(chainParamsOrName, opts = {}) {\n    const baseChain = opts.baseChain ?? 'mainnet';\n    const standardChainParams = { ...Common._getChainParams(baseChain)\n    };\n    standardChainParams['name'] = 'custom-chain';\n\n    if (typeof chainParamsOrName !== 'string') {\n      return new Common({\n        chain: { ...standardChainParams,\n          ...chainParamsOrName\n        },\n        ...opts\n      });\n    } else {\n      if (chainParamsOrName === enums_1.CustomChain.PolygonMainnet) {\n        return Common.custom({\n          name: enums_1.CustomChain.PolygonMainnet,\n          chainId: 137,\n          networkId: 137\n        }, opts);\n      }\n\n      if (chainParamsOrName === enums_1.CustomChain.PolygonMumbai) {\n        return Common.custom({\n          name: enums_1.CustomChain.PolygonMumbai,\n          chainId: 80001,\n          networkId: 80001\n        }, opts);\n      }\n\n      if (chainParamsOrName === enums_1.CustomChain.ArbitrumRinkebyTestnet) {\n        return Common.custom({\n          name: enums_1.CustomChain.ArbitrumRinkebyTestnet,\n          chainId: 421611,\n          networkId: 421611\n        }, opts);\n      }\n\n      if (chainParamsOrName === enums_1.CustomChain.ArbitrumOne) {\n        return Common.custom({\n          name: enums_1.CustomChain.ArbitrumOne,\n          chainId: 42161,\n          networkId: 42161\n        }, opts);\n      }\n\n      if (chainParamsOrName === enums_1.CustomChain.xDaiChain) {\n        return Common.custom({\n          name: enums_1.CustomChain.xDaiChain,\n          chainId: 100,\n          networkId: 100\n        }, opts);\n      }\n\n      if (chainParamsOrName === enums_1.CustomChain.OptimisticKovan) {\n        return Common.custom({\n          name: enums_1.CustomChain.OptimisticKovan,\n          chainId: 69,\n          networkId: 69\n        }, // Optimism has not implemented the London hardfork yet (targeting Q1.22)\n        {\n          hardfork: enums_1.Hardfork.Berlin,\n          ...opts\n        });\n      }\n\n      if (chainParamsOrName === enums_1.CustomChain.OptimisticEthereum) {\n        return Common.custom({\n          name: enums_1.CustomChain.OptimisticEthereum,\n          chainId: 10,\n          networkId: 10\n        }, // Optimism has not implemented the London hardfork yet (targeting Q1.22)\n        {\n          hardfork: enums_1.Hardfork.Berlin,\n          ...opts\n        });\n      }\n\n      throw new Error(`Custom chain ${chainParamsOrName} not supported`);\n    }\n  }\n  /**\n   * Static method to load and set common from a geth genesis json\n   * @param genesisJson json of geth configuration\n   * @param { chain, eips, genesisHash, hardfork, mergeForkIdPostMerge } to further configure the common instance\n   * @returns Common\n   */\n\n\n  static fromGethGenesis(genesisJson, {\n    chain,\n    eips,\n    genesisHash,\n    hardfork,\n    mergeForkIdPostMerge\n  }) {\n    const genesisParams = (0, utils_1.parseGethGenesis)(genesisJson, chain, mergeForkIdPostMerge);\n    const common = new Common({\n      chain: genesisParams.name ?? 'custom',\n      customChains: [genesisParams],\n      eips,\n      hardfork: hardfork ?? genesisParams.hardfork\n    });\n\n    if (genesisHash !== undefined) {\n      common.setForkHashes(genesisHash);\n    }\n\n    return common;\n  }\n  /**\n   * Static method to determine if a {@link chainId} is supported as a standard chain\n   * @param chainId bigint id (`1`) of a standard chain\n   * @returns boolean\n   */\n\n\n  static isSupportedChainId(chainId) {\n    const initializedChains = this._getInitializedChains();\n\n    return Boolean(initializedChains['names'][chainId.toString()]);\n  }\n\n  static _getChainParams(chain, customChains) {\n    const initializedChains = this._getInitializedChains(customChains);\n\n    if (typeof chain === 'number' || typeof chain === 'bigint') {\n      chain = chain.toString();\n\n      if (initializedChains['names'][chain]) {\n        const name = initializedChains['names'][chain];\n        return initializedChains[name];\n      }\n\n      throw new Error(`Chain with ID ${chain} not supported`);\n    }\n\n    if (initializedChains[chain] !== undefined) {\n      return initializedChains[chain];\n    }\n\n    throw new Error(`Chain with name ${chain} not supported`);\n  }\n  /**\n   * Sets the chain\n   * @param chain String ('mainnet') or Number (1) chain representation.\n   *              Or, a Dictionary of chain parameters for a private network.\n   * @returns The dictionary with parameters set as chain\n   */\n\n\n  setChain(chain) {\n    if (typeof chain === 'number' || typeof chain === 'bigint' || typeof chain === 'string') {\n      this._chainParams = Common._getChainParams(chain, this._customChains);\n    } else if (typeof chain === 'object') {\n      if (this._customChains.length > 0) {\n        throw new Error('Chain must be a string, number, or bigint when initialized with customChains passed in');\n      }\n\n      const required = ['networkId', 'genesis', 'hardforks', 'bootstrapNodes'];\n\n      for (const param of required) {\n        if (!(param in chain)) {\n          throw new Error(`Missing required chain parameter: ${param}`);\n        }\n      }\n\n      this._chainParams = chain;\n    } else {\n      throw new Error('Wrong input format');\n    }\n\n    for (const hf of this.hardforks()) {\n      if (hf.block === undefined) {\n        throw new Error(`Hardfork cannot have undefined block number`);\n      }\n    }\n\n    return this._chainParams;\n  }\n  /**\n   * Sets the hardfork to get params for\n   * @param hardfork String identifier (e.g. 'byzantium') or {@link Hardfork} enum\n   */\n\n\n  setHardfork(hardfork) {\n    let existing = false;\n\n    for (const hfChanges of this.HARDFORK_CHANGES) {\n      if (hfChanges[0] === hardfork) {\n        if (this._hardfork !== hardfork) {\n          this._hardfork = hardfork;\n          this.emit('hardforkChanged', hardfork);\n        }\n\n        existing = true;\n      }\n    }\n\n    if (!existing) {\n      throw new Error(`Hardfork with name ${hardfork} not supported`);\n    }\n  }\n  /**\n   * Returns the hardfork based on the block number or an optional\n   * total difficulty (Merge HF) provided.\n   *\n   * An optional TD takes precedence in case the corresponding HF block\n   * is set to `null` or otherwise needs to match (if not an error\n   * will be thrown).\n   *\n   * @param blockNumber\n   * @param td : total difficulty of the parent block (for block hf) OR of the chain latest (for chain hf)\n   * @param timestamp: timestamp in seconds at which block was/is to be minted\n   * @returns The name of the HF\n   */\n\n\n  getHardforkByBlockNumber(blockNumber, td, timestamp) {\n    blockNumber = (0, util_1.toType)(blockNumber, util_1.TypeOutput.BigInt);\n    td = (0, util_1.toType)(td, util_1.TypeOutput.BigInt);\n    timestamp = (0, util_1.toType)(timestamp, util_1.TypeOutput.Number); // Filter out hardforks with no block number, no ttd or no timestamp (i.e. unapplied hardforks)\n\n    const hfs = this.hardforks().filter(hf => hf.block !== null || hf.ttd !== null && hf.ttd !== undefined || hf.timestamp !== undefined);\n    const mergeIndex = hfs.findIndex(hf => hf.ttd !== null && hf.ttd !== undefined);\n    const doubleTTDHF = hfs.slice(mergeIndex + 1).findIndex(hf => hf.ttd !== null && hf.ttd !== undefined);\n\n    if (doubleTTDHF >= 0) {\n      throw Error(`More than one merge hardforks found with ttd specified`);\n    } // Find the first hardfork that has a block number greater than `blockNumber`\n    // (skips the merge hardfork since it cannot have a block number specified).\n    // If timestamp is not provided, it also skips timestamps hardforks to continue\n    // discovering/checking number hardforks.\n\n\n    let hfIndex = hfs.findIndex(hf => hf.block !== null && hf.block > blockNumber || timestamp !== undefined && Number(hf.timestamp) > timestamp);\n\n    if (hfIndex === -1) {\n      // all hardforks apply, set hfIndex to the last one as that's the candidate\n      hfIndex = hfs.length;\n    } else if (hfIndex === 0) {\n      // cannot have a case where a block number is before all applied hardforks\n      // since the chain has to start with a hardfork\n      throw Error('Must have at least one hardfork at block 0');\n    } // If timestamp is not provided, we need to rollback to the last hf with block or ttd\n\n\n    if (timestamp === undefined) {\n      const stepBack = hfs.slice(0, hfIndex).reverse().findIndex(hf => hf.block !== null || hf.ttd !== undefined);\n      hfIndex = hfIndex - stepBack;\n    } // Move hfIndex one back to arrive at candidate hardfork\n\n\n    hfIndex = hfIndex - 1; // If the timestamp was not provided, we could have skipped timestamp hardforks to look for number\n    // hardforks. so it will now be needed to rollback\n\n    if (hfs[hfIndex].block === null && hfs[hfIndex].timestamp === undefined) {\n      // We're on the merge hardfork.  Let's check the TTD\n      if (td === undefined || td === null || BigInt(hfs[hfIndex].ttd) > td) {\n        // Merge ttd greater than current td so we're on hardfork before merge\n        hfIndex -= 1;\n      }\n    } else {\n      if (mergeIndex >= 0 && td !== undefined && td !== null) {\n        if (hfIndex >= mergeIndex && BigInt(hfs[mergeIndex].ttd) > td) {\n          throw Error('Maximum HF determined by total difficulty is lower than the block number HF');\n        } else if (hfIndex < mergeIndex && BigInt(hfs[mergeIndex].ttd) <= td) {\n          throw Error('HF determined by block number is lower than the minimum total difficulty HF');\n        }\n      }\n    }\n\n    const hfStartIndex = hfIndex; // Move the hfIndex to the end of the hardforks that might be scheduled on the same block/timestamp\n    // This won't anyway be the case with Merge hfs\n\n    for (; hfIndex < hfs.length - 1; hfIndex++) {\n      // break out if hfIndex + 1 is not scheduled at hfIndex\n      if (hfs[hfIndex].block !== hfs[hfIndex + 1].block || hfs[hfIndex].timestamp !== hfs[hfIndex + 1].timestamp) {\n        break;\n      }\n    }\n\n    if (timestamp) {\n      const minTimeStamp = hfs.slice(0, hfStartIndex).reduce((acc, hf) => Math.max(Number(hf.timestamp ?? '0'), acc), 0);\n\n      if (minTimeStamp > timestamp) {\n        throw Error(`Maximum HF determined by timestamp is lower than the block number/ttd HF`);\n      }\n\n      const maxTimeStamp = hfs.slice(hfIndex + 1).reduce((acc, hf) => Math.min(Number(hf.timestamp ?? timestamp), acc), timestamp);\n\n      if (maxTimeStamp < timestamp) {\n        throw Error(`Maximum HF determined by block number/ttd is lower than timestamp HF`);\n      }\n    }\n\n    const hardfork = hfs[hfIndex];\n    return hardfork.name;\n  }\n  /**\n   * Sets a new hardfork based on the block number or an optional\n   * total difficulty (Merge HF) provided.\n   *\n   * An optional TD takes precedence in case the corresponding HF block\n   * is set to `null` or otherwise needs to match (if not an error\n   * will be thrown).\n   *\n   * @param blockNumber\n   * @param td\n   * @param timestamp\n   * @returns The name of the HF set\n   */\n\n\n  setHardforkByBlockNumber(blockNumber, td, timestamp) {\n    const hardfork = this.getHardforkByBlockNumber(blockNumber, td, timestamp);\n    this.setHardfork(hardfork);\n    return hardfork;\n  }\n  /**\n   * Internal helper function, returns the params for the given hardfork for the chain set\n   * @param hardfork Hardfork name\n   * @returns Dictionary with hardfork params or null if hardfork not on chain\n   */\n\n\n  _getHardfork(hardfork) {\n    const hfs = this.hardforks();\n\n    for (const hf of hfs) {\n      if (hf['name'] === hardfork) return hf;\n    }\n\n    return null;\n  }\n  /**\n   * Sets the active EIPs\n   * @param eips\n   */\n\n\n  setEIPs(eips = []) {\n    for (const eip of eips) {\n      if (!(eip in eips_1.EIPs)) {\n        throw new Error(`${eip} not supported`);\n      }\n\n      const minHF = this.gteHardfork(eips_1.EIPs[eip]['minimumHardfork']);\n\n      if (!minHF) {\n        throw new Error(`${eip} cannot be activated on hardfork ${this.hardfork()}, minimumHardfork: ${minHF}`);\n      }\n\n      if (eips_1.EIPs[eip].requiredEIPs !== undefined) {\n        for (const elem of eips_1.EIPs[eip].requiredEIPs) {\n          if (!(eips.includes(elem) || this.isActivatedEIP(elem))) {\n            throw new Error(`${eip} requires EIP ${elem}, but is not included in the EIP list`);\n          }\n        }\n      }\n    }\n\n    this._eips = eips;\n  }\n  /**\n   * Returns a parameter for the current chain setup\n   *\n   * If the parameter is present in an EIP, the EIP always takes precedence.\n   * Otherwise the parameter if taken from the latest applied HF with\n   * a change on the respective parameter.\n   *\n   * @param topic Parameter topic ('gasConfig', 'gasPrices', 'vm', 'pow')\n   * @param name Parameter name (e.g. 'minGasLimit' for 'gasConfig' topic)\n   * @returns The value requested or `BigInt(0)` if not found\n   */\n\n\n  param(topic, name) {\n    // TODO: consider the case that different active EIPs\n    // can change the same parameter\n    let value;\n\n    for (const eip of this._eips) {\n      value = this.paramByEIP(topic, name, eip);\n      if (value !== undefined) return value;\n    }\n\n    return this.paramByHardfork(topic, name, this._hardfork);\n  }\n  /**\n   * Returns the parameter corresponding to a hardfork\n   * @param topic Parameter topic ('gasConfig', 'gasPrices', 'vm', 'pow')\n   * @param name Parameter name (e.g. 'minGasLimit' for 'gasConfig' topic)\n   * @param hardfork Hardfork name\n   * @returns The value requested or `BigInt(0)` if not found\n   */\n\n\n  paramByHardfork(topic, name, hardfork) {\n    let value = null;\n\n    for (const hfChanges of this.HARDFORK_CHANGES) {\n      // EIP-referencing HF file (e.g. berlin.json)\n      if ('eips' in hfChanges[1]) {\n        const hfEIPs = hfChanges[1]['eips'];\n\n        for (const eip of hfEIPs) {\n          const valueEIP = this.paramByEIP(topic, name, eip);\n          value = typeof valueEIP === 'bigint' ? valueEIP : value;\n        } // Parameter-inlining HF file (e.g. istanbul.json)\n\n      } else {\n        if (hfChanges[1][topic] === undefined) {\n          throw new Error(`Topic ${topic} not defined`);\n        }\n\n        if (hfChanges[1][topic][name] !== undefined) {\n          value = hfChanges[1][topic][name].v;\n        }\n      }\n\n      if (hfChanges[0] === hardfork) break;\n    }\n\n    return BigInt(value ?? 0);\n  }\n  /**\n   * Returns a parameter corresponding to an EIP\n   * @param topic Parameter topic ('gasConfig', 'gasPrices', 'vm', 'pow')\n   * @param name Parameter name (e.g. 'minGasLimit' for 'gasConfig' topic)\n   * @param eip Number of the EIP\n   * @returns The value requested or `undefined` if not found\n   */\n\n\n  paramByEIP(topic, name, eip) {\n    if (!(eip in eips_1.EIPs)) {\n      throw new Error(`${eip} not supported`);\n    }\n\n    const eipParams = eips_1.EIPs[eip];\n\n    if (!(topic in eipParams)) {\n      throw new Error(`Topic ${topic} not defined`);\n    }\n\n    if (eipParams[topic][name] === undefined) {\n      return undefined;\n    }\n\n    const value = eipParams[topic][name].v;\n    return BigInt(value);\n  }\n  /**\n   * Returns a parameter for the hardfork active on block number or\n   * optional provided total difficulty (Merge HF)\n   * @param topic Parameter topic\n   * @param name Parameter name\n   * @param blockNumber Block number\n   * @param td Total difficulty\n   *    * @returns The value requested or `BigInt(0)` if not found\n   */\n\n\n  paramByBlock(topic, name, blockNumber, td, timestamp) {\n    const hardfork = this.getHardforkByBlockNumber(blockNumber, td, timestamp);\n    return this.paramByHardfork(topic, name, hardfork);\n  }\n  /**\n   * Checks if an EIP is activated by either being included in the EIPs\n   * manually passed in with the {@link CommonOpts.eips} or in a\n   * hardfork currently being active\n   *\n   * Note: this method only works for EIPs being supported\n   * by the {@link CommonOpts.eips} constructor option\n   * @param eip\n   */\n\n\n  isActivatedEIP(eip) {\n    if (this.eips().includes(eip)) {\n      return true;\n    }\n\n    for (const hfChanges of this.HARDFORK_CHANGES) {\n      const hf = hfChanges[1];\n\n      if (this.gteHardfork(hf['name']) && 'eips' in hf) {\n        if (hf['eips'].includes(eip)) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }\n  /**\n   * Checks if set or provided hardfork is active on block number\n   * @param hardfork Hardfork name or null (for HF set)\n   * @param blockNumber\n   * @returns True if HF is active on block number\n   */\n\n\n  hardforkIsActiveOnBlock(hardfork, blockNumber) {\n    blockNumber = (0, util_1.toType)(blockNumber, util_1.TypeOutput.BigInt);\n    hardfork = hardfork ?? this._hardfork;\n    const hfBlock = this.hardforkBlock(hardfork);\n\n    if (typeof hfBlock === 'bigint' && hfBlock !== BigInt(0) && blockNumber >= hfBlock) {\n      return true;\n    }\n\n    return false;\n  }\n  /**\n   * Alias to hardforkIsActiveOnBlock when hardfork is set\n   * @param blockNumber\n   * @returns True if HF is active on block number\n   */\n\n\n  activeOnBlock(blockNumber) {\n    return this.hardforkIsActiveOnBlock(null, blockNumber);\n  }\n  /**\n   * Sequence based check if given or set HF1 is greater than or equal HF2\n   * @param hardfork1 Hardfork name or null (if set)\n   * @param hardfork2 Hardfork name\n   * @param opts Hardfork options\n   * @returns True if HF1 gte HF2\n   */\n\n\n  hardforkGteHardfork(hardfork1, hardfork2) {\n    hardfork1 = hardfork1 ?? this._hardfork;\n    const hardforks = this.hardforks();\n    let posHf1 = -1,\n        posHf2 = -1;\n    let index = 0;\n\n    for (const hf of hardforks) {\n      if (hf['name'] === hardfork1) posHf1 = index;\n      if (hf['name'] === hardfork2) posHf2 = index;\n      index += 1;\n    }\n\n    return posHf1 >= posHf2 && posHf2 !== -1;\n  }\n  /**\n   * Alias to hardforkGteHardfork when hardfork is set\n   * @param hardfork Hardfork name\n   * @returns True if hardfork set is greater than hardfork provided\n   */\n\n\n  gteHardfork(hardfork) {\n    return this.hardforkGteHardfork(null, hardfork);\n  }\n  /**\n   * Returns the hardfork change block for hardfork provided or set\n   * @param hardfork Hardfork name, optional if HF set\n   * @returns Block number or null if unscheduled\n   */\n\n\n  hardforkBlock(hardfork) {\n    var _this$_getHardfork;\n\n    hardfork = hardfork ?? this._hardfork;\n    const block = (_this$_getHardfork = this._getHardfork(hardfork)) === null || _this$_getHardfork === void 0 ? void 0 : _this$_getHardfork['block'];\n\n    if (block === undefined || block === null) {\n      return null;\n    }\n\n    return BigInt(block);\n  }\n\n  hardforkTimestamp(hardfork) {\n    var _this$_getHardfork2;\n\n    hardfork = hardfork ?? this._hardfork;\n    const timestamp = (_this$_getHardfork2 = this._getHardfork(hardfork)) === null || _this$_getHardfork2 === void 0 ? void 0 : _this$_getHardfork2['timestamp'];\n\n    if (timestamp === undefined || timestamp === null) {\n      return null;\n    }\n\n    return BigInt(timestamp);\n  }\n  /**\n   * Returns the hardfork change block for eip\n   * @param eip EIP number\n   * @returns Block number or null if unscheduled\n   */\n\n\n  eipBlock(eip) {\n    for (const hfChanges of this.HARDFORK_CHANGES) {\n      const hf = hfChanges[1];\n\n      if ('eips' in hf) {\n        // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n        if (hf['eips'].includes(eip)) {\n          return this.hardforkBlock(hfChanges[0]);\n        }\n      }\n    }\n\n    return null;\n  }\n  /**\n   * Returns the hardfork change total difficulty (Merge HF) for hardfork provided or set\n   * @param hardfork Hardfork name, optional if HF set\n   * @returns Total difficulty or null if no set\n   */\n\n\n  hardforkTTD(hardfork) {\n    var _this$_getHardfork3;\n\n    hardfork = hardfork ?? this._hardfork;\n    const ttd = (_this$_getHardfork3 = this._getHardfork(hardfork)) === null || _this$_getHardfork3 === void 0 ? void 0 : _this$_getHardfork3['ttd'];\n\n    if (ttd === undefined || ttd === null) {\n      return null;\n    }\n\n    return BigInt(ttd);\n  }\n  /**\n   * True if block number provided is the hardfork (given or set) change block\n   * @param blockNumber Number of the block to check\n   * @param hardfork Hardfork name, optional if HF set\n   * @returns True if blockNumber is HF block\n   * @deprecated\n   */\n\n\n  isHardforkBlock(blockNumber, hardfork) {\n    blockNumber = (0, util_1.toType)(blockNumber, util_1.TypeOutput.BigInt);\n    hardfork = hardfork ?? this._hardfork;\n    const block = this.hardforkBlock(hardfork);\n    return typeof block === 'bigint' && block !== BigInt(0) ? block === blockNumber : false;\n  }\n  /**\n   * Returns the change block for the next hardfork after the hardfork provided or set\n   * @param hardfork Hardfork name, optional if HF set\n   * @returns Block timestamp, number or null if not available\n   */\n\n\n  nextHardforkBlockOrTimestamp(hardfork) {\n    hardfork = hardfork ?? this._hardfork;\n    const hfs = this.hardforks();\n    let hfIndex = hfs.findIndex(hf => hf.name === hardfork); // If the current hardfork is merge, go one behind as merge hf is not part of these\n    // calcs even if the merge hf block is set\n\n    if (hardfork === enums_1.Hardfork.Merge) {\n      hfIndex -= 1;\n    } // Hardfork not found\n\n\n    if (hfIndex < 0) {\n      return null;\n    }\n\n    let currHfTimeOrBlock = hfs[hfIndex].timestamp ?? hfs[hfIndex].block;\n    currHfTimeOrBlock = currHfTimeOrBlock !== null && currHfTimeOrBlock !== undefined ? Number(currHfTimeOrBlock) : null;\n    const nextHf = hfs.slice(hfIndex + 1).find(hf => {\n      let hfTimeOrBlock = hf.timestamp ?? hf.block;\n      hfTimeOrBlock = hfTimeOrBlock !== null && hfTimeOrBlock !== undefined ? Number(hfTimeOrBlock) : null;\n      return hf.name !== enums_1.Hardfork.Merge && hfTimeOrBlock !== null && hfTimeOrBlock !== undefined && hfTimeOrBlock !== currHfTimeOrBlock;\n    }); // If no next hf found with valid block or timestamp return null\n\n    if (nextHf === undefined) {\n      return null;\n    }\n\n    const nextHfBlock = nextHf.timestamp ?? nextHf.block;\n\n    if (nextHfBlock === null || nextHfBlock === undefined) {\n      return null;\n    }\n\n    return BigInt(nextHfBlock);\n  }\n  /**\n   * Returns the change block for the next hardfork after the hardfork provided or set\n   * @param hardfork Hardfork name, optional if HF set\n   * @returns Block number or null if not available\n   * @deprecated\n   */\n\n\n  nextHardforkBlock(hardfork) {\n    hardfork = hardfork ?? this._hardfork;\n    let hfBlock = this.hardforkBlock(hardfork); // If this is a merge hardfork with block not set, then we fallback to previous hardfork\n    // to find the nextHardforkBlock\n\n    if (hfBlock === null && hardfork === enums_1.Hardfork.Merge) {\n      const hfs = this.hardforks();\n      const mergeIndex = hfs.findIndex(hf => hf.ttd !== null && hf.ttd !== undefined);\n\n      if (mergeIndex < 0) {\n        throw Error(`Merge hardfork should have been found`);\n      }\n\n      hfBlock = this.hardforkBlock(hfs[mergeIndex - 1].name);\n    }\n\n    if (hfBlock === null) {\n      return null;\n    } // Next fork block number or null if none available\n    // Logic: if accumulator is still null and on the first occurrence of\n    // a block greater than the current hfBlock set the accumulator,\n    // pass on the accumulator as the final result from this time on\n\n\n    const nextHfBlock = this.hardforks().reduce((acc, hf) => {\n      // We need to ignore the merge block in our next hardfork calc\n      const block = BigInt(hf.block === null || hf.ttd !== undefined && hf.ttd !== null ? 0 : hf.block); // Typescript can't seem to follow that the hfBlock is not null at this point\n\n      return block > hfBlock && acc === null ? block : acc;\n    }, null);\n    return nextHfBlock;\n  }\n  /**\n   * True if block number provided is the hardfork change block following the hardfork given or set\n   * @param blockNumber Number of the block to check\n   * @param hardfork Hardfork name, optional if HF set\n   * @returns True if blockNumber is HF block\n   * @deprecated\n   */\n\n\n  isNextHardforkBlock(blockNumber, hardfork) {\n    blockNumber = (0, util_1.toType)(blockNumber, util_1.TypeOutput.BigInt);\n    hardfork = hardfork ?? this._hardfork;\n    const nextHardforkBlock = this.nextHardforkBlock(hardfork);\n    return nextHardforkBlock === null ? false : nextHardforkBlock === blockNumber;\n  }\n  /**\n   * Internal helper function to calculate a fork hash\n   * @param hardfork Hardfork name\n   * @param genesisHash Genesis block hash of the chain\n   * @returns Fork hash as hex string\n   */\n\n\n  _calcForkHash(hardfork, genesisHash) {\n    let hfBuffer = Buffer.alloc(0);\n    let prevBlockOrTime = 0;\n\n    for (const hf of this.hardforks()) {\n      const {\n        block,\n        timestamp,\n        name\n      } = hf; // Timestamp to be used for timestamp based hfs even if we may bundle\n      // block number with them retrospectively\n\n      let blockOrTime = timestamp ?? block;\n      blockOrTime = blockOrTime !== null ? Number(blockOrTime) : null; // Skip for chainstart (0), not applied HFs (null) and\n      // when already applied on same blockOrTime HFs\n      // and on the merge since forkhash doesn't change on merge hf\n\n      if (typeof blockOrTime === 'number' && blockOrTime !== 0 && blockOrTime !== prevBlockOrTime && name !== enums_1.Hardfork.Merge) {\n        const hfBlockBuffer = Buffer.from(blockOrTime.toString(16).padStart(16, '0'), 'hex');\n        hfBuffer = Buffer.concat([hfBuffer, hfBlockBuffer]);\n        prevBlockOrTime = blockOrTime;\n      }\n\n      if (hf.name === hardfork) break;\n    }\n\n    const inputBuffer = Buffer.concat([genesisHash, hfBuffer]); // CRC32 delivers result as signed (negative) 32-bit integer,\n    // convert to hex string\n\n    const forkhash = (0, util_1.intToBuffer)((0, crc_32_1.buf)(inputBuffer) >>> 0).toString('hex');\n    return `0x${forkhash}`;\n  }\n  /**\n   * Returns an eth/64 compliant fork hash (EIP-2124)\n   * @param hardfork Hardfork name, optional if HF set\n   * @param genesisHash Genesis block hash of the chain, optional if already defined and not needed to be calculated\n   */\n\n\n  forkHash(hardfork, genesisHash) {\n    hardfork = hardfork ?? this._hardfork;\n\n    const data = this._getHardfork(hardfork);\n\n    if (data === null || (data === null || data === void 0 ? void 0 : data.block) === null && (data === null || data === void 0 ? void 0 : data.timestamp) === undefined && (data === null || data === void 0 ? void 0 : data.ttd) === undefined) {\n      const msg = 'No fork hash calculation possible for future hardfork';\n      throw new Error(msg);\n    }\n\n    if ((data === null || data === void 0 ? void 0 : data.forkHash) !== null && (data === null || data === void 0 ? void 0 : data.forkHash) !== undefined) {\n      return data.forkHash;\n    }\n\n    if (!genesisHash) throw new Error('genesisHash required for forkHash calculation');\n    return this._calcForkHash(hardfork, genesisHash);\n  }\n  /**\n   *\n   * @param forkHash Fork hash as a hex string\n   * @returns Array with hardfork data (name, block, forkHash)\n   */\n\n\n  hardforkForForkHash(forkHash) {\n    const resArray = this.hardforks().filter(hf => {\n      return hf.forkHash === forkHash;\n    });\n    return resArray.length >= 1 ? resArray[resArray.length - 1] : null;\n  }\n  /**\n   * Sets any missing forkHashes on the passed-in {@link Common} instance\n   * @param common The {@link Common} to set the forkHashes for\n   * @param genesisHash The genesis block hash\n   */\n\n\n  setForkHashes(genesisHash) {\n    for (const hf of this.hardforks()) {\n      const blockOrTime = hf.timestamp ?? hf.block;\n\n      if ((hf.forkHash === null || hf.forkHash === undefined) && (blockOrTime !== null && blockOrTime !== undefined || typeof hf.ttd !== 'undefined')) {\n        hf.forkHash = this.forkHash(hf.name, genesisHash);\n      }\n    }\n  }\n  /**\n   * Returns the Genesis parameters of the current chain\n   * @returns Genesis dictionary\n   */\n\n\n  genesis() {\n    return this._chainParams.genesis;\n  }\n  /**\n   * Returns the hardforks for current chain\n   * @returns {Array} Array with arrays of hardforks\n   */\n\n\n  hardforks() {\n    return this._chainParams.hardforks;\n  }\n  /**\n   * Returns bootstrap nodes for the current chain\n   * @returns {Dictionary} Dict with bootstrap nodes\n   */\n\n\n  bootstrapNodes() {\n    return this._chainParams.bootstrapNodes;\n  }\n  /**\n   * Returns DNS networks for the current chain\n   * @returns {String[]} Array of DNS ENR urls\n   */\n\n\n  dnsNetworks() {\n    return this._chainParams.dnsNetworks;\n  }\n  /**\n   * Returns the hardfork set\n   * @returns Hardfork name\n   */\n\n\n  hardfork() {\n    return this._hardfork;\n  }\n  /**\n   * Returns the Id of current chain\n   * @returns chain Id\n   */\n\n\n  chainId() {\n    return BigInt(this._chainParams.chainId);\n  }\n  /**\n   * Returns the name of current chain\n   * @returns chain name (lower case)\n   */\n\n\n  chainName() {\n    return this._chainParams.name;\n  }\n  /**\n   * Returns the Id of current network\n   * @returns network Id\n   */\n\n\n  networkId() {\n    return BigInt(this._chainParams.networkId);\n  }\n  /**\n   * Returns the active EIPs\n   * @returns List of EIPs\n   */\n\n\n  eips() {\n    return this._eips;\n  }\n  /**\n   * Returns the consensus type of the network\n   * Possible values: \"pow\"|\"poa\"|\"pos\"\n   *\n   * Note: This value can update along a Hardfork.\n   */\n\n\n  consensusType() {\n    const hardfork = this.hardfork();\n    let value;\n\n    for (const hfChanges of this.HARDFORK_CHANGES) {\n      if ('consensus' in hfChanges[1]) {\n        value = hfChanges[1]['consensus']['type'];\n      }\n\n      if (hfChanges[0] === hardfork) break;\n    }\n\n    return value ?? this._chainParams['consensus']['type'];\n  }\n  /**\n   * Returns the concrete consensus implementation\n   * algorithm or protocol for the network\n   * e.g. \"ethash\" for \"pow\" consensus type,\n   * \"clique\" for \"poa\" consensus type or\n   * \"casper\" for \"pos\" consensus type.\n   *\n   * Note: This value can update along a Hardfork.\n   */\n\n\n  consensusAlgorithm() {\n    const hardfork = this.hardfork();\n    let value;\n\n    for (const hfChanges of this.HARDFORK_CHANGES) {\n      if ('consensus' in hfChanges[1]) {\n        value = hfChanges[1]['consensus']['algorithm'];\n      }\n\n      if (hfChanges[0] === hardfork) break;\n    }\n\n    return value ?? this._chainParams['consensus']['algorithm'];\n  }\n  /**\n   * Returns a dictionary with consensus configuration\n   * parameters based on the consensus algorithm\n   *\n   * Expected returns (parameters must be present in\n   * the respective chain json files):\n   *\n   * ethash: empty object\n   * clique: period, epoch\n   * casper: empty object\n   *\n   * Note: This value can update along a Hardfork.\n   */\n\n\n  consensusConfig() {\n    const hardfork = this.hardfork();\n    let value;\n\n    for (const hfChanges of this.HARDFORK_CHANGES) {\n      if ('consensus' in hfChanges[1]) {\n        // The config parameter is named after the respective consensus algorithm\n        value = hfChanges[1]['consensus'][hfChanges[1]['consensus']['algorithm']];\n      }\n\n      if (hfChanges[0] === hardfork) break;\n    }\n\n    return value ?? this._chainParams['consensus'][this.consensusAlgorithm()] ?? {};\n  }\n  /**\n   * Returns a deep copy of this {@link Common} instance.\n   */\n\n\n  copy() {\n    const copy = Object.assign(Object.create(Object.getPrototypeOf(this)), this);\n    copy.removeAllListeners();\n    return copy;\n  }\n\n  static _getInitializedChains(customChains) {\n    const names = {};\n\n    for (const [name, id] of Object.entries(enums_1.Chain)) {\n      names[id] = name.toLowerCase();\n    }\n\n    const chains = {\n      mainnet,\n      ropsten,\n      rinkeby,\n      goerli,\n      sepolia\n    };\n\n    if (customChains) {\n      for (const chain of customChains) {\n        const {\n          name\n        } = chain;\n        names[chain.chainId.toString()] = name;\n        chains[name] = chain;\n      }\n    }\n\n    chains.names = names;\n    return chains;\n  }\n\n}\n\nexports.Common = Common;","map":{"version":3,"sources":["../src/common.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Common = void 0;\nconst util_1 = require(\"@ethereumjs/util\");\nconst crc_32_1 = require(\"crc-32\");\nconst events_1 = require(\"events\");\nconst goerli = require(\"./chains/goerli.json\");\nconst mainnet = require(\"./chains/mainnet.json\");\nconst rinkeby = require(\"./chains/rinkeby.json\");\nconst ropsten = require(\"./chains/ropsten.json\");\nconst sepolia = require(\"./chains/sepolia.json\");\nconst eips_1 = require(\"./eips\");\nconst enums_1 = require(\"./enums\");\nconst hardforks_1 = require(\"./hardforks\");\nconst utils_1 = require(\"./utils\");\n/**\n * Common class to access chain and hardfork parameters and to provide\n * a unified and shared view on the network and hardfork state.\n *\n * Use the {@link Common.custom} static constructor for creating simple\n * custom chain {@link Common} objects (more complete custom chain setups\n * can be created via the main constructor and the {@link CommonOpts.customChains} parameter).\n */\nclass Common extends events_1.EventEmitter {\n    constructor(opts) {\n        super();\n        this._eips = [];\n        this._customChains = opts.customChains ?? [];\n        this._chainParams = this.setChain(opts.chain);\n        this.DEFAULT_HARDFORK = this._chainParams.defaultHardfork ?? enums_1.Hardfork.Merge;\n        // Assign hardfork changes in the sequence of the applied hardforks\n        this.HARDFORK_CHANGES = this.hardforks().map((hf) => [\n            hf.name,\n            hardforks_1.hardforks[hf.name],\n        ]);\n        this._hardfork = this.DEFAULT_HARDFORK;\n        if (opts.hardfork !== undefined) {\n            this.setHardfork(opts.hardfork);\n        }\n        if (opts.eips) {\n            this.setEIPs(opts.eips);\n        }\n    }\n    /**\n     * Creates a {@link Common} object for a custom chain, based on a standard one.\n     *\n     * It uses all the {@link Chain} parameters from the {@link baseChain} option except the ones overridden\n     * in a provided {@link chainParamsOrName} dictionary. Some usage example:\n     *\n     * ```javascript\n     * Common.custom({chainId: 123})\n     * ```\n     *\n     * There are also selected supported custom chains which can be initialized by using one of the\n     * {@link CustomChains} for {@link chainParamsOrName}, e.g.:\n     *\n     * ```javascript\n     * Common.custom(CustomChains.MaticMumbai)\n     * ```\n     *\n     * Note that these supported custom chains only provide some base parameters (usually the chain and\n     * network ID and a name) and can only be used for selected use cases (e.g. sending a tx with\n     * the `@ethereumjs/tx` library to a Layer-2 chain).\n     *\n     * @param chainParamsOrName Custom parameter dict (`name` will default to `custom-chain`) or string with name of a supported custom chain\n     * @param opts Custom chain options to set the {@link CustomCommonOpts.baseChain}, selected {@link CustomCommonOpts.hardfork} and others\n     */\n    static custom(chainParamsOrName, opts = {}) {\n        const baseChain = opts.baseChain ?? 'mainnet';\n        const standardChainParams = { ...Common._getChainParams(baseChain) };\n        standardChainParams['name'] = 'custom-chain';\n        if (typeof chainParamsOrName !== 'string') {\n            return new Common({\n                chain: {\n                    ...standardChainParams,\n                    ...chainParamsOrName,\n                },\n                ...opts,\n            });\n        }\n        else {\n            if (chainParamsOrName === enums_1.CustomChain.PolygonMainnet) {\n                return Common.custom({\n                    name: enums_1.CustomChain.PolygonMainnet,\n                    chainId: 137,\n                    networkId: 137,\n                }, opts);\n            }\n            if (chainParamsOrName === enums_1.CustomChain.PolygonMumbai) {\n                return Common.custom({\n                    name: enums_1.CustomChain.PolygonMumbai,\n                    chainId: 80001,\n                    networkId: 80001,\n                }, opts);\n            }\n            if (chainParamsOrName === enums_1.CustomChain.ArbitrumRinkebyTestnet) {\n                return Common.custom({\n                    name: enums_1.CustomChain.ArbitrumRinkebyTestnet,\n                    chainId: 421611,\n                    networkId: 421611,\n                }, opts);\n            }\n            if (chainParamsOrName === enums_1.CustomChain.ArbitrumOne) {\n                return Common.custom({\n                    name: enums_1.CustomChain.ArbitrumOne,\n                    chainId: 42161,\n                    networkId: 42161,\n                }, opts);\n            }\n            if (chainParamsOrName === enums_1.CustomChain.xDaiChain) {\n                return Common.custom({\n                    name: enums_1.CustomChain.xDaiChain,\n                    chainId: 100,\n                    networkId: 100,\n                }, opts);\n            }\n            if (chainParamsOrName === enums_1.CustomChain.OptimisticKovan) {\n                return Common.custom({\n                    name: enums_1.CustomChain.OptimisticKovan,\n                    chainId: 69,\n                    networkId: 69,\n                }, \n                // Optimism has not implemented the London hardfork yet (targeting Q1.22)\n                { hardfork: enums_1.Hardfork.Berlin, ...opts });\n            }\n            if (chainParamsOrName === enums_1.CustomChain.OptimisticEthereum) {\n                return Common.custom({\n                    name: enums_1.CustomChain.OptimisticEthereum,\n                    chainId: 10,\n                    networkId: 10,\n                }, \n                // Optimism has not implemented the London hardfork yet (targeting Q1.22)\n                { hardfork: enums_1.Hardfork.Berlin, ...opts });\n            }\n            throw new Error(`Custom chain ${chainParamsOrName} not supported`);\n        }\n    }\n    /**\n     * Static method to load and set common from a geth genesis json\n     * @param genesisJson json of geth configuration\n     * @param { chain, eips, genesisHash, hardfork, mergeForkIdPostMerge } to further configure the common instance\n     * @returns Common\n     */\n    static fromGethGenesis(genesisJson, { chain, eips, genesisHash, hardfork, mergeForkIdPostMerge }) {\n        const genesisParams = (0, utils_1.parseGethGenesis)(genesisJson, chain, mergeForkIdPostMerge);\n        const common = new Common({\n            chain: genesisParams.name ?? 'custom',\n            customChains: [genesisParams],\n            eips,\n            hardfork: hardfork ?? genesisParams.hardfork,\n        });\n        if (genesisHash !== undefined) {\n            common.setForkHashes(genesisHash);\n        }\n        return common;\n    }\n    /**\n     * Static method to determine if a {@link chainId} is supported as a standard chain\n     * @param chainId bigint id (`1`) of a standard chain\n     * @returns boolean\n     */\n    static isSupportedChainId(chainId) {\n        const initializedChains = this._getInitializedChains();\n        return Boolean(initializedChains['names'][chainId.toString()]);\n    }\n    static _getChainParams(chain, customChains) {\n        const initializedChains = this._getInitializedChains(customChains);\n        if (typeof chain === 'number' || typeof chain === 'bigint') {\n            chain = chain.toString();\n            if (initializedChains['names'][chain]) {\n                const name = initializedChains['names'][chain];\n                return initializedChains[name];\n            }\n            throw new Error(`Chain with ID ${chain} not supported`);\n        }\n        if (initializedChains[chain] !== undefined) {\n            return initializedChains[chain];\n        }\n        throw new Error(`Chain with name ${chain} not supported`);\n    }\n    /**\n     * Sets the chain\n     * @param chain String ('mainnet') or Number (1) chain representation.\n     *              Or, a Dictionary of chain parameters for a private network.\n     * @returns The dictionary with parameters set as chain\n     */\n    setChain(chain) {\n        if (typeof chain === 'number' || typeof chain === 'bigint' || typeof chain === 'string') {\n            this._chainParams = Common._getChainParams(chain, this._customChains);\n        }\n        else if (typeof chain === 'object') {\n            if (this._customChains.length > 0) {\n                throw new Error('Chain must be a string, number, or bigint when initialized with customChains passed in');\n            }\n            const required = ['networkId', 'genesis', 'hardforks', 'bootstrapNodes'];\n            for (const param of required) {\n                if (!(param in chain)) {\n                    throw new Error(`Missing required chain parameter: ${param}`);\n                }\n            }\n            this._chainParams = chain;\n        }\n        else {\n            throw new Error('Wrong input format');\n        }\n        for (const hf of this.hardforks()) {\n            if (hf.block === undefined) {\n                throw new Error(`Hardfork cannot have undefined block number`);\n            }\n        }\n        return this._chainParams;\n    }\n    /**\n     * Sets the hardfork to get params for\n     * @param hardfork String identifier (e.g. 'byzantium') or {@link Hardfork} enum\n     */\n    setHardfork(hardfork) {\n        let existing = false;\n        for (const hfChanges of this.HARDFORK_CHANGES) {\n            if (hfChanges[0] === hardfork) {\n                if (this._hardfork !== hardfork) {\n                    this._hardfork = hardfork;\n                    this.emit('hardforkChanged', hardfork);\n                }\n                existing = true;\n            }\n        }\n        if (!existing) {\n            throw new Error(`Hardfork with name ${hardfork} not supported`);\n        }\n    }\n    /**\n     * Returns the hardfork based on the block number or an optional\n     * total difficulty (Merge HF) provided.\n     *\n     * An optional TD takes precedence in case the corresponding HF block\n     * is set to `null` or otherwise needs to match (if not an error\n     * will be thrown).\n     *\n     * @param blockNumber\n     * @param td : total difficulty of the parent block (for block hf) OR of the chain latest (for chain hf)\n     * @param timestamp: timestamp in seconds at which block was/is to be minted\n     * @returns The name of the HF\n     */\n    getHardforkByBlockNumber(blockNumber, td, timestamp) {\n        blockNumber = (0, util_1.toType)(blockNumber, util_1.TypeOutput.BigInt);\n        td = (0, util_1.toType)(td, util_1.TypeOutput.BigInt);\n        timestamp = (0, util_1.toType)(timestamp, util_1.TypeOutput.Number);\n        // Filter out hardforks with no block number, no ttd or no timestamp (i.e. unapplied hardforks)\n        const hfs = this.hardforks().filter((hf) => hf.block !== null || (hf.ttd !== null && hf.ttd !== undefined) || hf.timestamp !== undefined);\n        const mergeIndex = hfs.findIndex((hf) => hf.ttd !== null && hf.ttd !== undefined);\n        const doubleTTDHF = hfs\n            .slice(mergeIndex + 1)\n            .findIndex((hf) => hf.ttd !== null && hf.ttd !== undefined);\n        if (doubleTTDHF >= 0) {\n            throw Error(`More than one merge hardforks found with ttd specified`);\n        }\n        // Find the first hardfork that has a block number greater than `blockNumber`\n        // (skips the merge hardfork since it cannot have a block number specified).\n        // If timestamp is not provided, it also skips timestamps hardforks to continue\n        // discovering/checking number hardforks.\n        let hfIndex = hfs.findIndex((hf) => (hf.block !== null && hf.block > blockNumber) ||\n            (timestamp !== undefined && Number(hf.timestamp) > timestamp));\n        if (hfIndex === -1) {\n            // all hardforks apply, set hfIndex to the last one as that's the candidate\n            hfIndex = hfs.length;\n        }\n        else if (hfIndex === 0) {\n            // cannot have a case where a block number is before all applied hardforks\n            // since the chain has to start with a hardfork\n            throw Error('Must have at least one hardfork at block 0');\n        }\n        // If timestamp is not provided, we need to rollback to the last hf with block or ttd\n        if (timestamp === undefined) {\n            const stepBack = hfs\n                .slice(0, hfIndex)\n                .reverse()\n                .findIndex((hf) => hf.block !== null || hf.ttd !== undefined);\n            hfIndex = hfIndex - stepBack;\n        }\n        // Move hfIndex one back to arrive at candidate hardfork\n        hfIndex = hfIndex - 1;\n        // If the timestamp was not provided, we could have skipped timestamp hardforks to look for number\n        // hardforks. so it will now be needed to rollback\n        if (hfs[hfIndex].block === null && hfs[hfIndex].timestamp === undefined) {\n            // We're on the merge hardfork.  Let's check the TTD\n            if (td === undefined || td === null || BigInt(hfs[hfIndex].ttd) > td) {\n                // Merge ttd greater than current td so we're on hardfork before merge\n                hfIndex -= 1;\n            }\n        }\n        else {\n            if (mergeIndex >= 0 && td !== undefined && td !== null) {\n                if (hfIndex >= mergeIndex && BigInt(hfs[mergeIndex].ttd) > td) {\n                    throw Error('Maximum HF determined by total difficulty is lower than the block number HF');\n                }\n                else if (hfIndex < mergeIndex && BigInt(hfs[mergeIndex].ttd) <= td) {\n                    throw Error('HF determined by block number is lower than the minimum total difficulty HF');\n                }\n            }\n        }\n        const hfStartIndex = hfIndex;\n        // Move the hfIndex to the end of the hardforks that might be scheduled on the same block/timestamp\n        // This won't anyway be the case with Merge hfs\n        for (; hfIndex < hfs.length - 1; hfIndex++) {\n            // break out if hfIndex + 1 is not scheduled at hfIndex\n            if (hfs[hfIndex].block !== hfs[hfIndex + 1].block ||\n                hfs[hfIndex].timestamp !== hfs[hfIndex + 1].timestamp) {\n                break;\n            }\n        }\n        if (timestamp) {\n            const minTimeStamp = hfs\n                .slice(0, hfStartIndex)\n                .reduce((acc, hf) => Math.max(Number(hf.timestamp ?? '0'), acc), 0);\n            if (minTimeStamp > timestamp) {\n                throw Error(`Maximum HF determined by timestamp is lower than the block number/ttd HF`);\n            }\n            const maxTimeStamp = hfs\n                .slice(hfIndex + 1)\n                .reduce((acc, hf) => Math.min(Number(hf.timestamp ?? timestamp), acc), timestamp);\n            if (maxTimeStamp < timestamp) {\n                throw Error(`Maximum HF determined by block number/ttd is lower than timestamp HF`);\n            }\n        }\n        const hardfork = hfs[hfIndex];\n        return hardfork.name;\n    }\n    /**\n     * Sets a new hardfork based on the block number or an optional\n     * total difficulty (Merge HF) provided.\n     *\n     * An optional TD takes precedence in case the corresponding HF block\n     * is set to `null` or otherwise needs to match (if not an error\n     * will be thrown).\n     *\n     * @param blockNumber\n     * @param td\n     * @param timestamp\n     * @returns The name of the HF set\n     */\n    setHardforkByBlockNumber(blockNumber, td, timestamp) {\n        const hardfork = this.getHardforkByBlockNumber(blockNumber, td, timestamp);\n        this.setHardfork(hardfork);\n        return hardfork;\n    }\n    /**\n     * Internal helper function, returns the params for the given hardfork for the chain set\n     * @param hardfork Hardfork name\n     * @returns Dictionary with hardfork params or null if hardfork not on chain\n     */\n    _getHardfork(hardfork) {\n        const hfs = this.hardforks();\n        for (const hf of hfs) {\n            if (hf['name'] === hardfork)\n                return hf;\n        }\n        return null;\n    }\n    /**\n     * Sets the active EIPs\n     * @param eips\n     */\n    setEIPs(eips = []) {\n        for (const eip of eips) {\n            if (!(eip in eips_1.EIPs)) {\n                throw new Error(`${eip} not supported`);\n            }\n            const minHF = this.gteHardfork(eips_1.EIPs[eip]['minimumHardfork']);\n            if (!minHF) {\n                throw new Error(`${eip} cannot be activated on hardfork ${this.hardfork()}, minimumHardfork: ${minHF}`);\n            }\n            if (eips_1.EIPs[eip].requiredEIPs !== undefined) {\n                for (const elem of eips_1.EIPs[eip].requiredEIPs) {\n                    if (!(eips.includes(elem) || this.isActivatedEIP(elem))) {\n                        throw new Error(`${eip} requires EIP ${elem}, but is not included in the EIP list`);\n                    }\n                }\n            }\n        }\n        this._eips = eips;\n    }\n    /**\n     * Returns a parameter for the current chain setup\n     *\n     * If the parameter is present in an EIP, the EIP always takes precedence.\n     * Otherwise the parameter if taken from the latest applied HF with\n     * a change on the respective parameter.\n     *\n     * @param topic Parameter topic ('gasConfig', 'gasPrices', 'vm', 'pow')\n     * @param name Parameter name (e.g. 'minGasLimit' for 'gasConfig' topic)\n     * @returns The value requested or `BigInt(0)` if not found\n     */\n    param(topic, name) {\n        // TODO: consider the case that different active EIPs\n        // can change the same parameter\n        let value;\n        for (const eip of this._eips) {\n            value = this.paramByEIP(topic, name, eip);\n            if (value !== undefined)\n                return value;\n        }\n        return this.paramByHardfork(topic, name, this._hardfork);\n    }\n    /**\n     * Returns the parameter corresponding to a hardfork\n     * @param topic Parameter topic ('gasConfig', 'gasPrices', 'vm', 'pow')\n     * @param name Parameter name (e.g. 'minGasLimit' for 'gasConfig' topic)\n     * @param hardfork Hardfork name\n     * @returns The value requested or `BigInt(0)` if not found\n     */\n    paramByHardfork(topic, name, hardfork) {\n        let value = null;\n        for (const hfChanges of this.HARDFORK_CHANGES) {\n            // EIP-referencing HF file (e.g. berlin.json)\n            if ('eips' in hfChanges[1]) {\n                const hfEIPs = hfChanges[1]['eips'];\n                for (const eip of hfEIPs) {\n                    const valueEIP = this.paramByEIP(topic, name, eip);\n                    value = typeof valueEIP === 'bigint' ? valueEIP : value;\n                }\n                // Parameter-inlining HF file (e.g. istanbul.json)\n            }\n            else {\n                if (hfChanges[1][topic] === undefined) {\n                    throw new Error(`Topic ${topic} not defined`);\n                }\n                if (hfChanges[1][topic][name] !== undefined) {\n                    value = hfChanges[1][topic][name].v;\n                }\n            }\n            if (hfChanges[0] === hardfork)\n                break;\n        }\n        return BigInt(value ?? 0);\n    }\n    /**\n     * Returns a parameter corresponding to an EIP\n     * @param topic Parameter topic ('gasConfig', 'gasPrices', 'vm', 'pow')\n     * @param name Parameter name (e.g. 'minGasLimit' for 'gasConfig' topic)\n     * @param eip Number of the EIP\n     * @returns The value requested or `undefined` if not found\n     */\n    paramByEIP(topic, name, eip) {\n        if (!(eip in eips_1.EIPs)) {\n            throw new Error(`${eip} not supported`);\n        }\n        const eipParams = eips_1.EIPs[eip];\n        if (!(topic in eipParams)) {\n            throw new Error(`Topic ${topic} not defined`);\n        }\n        if (eipParams[topic][name] === undefined) {\n            return undefined;\n        }\n        const value = eipParams[topic][name].v;\n        return BigInt(value);\n    }\n    /**\n     * Returns a parameter for the hardfork active on block number or\n     * optional provided total difficulty (Merge HF)\n     * @param topic Parameter topic\n     * @param name Parameter name\n     * @param blockNumber Block number\n     * @param td Total difficulty\n     *    * @returns The value requested or `BigInt(0)` if not found\n     */\n    paramByBlock(topic, name, blockNumber, td, timestamp) {\n        const hardfork = this.getHardforkByBlockNumber(blockNumber, td, timestamp);\n        return this.paramByHardfork(topic, name, hardfork);\n    }\n    /**\n     * Checks if an EIP is activated by either being included in the EIPs\n     * manually passed in with the {@link CommonOpts.eips} or in a\n     * hardfork currently being active\n     *\n     * Note: this method only works for EIPs being supported\n     * by the {@link CommonOpts.eips} constructor option\n     * @param eip\n     */\n    isActivatedEIP(eip) {\n        if (this.eips().includes(eip)) {\n            return true;\n        }\n        for (const hfChanges of this.HARDFORK_CHANGES) {\n            const hf = hfChanges[1];\n            if (this.gteHardfork(hf['name']) && 'eips' in hf) {\n                if (hf['eips'].includes(eip)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n    /**\n     * Checks if set or provided hardfork is active on block number\n     * @param hardfork Hardfork name or null (for HF set)\n     * @param blockNumber\n     * @returns True if HF is active on block number\n     */\n    hardforkIsActiveOnBlock(hardfork, blockNumber) {\n        blockNumber = (0, util_1.toType)(blockNumber, util_1.TypeOutput.BigInt);\n        hardfork = hardfork ?? this._hardfork;\n        const hfBlock = this.hardforkBlock(hardfork);\n        if (typeof hfBlock === 'bigint' && hfBlock !== BigInt(0) && blockNumber >= hfBlock) {\n            return true;\n        }\n        return false;\n    }\n    /**\n     * Alias to hardforkIsActiveOnBlock when hardfork is set\n     * @param blockNumber\n     * @returns True if HF is active on block number\n     */\n    activeOnBlock(blockNumber) {\n        return this.hardforkIsActiveOnBlock(null, blockNumber);\n    }\n    /**\n     * Sequence based check if given or set HF1 is greater than or equal HF2\n     * @param hardfork1 Hardfork name or null (if set)\n     * @param hardfork2 Hardfork name\n     * @param opts Hardfork options\n     * @returns True if HF1 gte HF2\n     */\n    hardforkGteHardfork(hardfork1, hardfork2) {\n        hardfork1 = hardfork1 ?? this._hardfork;\n        const hardforks = this.hardforks();\n        let posHf1 = -1, posHf2 = -1;\n        let index = 0;\n        for (const hf of hardforks) {\n            if (hf['name'] === hardfork1)\n                posHf1 = index;\n            if (hf['name'] === hardfork2)\n                posHf2 = index;\n            index += 1;\n        }\n        return posHf1 >= posHf2 && posHf2 !== -1;\n    }\n    /**\n     * Alias to hardforkGteHardfork when hardfork is set\n     * @param hardfork Hardfork name\n     * @returns True if hardfork set is greater than hardfork provided\n     */\n    gteHardfork(hardfork) {\n        return this.hardforkGteHardfork(null, hardfork);\n    }\n    /**\n     * Returns the hardfork change block for hardfork provided or set\n     * @param hardfork Hardfork name, optional if HF set\n     * @returns Block number or null if unscheduled\n     */\n    hardforkBlock(hardfork) {\n        hardfork = hardfork ?? this._hardfork;\n        const block = this._getHardfork(hardfork)?.['block'];\n        if (block === undefined || block === null) {\n            return null;\n        }\n        return BigInt(block);\n    }\n    hardforkTimestamp(hardfork) {\n        hardfork = hardfork ?? this._hardfork;\n        const timestamp = this._getHardfork(hardfork)?.['timestamp'];\n        if (timestamp === undefined || timestamp === null) {\n            return null;\n        }\n        return BigInt(timestamp);\n    }\n    /**\n     * Returns the hardfork change block for eip\n     * @param eip EIP number\n     * @returns Block number or null if unscheduled\n     */\n    eipBlock(eip) {\n        for (const hfChanges of this.HARDFORK_CHANGES) {\n            const hf = hfChanges[1];\n            if ('eips' in hf) {\n                // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n                if (hf['eips'].includes(eip)) {\n                    return this.hardforkBlock(hfChanges[0]);\n                }\n            }\n        }\n        return null;\n    }\n    /**\n     * Returns the hardfork change total difficulty (Merge HF) for hardfork provided or set\n     * @param hardfork Hardfork name, optional if HF set\n     * @returns Total difficulty or null if no set\n     */\n    hardforkTTD(hardfork) {\n        hardfork = hardfork ?? this._hardfork;\n        const ttd = this._getHardfork(hardfork)?.['ttd'];\n        if (ttd === undefined || ttd === null) {\n            return null;\n        }\n        return BigInt(ttd);\n    }\n    /**\n     * True if block number provided is the hardfork (given or set) change block\n     * @param blockNumber Number of the block to check\n     * @param hardfork Hardfork name, optional if HF set\n     * @returns True if blockNumber is HF block\n     * @deprecated\n     */\n    isHardforkBlock(blockNumber, hardfork) {\n        blockNumber = (0, util_1.toType)(blockNumber, util_1.TypeOutput.BigInt);\n        hardfork = hardfork ?? this._hardfork;\n        const block = this.hardforkBlock(hardfork);\n        return typeof block === 'bigint' && block !== BigInt(0) ? block === blockNumber : false;\n    }\n    /**\n     * Returns the change block for the next hardfork after the hardfork provided or set\n     * @param hardfork Hardfork name, optional if HF set\n     * @returns Block timestamp, number or null if not available\n     */\n    nextHardforkBlockOrTimestamp(hardfork) {\n        hardfork = hardfork ?? this._hardfork;\n        const hfs = this.hardforks();\n        let hfIndex = hfs.findIndex((hf) => hf.name === hardfork);\n        // If the current hardfork is merge, go one behind as merge hf is not part of these\n        // calcs even if the merge hf block is set\n        if (hardfork === enums_1.Hardfork.Merge) {\n            hfIndex -= 1;\n        }\n        // Hardfork not found\n        if (hfIndex < 0) {\n            return null;\n        }\n        let currHfTimeOrBlock = hfs[hfIndex].timestamp ?? hfs[hfIndex].block;\n        currHfTimeOrBlock =\n            currHfTimeOrBlock !== null && currHfTimeOrBlock !== undefined\n                ? Number(currHfTimeOrBlock)\n                : null;\n        const nextHf = hfs.slice(hfIndex + 1).find((hf) => {\n            let hfTimeOrBlock = hf.timestamp ?? hf.block;\n            hfTimeOrBlock =\n                hfTimeOrBlock !== null && hfTimeOrBlock !== undefined ? Number(hfTimeOrBlock) : null;\n            return (hf.name !== enums_1.Hardfork.Merge &&\n                hfTimeOrBlock !== null &&\n                hfTimeOrBlock !== undefined &&\n                hfTimeOrBlock !== currHfTimeOrBlock);\n        });\n        // If no next hf found with valid block or timestamp return null\n        if (nextHf === undefined) {\n            return null;\n        }\n        const nextHfBlock = nextHf.timestamp ?? nextHf.block;\n        if (nextHfBlock === null || nextHfBlock === undefined) {\n            return null;\n        }\n        return BigInt(nextHfBlock);\n    }\n    /**\n     * Returns the change block for the next hardfork after the hardfork provided or set\n     * @param hardfork Hardfork name, optional if HF set\n     * @returns Block number or null if not available\n     * @deprecated\n     */\n    nextHardforkBlock(hardfork) {\n        hardfork = hardfork ?? this._hardfork;\n        let hfBlock = this.hardforkBlock(hardfork);\n        // If this is a merge hardfork with block not set, then we fallback to previous hardfork\n        // to find the nextHardforkBlock\n        if (hfBlock === null && hardfork === enums_1.Hardfork.Merge) {\n            const hfs = this.hardforks();\n            const mergeIndex = hfs.findIndex((hf) => hf.ttd !== null && hf.ttd !== undefined);\n            if (mergeIndex < 0) {\n                throw Error(`Merge hardfork should have been found`);\n            }\n            hfBlock = this.hardforkBlock(hfs[mergeIndex - 1].name);\n        }\n        if (hfBlock === null) {\n            return null;\n        }\n        // Next fork block number or null if none available\n        // Logic: if accumulator is still null and on the first occurrence of\n        // a block greater than the current hfBlock set the accumulator,\n        // pass on the accumulator as the final result from this time on\n        const nextHfBlock = this.hardforks().reduce((acc, hf) => {\n            // We need to ignore the merge block in our next hardfork calc\n            const block = BigInt(hf.block === null || (hf.ttd !== undefined && hf.ttd !== null) ? 0 : hf.block);\n            // Typescript can't seem to follow that the hfBlock is not null at this point\n            return block > hfBlock && acc === null ? block : acc;\n        }, null);\n        return nextHfBlock;\n    }\n    /**\n     * True if block number provided is the hardfork change block following the hardfork given or set\n     * @param blockNumber Number of the block to check\n     * @param hardfork Hardfork name, optional if HF set\n     * @returns True if blockNumber is HF block\n     * @deprecated\n     */\n    isNextHardforkBlock(blockNumber, hardfork) {\n        blockNumber = (0, util_1.toType)(blockNumber, util_1.TypeOutput.BigInt);\n        hardfork = hardfork ?? this._hardfork;\n        const nextHardforkBlock = this.nextHardforkBlock(hardfork);\n        return nextHardforkBlock === null ? false : nextHardforkBlock === blockNumber;\n    }\n    /**\n     * Internal helper function to calculate a fork hash\n     * @param hardfork Hardfork name\n     * @param genesisHash Genesis block hash of the chain\n     * @returns Fork hash as hex string\n     */\n    _calcForkHash(hardfork, genesisHash) {\n        let hfBuffer = Buffer.alloc(0);\n        let prevBlockOrTime = 0;\n        for (const hf of this.hardforks()) {\n            const { block, timestamp, name } = hf;\n            // Timestamp to be used for timestamp based hfs even if we may bundle\n            // block number with them retrospectively\n            let blockOrTime = timestamp ?? block;\n            blockOrTime = blockOrTime !== null ? Number(blockOrTime) : null;\n            // Skip for chainstart (0), not applied HFs (null) and\n            // when already applied on same blockOrTime HFs\n            // and on the merge since forkhash doesn't change on merge hf\n            if (typeof blockOrTime === 'number' &&\n                blockOrTime !== 0 &&\n                blockOrTime !== prevBlockOrTime &&\n                name !== enums_1.Hardfork.Merge) {\n                const hfBlockBuffer = Buffer.from(blockOrTime.toString(16).padStart(16, '0'), 'hex');\n                hfBuffer = Buffer.concat([hfBuffer, hfBlockBuffer]);\n                prevBlockOrTime = blockOrTime;\n            }\n            if (hf.name === hardfork)\n                break;\n        }\n        const inputBuffer = Buffer.concat([genesisHash, hfBuffer]);\n        // CRC32 delivers result as signed (negative) 32-bit integer,\n        // convert to hex string\n        const forkhash = (0, util_1.intToBuffer)((0, crc_32_1.buf)(inputBuffer) >>> 0).toString('hex');\n        return `0x${forkhash}`;\n    }\n    /**\n     * Returns an eth/64 compliant fork hash (EIP-2124)\n     * @param hardfork Hardfork name, optional if HF set\n     * @param genesisHash Genesis block hash of the chain, optional if already defined and not needed to be calculated\n     */\n    forkHash(hardfork, genesisHash) {\n        hardfork = hardfork ?? this._hardfork;\n        const data = this._getHardfork(hardfork);\n        if (data === null ||\n            (data?.block === null && data?.timestamp === undefined && data?.ttd === undefined)) {\n            const msg = 'No fork hash calculation possible for future hardfork';\n            throw new Error(msg);\n        }\n        if (data?.forkHash !== null && data?.forkHash !== undefined) {\n            return data.forkHash;\n        }\n        if (!genesisHash)\n            throw new Error('genesisHash required for forkHash calculation');\n        return this._calcForkHash(hardfork, genesisHash);\n    }\n    /**\n     *\n     * @param forkHash Fork hash as a hex string\n     * @returns Array with hardfork data (name, block, forkHash)\n     */\n    hardforkForForkHash(forkHash) {\n        const resArray = this.hardforks().filter((hf) => {\n            return hf.forkHash === forkHash;\n        });\n        return resArray.length >= 1 ? resArray[resArray.length - 1] : null;\n    }\n    /**\n     * Sets any missing forkHashes on the passed-in {@link Common} instance\n     * @param common The {@link Common} to set the forkHashes for\n     * @param genesisHash The genesis block hash\n     */\n    setForkHashes(genesisHash) {\n        for (const hf of this.hardforks()) {\n            const blockOrTime = hf.timestamp ?? hf.block;\n            if ((hf.forkHash === null || hf.forkHash === undefined) &&\n                ((blockOrTime !== null && blockOrTime !== undefined) || typeof hf.ttd !== 'undefined')) {\n                hf.forkHash = this.forkHash(hf.name, genesisHash);\n            }\n        }\n    }\n    /**\n     * Returns the Genesis parameters of the current chain\n     * @returns Genesis dictionary\n     */\n    genesis() {\n        return this._chainParams.genesis;\n    }\n    /**\n     * Returns the hardforks for current chain\n     * @returns {Array} Array with arrays of hardforks\n     */\n    hardforks() {\n        return this._chainParams.hardforks;\n    }\n    /**\n     * Returns bootstrap nodes for the current chain\n     * @returns {Dictionary} Dict with bootstrap nodes\n     */\n    bootstrapNodes() {\n        return this._chainParams.bootstrapNodes;\n    }\n    /**\n     * Returns DNS networks for the current chain\n     * @returns {String[]} Array of DNS ENR urls\n     */\n    dnsNetworks() {\n        return this._chainParams.dnsNetworks;\n    }\n    /**\n     * Returns the hardfork set\n     * @returns Hardfork name\n     */\n    hardfork() {\n        return this._hardfork;\n    }\n    /**\n     * Returns the Id of current chain\n     * @returns chain Id\n     */\n    chainId() {\n        return BigInt(this._chainParams.chainId);\n    }\n    /**\n     * Returns the name of current chain\n     * @returns chain name (lower case)\n     */\n    chainName() {\n        return this._chainParams.name;\n    }\n    /**\n     * Returns the Id of current network\n     * @returns network Id\n     */\n    networkId() {\n        return BigInt(this._chainParams.networkId);\n    }\n    /**\n     * Returns the active EIPs\n     * @returns List of EIPs\n     */\n    eips() {\n        return this._eips;\n    }\n    /**\n     * Returns the consensus type of the network\n     * Possible values: \"pow\"|\"poa\"|\"pos\"\n     *\n     * Note: This value can update along a Hardfork.\n     */\n    consensusType() {\n        const hardfork = this.hardfork();\n        let value;\n        for (const hfChanges of this.HARDFORK_CHANGES) {\n            if ('consensus' in hfChanges[1]) {\n                value = hfChanges[1]['consensus']['type'];\n            }\n            if (hfChanges[0] === hardfork)\n                break;\n        }\n        return value ?? this._chainParams['consensus']['type'];\n    }\n    /**\n     * Returns the concrete consensus implementation\n     * algorithm or protocol for the network\n     * e.g. \"ethash\" for \"pow\" consensus type,\n     * \"clique\" for \"poa\" consensus type or\n     * \"casper\" for \"pos\" consensus type.\n     *\n     * Note: This value can update along a Hardfork.\n     */\n    consensusAlgorithm() {\n        const hardfork = this.hardfork();\n        let value;\n        for (const hfChanges of this.HARDFORK_CHANGES) {\n            if ('consensus' in hfChanges[1]) {\n                value = hfChanges[1]['consensus']['algorithm'];\n            }\n            if (hfChanges[0] === hardfork)\n                break;\n        }\n        return value ?? this._chainParams['consensus']['algorithm'];\n    }\n    /**\n     * Returns a dictionary with consensus configuration\n     * parameters based on the consensus algorithm\n     *\n     * Expected returns (parameters must be present in\n     * the respective chain json files):\n     *\n     * ethash: empty object\n     * clique: period, epoch\n     * casper: empty object\n     *\n     * Note: This value can update along a Hardfork.\n     */\n    consensusConfig() {\n        const hardfork = this.hardfork();\n        let value;\n        for (const hfChanges of this.HARDFORK_CHANGES) {\n            if ('consensus' in hfChanges[1]) {\n                // The config parameter is named after the respective consensus algorithm\n                value = hfChanges[1]['consensus'][hfChanges[1]['consensus']['algorithm']];\n            }\n            if (hfChanges[0] === hardfork)\n                break;\n        }\n        return (value ?? this._chainParams['consensus'][this.consensusAlgorithm()] ?? {});\n    }\n    /**\n     * Returns a deep copy of this {@link Common} instance.\n     */\n    copy() {\n        const copy = Object.assign(Object.create(Object.getPrototypeOf(this)), this);\n        copy.removeAllListeners();\n        return copy;\n    }\n    static _getInitializedChains(customChains) {\n        const names = {};\n        for (const [name, id] of Object.entries(enums_1.Chain)) {\n            names[id] = name.toLowerCase();\n        }\n        const chains = { mainnet, ropsten, rinkeby, goerli, sepolia };\n        if (customChains) {\n            for (const chain of customChains) {\n                const { name } = chain;\n                names[chain.chainId.toString()] = name;\n                chains[name] = chain;\n            }\n        }\n        chains.names = names;\n        return chains;\n    }\n}\nexports.Common = Common;\n//# sourceMappingURL=common.js.map"]},"metadata":{},"sourceType":"script"}