{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.treeZeroAfterIndex = exports.iterateNodesAtDepth = exports.getNodesAtDepth = exports.setNodesAtDepth = exports.setNodeAtDepth = exports.getNodeAtDepth = exports.setNodeWithFn = exports.setNode = exports.getNode = exports.Tree = void 0;\n\nconst zeroNode_1 = require(\"./zeroNode\");\n\nconst gindex_1 = require(\"./gindex\");\n\nconst node_1 = require(\"./node\");\n\nconst proof_1 = require(\"./proof\");\n\nconst single_1 = require(\"./proof/single\");\n/**\n * Binary merkle tree\n *\n * Wrapper around immutable `Node` to support mutability.\n *\n * Mutability between a parent tree and subtree is achieved by maintaining a `hook` callback, which updates the parent when the subtree is updated.\n */\n\n\nclass Tree {\n  constructor(node, hook) {\n    this._rootNode = node;\n\n    if (hook) {\n      if (typeof WeakRef === \"undefined\") {\n        this.hook = hook;\n      } else {\n        this.hook = new WeakRef(hook);\n      }\n    }\n  }\n  /**\n   * Create a `Tree` from a `Proof` object\n   */\n\n\n  static createFromProof(proof) {\n    return new Tree(proof_1.createNodeFromProof(proof));\n  }\n  /**\n   * The root node of the tree\n   */\n\n\n  get rootNode() {\n    return this._rootNode;\n  }\n  /**\n   *\n   * Setting the root node will trigger a call to the tree's `hook` if it exists.\n   */\n\n\n  set rootNode(newRootNode) {\n    this._rootNode = newRootNode;\n\n    if (this.hook) {\n      // WeakRef should not change status during a program's execution\n      // So, use WeakRef feature detection to assume the type of this.hook\n      // to minimize the memory footprint of Tree\n      if (typeof WeakRef === \"undefined\") {\n        this.hook(newRootNode);\n      } else {\n        const hookVar = this.hook.deref();\n\n        if (hookVar) {\n          hookVar(newRootNode);\n        } else {\n          // Hook has been garbage collected, no need to keep the hookRef\n          this.hook = undefined;\n        }\n      }\n    }\n  }\n  /**\n   * The root hash of the tree\n   */\n\n\n  get root() {\n    return this.rootNode.root;\n  }\n  /**\n   * Return a copy of the tree\n   */\n\n\n  clone() {\n    return new Tree(this.rootNode);\n  }\n  /**\n   * Return the subtree at the specified gindex.\n   *\n   * Note: The returned subtree will have a `hook` attached to the parent tree.\n   * Updates to the subtree will result in updates to the parent.\n   */\n\n\n  getSubtree(index) {\n    return new Tree(this.getNode(index), node => this.setNode(index, node));\n  }\n  /**\n   * Return the node at the specified gindex.\n   */\n\n\n  getNode(gindex) {\n    return getNode(this.rootNode, gindex);\n  }\n  /**\n   * Return the node at the specified depth and index.\n   *\n   * Supports index up to `Number.MAX_SAFE_INTEGER`.\n   */\n\n\n  getNodeAtDepth(depth, index) {\n    return getNodeAtDepth(this.rootNode, depth, index);\n  }\n  /**\n   * Return the hash at the specified gindex.\n   */\n\n\n  getRoot(index) {\n    return this.getNode(index).root;\n  }\n  /**\n   * Set the node at at the specified gindex.\n   */\n\n\n  setNode(gindex, n) {\n    this.rootNode = setNode(this.rootNode, gindex, n);\n  }\n  /**\n   * Traverse to the node at the specified gindex,\n   * then apply the function to get a new node and set the node at the specified gindex with the result.\n   *\n   * This is a convenient method to avoid traversing the tree 2 times to\n   * get and set.\n   */\n\n\n  setNodeWithFn(gindex, getNewNode) {\n    this.rootNode = setNodeWithFn(this.rootNode, gindex, getNewNode);\n  }\n  /**\n   * Set the node at the specified depth and index.\n   *\n   * Supports index up to `Number.MAX_SAFE_INTEGER`.\n   */\n\n\n  setNodeAtDepth(depth, index, node) {\n    this.rootNode = setNodeAtDepth(this.rootNode, depth, index, node);\n  }\n  /**\n   * Set the hash at the specified gindex.\n   *\n   * Note: This will set a new `LeafNode` at the specified gindex.\n   */\n\n\n  setRoot(index, root) {\n    this.setNode(index, node_1.LeafNode.fromRoot(root));\n  }\n  /**\n   * Fast read-only iteration\n   * In-order traversal of nodes at `depth`\n   * starting from the `startIndex`-indexed node\n   * iterating through `count` nodes\n   *\n   * Supports index up to `Number.MAX_SAFE_INTEGER`.\n   */\n\n\n  getNodesAtDepth(depth, startIndex, count) {\n    return getNodesAtDepth(this.rootNode, depth, startIndex, count);\n  }\n  /**\n   * Fast read-only iteration\n   * In-order traversal of nodes at `depth`\n   * starting from the `startIndex`-indexed node\n   * iterating through `count` nodes\n   *\n   * Supports index up to `Number.MAX_SAFE_INTEGER`.\n   */\n\n\n  iterateNodesAtDepth(depth, startIndex, count) {\n    return iterateNodesAtDepth(this.rootNode, depth, startIndex, count);\n  }\n  /**\n   * Return a merkle proof for the node at the specified gindex.\n   */\n\n\n  getSingleProof(index) {\n    return single_1.createSingleProof(this.rootNode, index)[1];\n  }\n  /**\n   * Return a merkle proof for the proof input.\n   *\n   * This method can be used to create multiproofs.\n   */\n\n\n  getProof(input) {\n    return proof_1.createProof(this.rootNode, input);\n  }\n\n}\n\nexports.Tree = Tree;\n/**\n * Return the node at the specified gindex.\n */\n\nfunction getNode(rootNode, gindex) {\n  const gindexBitstring = gindex_1.convertGindexToBitstring(gindex);\n  let node = rootNode;\n\n  for (let i = 1; i < gindexBitstring.length; i++) {\n    if (node.isLeaf()) {\n      throw new Error(`Invalid tree - found leaf at depth ${i}`);\n    } // If bit is set, means navigate right\n\n\n    node = gindexBitstring[i] === \"1\" ? node.right : node.left;\n  }\n\n  return node;\n}\n\nexports.getNode = getNode;\n/**\n * Set the node at at the specified gindex.\n * Returns the new root node.\n */\n\nfunction setNode(rootNode, gindex, n) {\n  // Pre-compute entire bitstring instead of using an iterator (25% faster)\n  const gindexBitstring = gindex_1.convertGindexToBitstring(gindex);\n  const parentNodes = getParentNodes(rootNode, gindexBitstring);\n  return rebindNodeToRoot(gindexBitstring, parentNodes, n);\n}\n\nexports.setNode = setNode;\n/**\n * Traverse to the node at the specified gindex,\n * then apply the function to get a new node and set the node at the specified gindex with the result.\n *\n * This is a convenient method to avoid traversing the tree 2 times to\n * get and set.\n *\n * Returns the new root node.\n */\n\nfunction setNodeWithFn(rootNode, gindex, getNewNode) {\n  // Pre-compute entire bitstring instead of using an iterator (25% faster)\n  const gindexBitstring = gindex_1.convertGindexToBitstring(gindex);\n  const parentNodes = getParentNodes(rootNode, gindexBitstring);\n  const lastParentNode = parentNodes[parentNodes.length - 1];\n  const lastBit = gindexBitstring[gindexBitstring.length - 1];\n  const oldNode = lastBit === \"1\" ? lastParentNode.right : lastParentNode.left;\n  const newNode = getNewNode(oldNode);\n  return rebindNodeToRoot(gindexBitstring, parentNodes, newNode);\n}\n\nexports.setNodeWithFn = setNodeWithFn;\n/**\n * Traverse the tree from root node, ignore the last bit to get all parent nodes\n * of the specified bitstring.\n */\n\nfunction getParentNodes(rootNode, bitstring) {\n  let node = rootNode; // Keep a list of all parent nodes of node at gindex `index`. Then walk the list\n  // backwards to rebind them \"recursively\" with the new nodes without using functions\n\n  const parentNodes = [rootNode]; // Ignore the first bit, left right directions are at bits [1,..]\n  // Ignore the last bit, no need to push the target node to the parentNodes array\n\n  for (let i = 1; i < bitstring.length - 1; i++) {\n    // Compare to string directly to prevent unnecessary type conversions\n    if (bitstring[i] === \"1\") {\n      node = node.right;\n    } else {\n      node = node.left;\n    }\n\n    parentNodes.push(node);\n  }\n\n  return parentNodes;\n}\n/**\n * Build a new tree structure from bitstring, parentNodes and a new node.\n * Returns the new root node.\n */\n\n\nfunction rebindNodeToRoot(bitstring, parentNodes, newNode) {\n  let node = newNode; // Ignore the first bit, left right directions are at bits [1,..]\n  // Iterate the list backwards including the last bit, but offset the parentNodes array\n  // by one since the first bit in bitstring was ignored in the previous loop\n\n  for (let i = bitstring.length - 1; i >= 1; i--) {\n    if (bitstring[i] === \"1\") {\n      node = new node_1.BranchNode(parentNodes[i - 1].left, node);\n    } else {\n      node = new node_1.BranchNode(node, parentNodes[i - 1].right);\n    }\n  }\n\n  return node;\n}\n/**\n * Supports index up to `Number.MAX_SAFE_INTEGER`.\n */\n\n\nfunction getNodeAtDepth(rootNode, depth, index) {\n  if (depth === 0) {\n    return rootNode;\n  }\n\n  if (depth === 1) {\n    return index === 0 ? rootNode.left : rootNode.right;\n  } // Ignore first bit \"1\", then substract 1 to get to the parent\n\n\n  const depthiRoot = depth - 1;\n  const depthiParent = 0;\n  let node = rootNode;\n\n  for (let d = depthiRoot; d >= depthiParent; d--) {\n    node = isLeftNode(d, index) ? node.left : node.right;\n  }\n\n  return node;\n}\n\nexports.getNodeAtDepth = getNodeAtDepth;\n/**\n * Supports index up to `Number.MAX_SAFE_INTEGER`.\n */\n\nfunction setNodeAtDepth(rootNode, nodesDepth, index, nodeChanged) {\n  // TODO: OPTIMIZE (if necessary)\n  return setNodesAtDepth(rootNode, nodesDepth, [index], [nodeChanged]);\n}\n\nexports.setNodeAtDepth = setNodeAtDepth;\n/**\n * Set multiple nodes in batch, editing and traversing nodes strictly once.\n *\n * - gindexes MUST be sorted in ascending order beforehand.\n * - All gindexes must be at the exact same depth.\n * - Depth must be > 0, if 0 just replace the root node.\n *\n * Strategy: for each gindex in `gindexes` navigate to the depth of its parent,\n * and create a new parent. Then calculate the closest common depth with the next\n * gindex and navigate upwards creating or caching nodes as necessary. Loop and repeat.\n *\n * Supports index up to `Number.MAX_SAFE_INTEGER`.\n */\n\nfunction setNodesAtDepth(rootNode, nodesDepth, indexes, nodes) {\n  // depth depthi   gindexes   indexes\n  // 0     1           1          0\n  // 1     0         2   3      0   1\n  // 2     -        4 5 6 7    0 1 2 3\n  // '10' means, at depth 1, node is at the left\n  //\n  // For index N check if the bit at position depthi is set to navigate right at depthi\n  // ```\n  // mask = 1 << depthi\n  // goRight = (N & mask) == mask\n  // ```\n  // If depth is 0 there's only one node max and the optimization below will cause a navigation error.\n  // For this case, check if there's a new root node and return it, otherwise the current rootNode.\n  if (nodesDepth === 0) {\n    return nodes.length > 0 ? nodes[0] : rootNode;\n  }\n  /**\n   * Contiguous filled stack of parent nodes. It get filled in the first descent\n   * Indexed by depthi\n   */\n\n\n  const parentNodeStack = new Array(nodesDepth);\n  /**\n   * Temp stack of left parent nodes, index by depthi.\n   * Node leftParentNodeStack[depthi] is a node at d = depthi - 1, such that:\n   * ```\n   * parentNodeStack[depthi].left = leftParentNodeStack[depthi]\n   * ```\n   */\n\n  const leftParentNodeStack = new Array(nodesDepth); // Ignore first bit \"1\", then substract 1 to get to the parent\n\n  const depthiRoot = nodesDepth - 1;\n  const depthiParent = 0;\n  let depthi = depthiRoot;\n  let node = rootNode; // Insert root node to make the loop below general\n\n  parentNodeStack[depthiRoot] = rootNode; // TODO: Iterate to depth 32 to allow using bit ops\n  // for (; depthi >= 32; depthi--) {\n  //   node = node.left;\n  // }\n\n  for (let i = 0; i < indexes.length; i++) {\n    const index = indexes[i]; // Navigate down until parent depth, and store the chain of nodes\n    //\n    // Starts from latest common depth, so node is the parent node at `depthi`\n    // When persisting the next node, store at the `d - 1` since its the child of node at `depthi`\n    //\n    // Stops at the level above depthiParent. For the re-binding routing below node must be at depthiParent\n\n    for (let d = depthi; d > depthiParent; d--) {\n      node = isLeftNode(d, index) ? node.left : node.right;\n      parentNodeStack[d - 1] = node;\n    }\n\n    depthi = depthiParent; // If this is the left node, check first it the next node is on the right\n    //\n    //   -    If both nodes exist, create new\n    //  / \\\n    // x   x\n    //\n    //   -    If only the left node exists, rebind left\n    //  / \\\n    // x   -\n    //\n    //   -    If this is the right node, only the right node exists, rebind right\n    //  / \\\n    // -   x\n    // d = 0, mask = 1 << d = 1\n\n    const isLeftLeafNode = (index & 1) !== 1;\n\n    if (isLeftLeafNode) {\n      // Next node is the very next to the right of current node\n      if (index + 1 === indexes[i + 1]) {\n        node = new node_1.BranchNode(nodes[i], nodes[i + 1]); // Move pointer one extra forward since node has consumed two nodes\n\n        i++;\n      } else {\n        node = new node_1.BranchNode(nodes[i], node.right);\n      }\n    } else {\n      node = new node_1.BranchNode(node.left, nodes[i]);\n    } // Here `node` is the new BranchNode at depthi `depthiParent`\n    // Now climb upwards until finding the common node with the next index\n    // For the last iteration, climb to the root at `depthiRoot`\n\n\n    const isLastIndex = i >= indexes.length - 1;\n    const diffDepthi = isLastIndex ? depthiRoot : findDiffDepthi(index, indexes[i + 1]); // When climbing up from a left node there are two possible paths\n    // 1. Go to the right of the parent: Store left node to rebind latter\n    // 2. Go another level up: Will never visit the left node again, so must rebind now\n    // 🡼 \\     Rebind left only, will never visit this node again\n    // 🡽 /\\\n    //\n    //    / 🡽  Rebind left only (same as above)\n    // 🡽 /\\\n    //\n    // 🡽 /\\ 🡾  Store left node to rebind the entire node when returning\n    //\n    // 🡼 \\     Rebind right with left if exists, will never visit this node again\n    //   /\\ 🡼\n    //\n    //    / 🡽  Rebind right with left if exists (same as above)\n    //   /\\ 🡼\n\n    for (let d = depthiParent + 1; d <= diffDepthi; d++) {\n      // If node is on the left, store for latter\n      // If node is on the right merge with stored left node\n      if (isLeftNode(d, index)) {\n        if (isLastIndex || d !== diffDepthi) {\n          // If it's last index, bind with parent since it won't navigate to the right anymore\n          // Also, if still has to move upwards, rebind since the node won't be visited anymore\n          node = new node_1.BranchNode(node, parentNodeStack[d].right);\n        } else {\n          // Only store the left node if it's at d = diffDepth\n          leftParentNodeStack[d] = node;\n          node = parentNodeStack[d];\n        }\n      } else {\n        const leftNode = leftParentNodeStack[d];\n\n        if (leftNode !== undefined) {\n          node = new node_1.BranchNode(leftNode, node);\n          leftParentNodeStack[d] = undefined;\n        } else {\n          node = new node_1.BranchNode(parentNodeStack[d].left, node);\n        }\n      }\n    } // Prepare next loop\n    // Go to the parent of the depth with diff, to switch branches to the right\n\n\n    depthi = diffDepthi;\n  } // Done, return new root node\n\n\n  return node;\n}\n\nexports.setNodesAtDepth = setNodesAtDepth;\n/**\n * Fast read-only iteration\n * In-order traversal of nodes at `depth`\n * starting from the `startIndex`-indexed node\n * iterating through `count` nodes\n *\n * **Strategy**\n * 1. Navigate down to parentDepth storing a stack of parents\n * 2. At target level push current node\n * 3. Go up to the first level that navigated left\n * 4. Repeat (1) for next index\n */\n\nfunction getNodesAtDepth(rootNode, depth, startIndex, count) {\n  // Optimized paths for short trees (x20 times faster)\n  if (depth === 0) {\n    return startIndex === 0 && count > 0 ? [rootNode] : [];\n  } else if (depth === 1) {\n    if (count === 0) {\n      return [];\n    } else if (count === 1) {\n      return startIndex === 0 ? [rootNode.left] : [rootNode.right];\n    } else {\n      return [rootNode.left, rootNode.right];\n    }\n  } // Ignore first bit \"1\", then substract 1 to get to the parent\n\n\n  const depthiRoot = depth - 1;\n  const depthiParent = 0;\n  let depthi = depthiRoot;\n  let node = rootNode; // Contiguous filled stack of parent nodes. It get filled in the first descent\n  // Indexed by depthi\n\n  const parentNodeStack = new Array(depth);\n  const isLeftStack = new Array(depth);\n  const nodes = new Array(count); // Insert root node to make the loop below general\n\n  parentNodeStack[depthiRoot] = rootNode;\n\n  for (let i = 0; i < count; i++) {\n    for (let d = depthi; d >= depthiParent; d--) {\n      if (d !== depthi) {\n        parentNodeStack[d] = node;\n      }\n\n      const isLeft = isLeftNode(d, startIndex + i);\n      isLeftStack[d] = isLeft;\n      node = isLeft ? node.left : node.right;\n    }\n\n    nodes[i] = node; // Find the first depth where navigation when left.\n    // Store that height and go right from there\n\n    for (let d = depthiParent; d <= depthiRoot; d++) {\n      if (isLeftStack[d] === true) {\n        depthi = d;\n        break;\n      }\n    }\n\n    node = parentNodeStack[depthi];\n  }\n\n  return nodes;\n}\n\nexports.getNodesAtDepth = getNodesAtDepth;\n/**\n * @see getNodesAtDepth but instead of pushing to an array, it yields\n */\n\nfunction* iterateNodesAtDepth(rootNode, depth, startIndex, count) {\n  const endIndex = startIndex + count; // Ignore first bit \"1\", then substract 1 to get to the parent\n\n  const depthiRoot = depth - 1;\n  const depthiParent = 0;\n  let depthi = depthiRoot;\n  let node = rootNode; // Contiguous filled stack of parent nodes. It get filled in the first descent\n  // Indexed by depthi\n\n  const parentNodeStack = new Array(depth);\n  const isLeftStack = new Array(depth); // Insert root node to make the loop below general\n\n  parentNodeStack[depthiRoot] = rootNode;\n\n  for (let index = startIndex; index < endIndex; index++) {\n    for (let d = depthi; d >= depthiParent; d--) {\n      if (d !== depthi) {\n        parentNodeStack[d] = node;\n      }\n\n      const isLeft = isLeftNode(d, index);\n      isLeftStack[d] = isLeft;\n      node = isLeft ? node.left : node.right;\n    }\n\n    yield node; // Find the first depth where navigation when left.\n    // Store that height and go right from there\n\n    for (let d = depthiParent; d <= depthiRoot; d++) {\n      if (isLeftStack[d] === true) {\n        depthi = d;\n        break;\n      }\n    }\n\n    node = parentNodeStack[depthi];\n  }\n}\n\nexports.iterateNodesAtDepth = iterateNodesAtDepth;\n/**\n * Zero's all nodes right of index with constant depth of `nodesDepth`.\n *\n * For example, zero-ing this tree at depth 2 after index 0\n * ```\n *    X              X\n *  X   X    ->    X   0\n * X X X X        X 0 0 0\n * ```\n *\n * Or, zero-ing this tree at depth 3 after index 2\n * ```\n *        X                     X\n *    X       X             X       0\n *  X   X   X   X    ->   X   X   0   0\n * X X X X X X X X       X X X 0 0 0 0 0\n * ```\n *\n * The strategy is to first navigate down to `nodesDepth` and `index` and keep a stack of parents.\n * Then navigate up re-binding:\n * - If navigated to the left rebind with zeroNode()\n * - If navigated to the right rebind with parent.left from the stack\n */\n\nfunction treeZeroAfterIndex(rootNode, nodesDepth, index) {\n  // depth depthi   gindexes   indexes\n  // 0     1           1          0\n  // 1     0         2   3      0   1\n  // 2     -        4 5 6 7    0 1 2 3\n  // '10' means, at depth 1, node is at the left\n  //\n  // For index N check if the bit at position depthi is set to navigate right at depthi\n  // ```\n  // mask = 1 << depthi\n  // goRight = (N & mask) == mask\n  // ```\n  // Degenerate case where tree is zero after a negative index (-1).\n  // All positive indexes are zero, so the entire tree is zero. Return cached zero node as root.\n  if (index < 0) {\n    return zeroNode_1.zeroNode(nodesDepth);\n  }\n  /**\n   * Contiguous filled stack of parent nodes. It get filled in the first descent\n   * Indexed by depthi\n   */\n\n\n  const parentNodeStack = new Array(nodesDepth); // Ignore first bit \"1\", then substract 1 to get to the parent\n\n  const depthiRoot = nodesDepth - 1;\n  const depthiParent = 0;\n  let depthi = depthiRoot;\n  let node = rootNode; // Insert root node to make the loop below general\n\n  parentNodeStack[depthiRoot] = rootNode; // Navigate down until parent depth, and store the chain of nodes\n  //\n  // Stops at the depthiParent level. To rebind below down to `nodesDepth`\n\n  for (let d = depthi; d >= depthiParent; d--) {\n    node = isLeftNode(d, index) ? node.left : node.right;\n    parentNodeStack[d - 1] = node;\n  }\n\n  depthi = depthiParent; // Now climb up re-binding with either zero of existing tree.\n\n  for (let d = depthiParent; d <= depthiRoot; d++) {\n    if (isLeftNode(d, index)) {\n      // If navigated to the left, then all the child nodes of the right node are NOT part of the new tree.\n      // So re-bind new `node` with a zeroNode at the current depth.\n      node = new node_1.BranchNode(node, zeroNode_1.zeroNode(d));\n    } else {\n      // If navigated to the right, then all the child nodes of the left node are part of the new tree.\n      // So re-bind new `node` with the existing left node of the parent.\n      node = new node_1.BranchNode(parentNodeStack[d].left, node);\n    }\n  } // Done, return new root node\n\n\n  return node;\n}\n\nexports.treeZeroAfterIndex = treeZeroAfterIndex;\n/**\n * Returns true if the `index` at `depth` is a left node, false if it is a right node.\n *\n * Supports index up to `Number.MAX_SAFE_INTEGER`.\n * In Eth2 case the biggest tree's index is 2**40 (VALIDATOR_REGISTRY_LIMIT)\n */\n\nfunction isLeftNode(depthi, index) {\n  if (depthi > 31) {\n    // Javascript can only do bitwise ops with 32 bit numbers.\n    // Shifting left 1 by 32 wraps around and becomes 1.\n    // Get the high part of `index` and adjust depthi\n    const indexHi = index / 2 ** 32 >>> 0;\n    const mask = 1 << depthi - 32;\n    return (indexHi & mask) !== mask;\n  }\n\n  const mask = 1 << depthi;\n  return (index & mask) !== mask;\n}\n/**\n * depth depthi   gindexes   indexes\n * 0     1           1          0\n * 1     0         2   3      0   1\n * 2     -        4 5 6 7    0 1 2 3\n *\n * **Conditions**:\n * - `from` and `to` must not be equal\n *\n * @param from Index\n * @param to Index\n */\n\n\nfunction findDiffDepthi(from, to) {\n  return (// (0,0) -> 0 | (0,1) -> 1 | (0,2) -> 2\n    Math.ceil(Math.log2(-~(from ^ to))) - // Must offset by one to match the depthi scale\n    1\n  );\n}","map":{"version":3,"sources":["/Users/dev3rs/provipdiploma/node_modules/@chainsafe/persistent-merkle-tree/lib/tree.js"],"names":["Object","defineProperty","exports","value","treeZeroAfterIndex","iterateNodesAtDepth","getNodesAtDepth","setNodesAtDepth","setNodeAtDepth","getNodeAtDepth","setNodeWithFn","setNode","getNode","Tree","zeroNode_1","require","gindex_1","node_1","proof_1","single_1","constructor","node","hook","_rootNode","WeakRef","createFromProof","proof","createNodeFromProof","rootNode","newRootNode","hookVar","deref","undefined","root","clone","getSubtree","index","gindex","depth","getRoot","n","getNewNode","setRoot","LeafNode","fromRoot","startIndex","count","getSingleProof","createSingleProof","getProof","input","createProof","gindexBitstring","convertGindexToBitstring","i","length","isLeaf","Error","right","left","parentNodes","getParentNodes","rebindNodeToRoot","lastParentNode","lastBit","oldNode","newNode","bitstring","push","BranchNode","depthiRoot","depthiParent","d","isLeftNode","nodesDepth","nodeChanged","indexes","nodes","parentNodeStack","Array","leftParentNodeStack","depthi","isLeftLeafNode","isLastIndex","diffDepthi","findDiffDepthi","leftNode","isLeftStack","isLeft","endIndex","zeroNode","indexHi","mask","from","to","Math","ceil","log2"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.treeZeroAfterIndex = exports.iterateNodesAtDepth = exports.getNodesAtDepth = exports.setNodesAtDepth = exports.setNodeAtDepth = exports.getNodeAtDepth = exports.setNodeWithFn = exports.setNode = exports.getNode = exports.Tree = void 0;\nconst zeroNode_1 = require(\"./zeroNode\");\nconst gindex_1 = require(\"./gindex\");\nconst node_1 = require(\"./node\");\nconst proof_1 = require(\"./proof\");\nconst single_1 = require(\"./proof/single\");\n/**\n * Binary merkle tree\n *\n * Wrapper around immutable `Node` to support mutability.\n *\n * Mutability between a parent tree and subtree is achieved by maintaining a `hook` callback, which updates the parent when the subtree is updated.\n */\nclass Tree {\n    constructor(node, hook) {\n        this._rootNode = node;\n        if (hook) {\n            if (typeof WeakRef === \"undefined\") {\n                this.hook = hook;\n            }\n            else {\n                this.hook = new WeakRef(hook);\n            }\n        }\n    }\n    /**\n     * Create a `Tree` from a `Proof` object\n     */\n    static createFromProof(proof) {\n        return new Tree(proof_1.createNodeFromProof(proof));\n    }\n    /**\n     * The root node of the tree\n     */\n    get rootNode() {\n        return this._rootNode;\n    }\n    /**\n     *\n     * Setting the root node will trigger a call to the tree's `hook` if it exists.\n     */\n    set rootNode(newRootNode) {\n        this._rootNode = newRootNode;\n        if (this.hook) {\n            // WeakRef should not change status during a program's execution\n            // So, use WeakRef feature detection to assume the type of this.hook\n            // to minimize the memory footprint of Tree\n            if (typeof WeakRef === \"undefined\") {\n                this.hook(newRootNode);\n            }\n            else {\n                const hookVar = this.hook.deref();\n                if (hookVar) {\n                    hookVar(newRootNode);\n                }\n                else {\n                    // Hook has been garbage collected, no need to keep the hookRef\n                    this.hook = undefined;\n                }\n            }\n        }\n    }\n    /**\n     * The root hash of the tree\n     */\n    get root() {\n        return this.rootNode.root;\n    }\n    /**\n     * Return a copy of the tree\n     */\n    clone() {\n        return new Tree(this.rootNode);\n    }\n    /**\n     * Return the subtree at the specified gindex.\n     *\n     * Note: The returned subtree will have a `hook` attached to the parent tree.\n     * Updates to the subtree will result in updates to the parent.\n     */\n    getSubtree(index) {\n        return new Tree(this.getNode(index), (node) => this.setNode(index, node));\n    }\n    /**\n     * Return the node at the specified gindex.\n     */\n    getNode(gindex) {\n        return getNode(this.rootNode, gindex);\n    }\n    /**\n     * Return the node at the specified depth and index.\n     *\n     * Supports index up to `Number.MAX_SAFE_INTEGER`.\n     */\n    getNodeAtDepth(depth, index) {\n        return getNodeAtDepth(this.rootNode, depth, index);\n    }\n    /**\n     * Return the hash at the specified gindex.\n     */\n    getRoot(index) {\n        return this.getNode(index).root;\n    }\n    /**\n     * Set the node at at the specified gindex.\n     */\n    setNode(gindex, n) {\n        this.rootNode = setNode(this.rootNode, gindex, n);\n    }\n    /**\n     * Traverse to the node at the specified gindex,\n     * then apply the function to get a new node and set the node at the specified gindex with the result.\n     *\n     * This is a convenient method to avoid traversing the tree 2 times to\n     * get and set.\n     */\n    setNodeWithFn(gindex, getNewNode) {\n        this.rootNode = setNodeWithFn(this.rootNode, gindex, getNewNode);\n    }\n    /**\n     * Set the node at the specified depth and index.\n     *\n     * Supports index up to `Number.MAX_SAFE_INTEGER`.\n     */\n    setNodeAtDepth(depth, index, node) {\n        this.rootNode = setNodeAtDepth(this.rootNode, depth, index, node);\n    }\n    /**\n     * Set the hash at the specified gindex.\n     *\n     * Note: This will set a new `LeafNode` at the specified gindex.\n     */\n    setRoot(index, root) {\n        this.setNode(index, node_1.LeafNode.fromRoot(root));\n    }\n    /**\n     * Fast read-only iteration\n     * In-order traversal of nodes at `depth`\n     * starting from the `startIndex`-indexed node\n     * iterating through `count` nodes\n     *\n     * Supports index up to `Number.MAX_SAFE_INTEGER`.\n     */\n    getNodesAtDepth(depth, startIndex, count) {\n        return getNodesAtDepth(this.rootNode, depth, startIndex, count);\n    }\n    /**\n     * Fast read-only iteration\n     * In-order traversal of nodes at `depth`\n     * starting from the `startIndex`-indexed node\n     * iterating through `count` nodes\n     *\n     * Supports index up to `Number.MAX_SAFE_INTEGER`.\n     */\n    iterateNodesAtDepth(depth, startIndex, count) {\n        return iterateNodesAtDepth(this.rootNode, depth, startIndex, count);\n    }\n    /**\n     * Return a merkle proof for the node at the specified gindex.\n     */\n    getSingleProof(index) {\n        return single_1.createSingleProof(this.rootNode, index)[1];\n    }\n    /**\n     * Return a merkle proof for the proof input.\n     *\n     * This method can be used to create multiproofs.\n     */\n    getProof(input) {\n        return proof_1.createProof(this.rootNode, input);\n    }\n}\nexports.Tree = Tree;\n/**\n * Return the node at the specified gindex.\n */\nfunction getNode(rootNode, gindex) {\n    const gindexBitstring = gindex_1.convertGindexToBitstring(gindex);\n    let node = rootNode;\n    for (let i = 1; i < gindexBitstring.length; i++) {\n        if (node.isLeaf()) {\n            throw new Error(`Invalid tree - found leaf at depth ${i}`);\n        }\n        // If bit is set, means navigate right\n        node = gindexBitstring[i] === \"1\" ? node.right : node.left;\n    }\n    return node;\n}\nexports.getNode = getNode;\n/**\n * Set the node at at the specified gindex.\n * Returns the new root node.\n */\nfunction setNode(rootNode, gindex, n) {\n    // Pre-compute entire bitstring instead of using an iterator (25% faster)\n    const gindexBitstring = gindex_1.convertGindexToBitstring(gindex);\n    const parentNodes = getParentNodes(rootNode, gindexBitstring);\n    return rebindNodeToRoot(gindexBitstring, parentNodes, n);\n}\nexports.setNode = setNode;\n/**\n * Traverse to the node at the specified gindex,\n * then apply the function to get a new node and set the node at the specified gindex with the result.\n *\n * This is a convenient method to avoid traversing the tree 2 times to\n * get and set.\n *\n * Returns the new root node.\n */\nfunction setNodeWithFn(rootNode, gindex, getNewNode) {\n    // Pre-compute entire bitstring instead of using an iterator (25% faster)\n    const gindexBitstring = gindex_1.convertGindexToBitstring(gindex);\n    const parentNodes = getParentNodes(rootNode, gindexBitstring);\n    const lastParentNode = parentNodes[parentNodes.length - 1];\n    const lastBit = gindexBitstring[gindexBitstring.length - 1];\n    const oldNode = lastBit === \"1\" ? lastParentNode.right : lastParentNode.left;\n    const newNode = getNewNode(oldNode);\n    return rebindNodeToRoot(gindexBitstring, parentNodes, newNode);\n}\nexports.setNodeWithFn = setNodeWithFn;\n/**\n * Traverse the tree from root node, ignore the last bit to get all parent nodes\n * of the specified bitstring.\n */\nfunction getParentNodes(rootNode, bitstring) {\n    let node = rootNode;\n    // Keep a list of all parent nodes of node at gindex `index`. Then walk the list\n    // backwards to rebind them \"recursively\" with the new nodes without using functions\n    const parentNodes = [rootNode];\n    // Ignore the first bit, left right directions are at bits [1,..]\n    // Ignore the last bit, no need to push the target node to the parentNodes array\n    for (let i = 1; i < bitstring.length - 1; i++) {\n        // Compare to string directly to prevent unnecessary type conversions\n        if (bitstring[i] === \"1\") {\n            node = node.right;\n        }\n        else {\n            node = node.left;\n        }\n        parentNodes.push(node);\n    }\n    return parentNodes;\n}\n/**\n * Build a new tree structure from bitstring, parentNodes and a new node.\n * Returns the new root node.\n */\nfunction rebindNodeToRoot(bitstring, parentNodes, newNode) {\n    let node = newNode;\n    // Ignore the first bit, left right directions are at bits [1,..]\n    // Iterate the list backwards including the last bit, but offset the parentNodes array\n    // by one since the first bit in bitstring was ignored in the previous loop\n    for (let i = bitstring.length - 1; i >= 1; i--) {\n        if (bitstring[i] === \"1\") {\n            node = new node_1.BranchNode(parentNodes[i - 1].left, node);\n        }\n        else {\n            node = new node_1.BranchNode(node, parentNodes[i - 1].right);\n        }\n    }\n    return node;\n}\n/**\n * Supports index up to `Number.MAX_SAFE_INTEGER`.\n */\nfunction getNodeAtDepth(rootNode, depth, index) {\n    if (depth === 0) {\n        return rootNode;\n    }\n    if (depth === 1) {\n        return index === 0 ? rootNode.left : rootNode.right;\n    }\n    // Ignore first bit \"1\", then substract 1 to get to the parent\n    const depthiRoot = depth - 1;\n    const depthiParent = 0;\n    let node = rootNode;\n    for (let d = depthiRoot; d >= depthiParent; d--) {\n        node = isLeftNode(d, index) ? node.left : node.right;\n    }\n    return node;\n}\nexports.getNodeAtDepth = getNodeAtDepth;\n/**\n * Supports index up to `Number.MAX_SAFE_INTEGER`.\n */\nfunction setNodeAtDepth(rootNode, nodesDepth, index, nodeChanged) {\n    // TODO: OPTIMIZE (if necessary)\n    return setNodesAtDepth(rootNode, nodesDepth, [index], [nodeChanged]);\n}\nexports.setNodeAtDepth = setNodeAtDepth;\n/**\n * Set multiple nodes in batch, editing and traversing nodes strictly once.\n *\n * - gindexes MUST be sorted in ascending order beforehand.\n * - All gindexes must be at the exact same depth.\n * - Depth must be > 0, if 0 just replace the root node.\n *\n * Strategy: for each gindex in `gindexes` navigate to the depth of its parent,\n * and create a new parent. Then calculate the closest common depth with the next\n * gindex and navigate upwards creating or caching nodes as necessary. Loop and repeat.\n *\n * Supports index up to `Number.MAX_SAFE_INTEGER`.\n */\nfunction setNodesAtDepth(rootNode, nodesDepth, indexes, nodes) {\n    // depth depthi   gindexes   indexes\n    // 0     1           1          0\n    // 1     0         2   3      0   1\n    // 2     -        4 5 6 7    0 1 2 3\n    // '10' means, at depth 1, node is at the left\n    //\n    // For index N check if the bit at position depthi is set to navigate right at depthi\n    // ```\n    // mask = 1 << depthi\n    // goRight = (N & mask) == mask\n    // ```\n    // If depth is 0 there's only one node max and the optimization below will cause a navigation error.\n    // For this case, check if there's a new root node and return it, otherwise the current rootNode.\n    if (nodesDepth === 0) {\n        return nodes.length > 0 ? nodes[0] : rootNode;\n    }\n    /**\n     * Contiguous filled stack of parent nodes. It get filled in the first descent\n     * Indexed by depthi\n     */\n    const parentNodeStack = new Array(nodesDepth);\n    /**\n     * Temp stack of left parent nodes, index by depthi.\n     * Node leftParentNodeStack[depthi] is a node at d = depthi - 1, such that:\n     * ```\n     * parentNodeStack[depthi].left = leftParentNodeStack[depthi]\n     * ```\n     */\n    const leftParentNodeStack = new Array(nodesDepth);\n    // Ignore first bit \"1\", then substract 1 to get to the parent\n    const depthiRoot = nodesDepth - 1;\n    const depthiParent = 0;\n    let depthi = depthiRoot;\n    let node = rootNode;\n    // Insert root node to make the loop below general\n    parentNodeStack[depthiRoot] = rootNode;\n    // TODO: Iterate to depth 32 to allow using bit ops\n    // for (; depthi >= 32; depthi--) {\n    //   node = node.left;\n    // }\n    for (let i = 0; i < indexes.length; i++) {\n        const index = indexes[i];\n        // Navigate down until parent depth, and store the chain of nodes\n        //\n        // Starts from latest common depth, so node is the parent node at `depthi`\n        // When persisting the next node, store at the `d - 1` since its the child of node at `depthi`\n        //\n        // Stops at the level above depthiParent. For the re-binding routing below node must be at depthiParent\n        for (let d = depthi; d > depthiParent; d--) {\n            node = isLeftNode(d, index) ? node.left : node.right;\n            parentNodeStack[d - 1] = node;\n        }\n        depthi = depthiParent;\n        // If this is the left node, check first it the next node is on the right\n        //\n        //   -    If both nodes exist, create new\n        //  / \\\n        // x   x\n        //\n        //   -    If only the left node exists, rebind left\n        //  / \\\n        // x   -\n        //\n        //   -    If this is the right node, only the right node exists, rebind right\n        //  / \\\n        // -   x\n        // d = 0, mask = 1 << d = 1\n        const isLeftLeafNode = (index & 1) !== 1;\n        if (isLeftLeafNode) {\n            // Next node is the very next to the right of current node\n            if (index + 1 === indexes[i + 1]) {\n                node = new node_1.BranchNode(nodes[i], nodes[i + 1]);\n                // Move pointer one extra forward since node has consumed two nodes\n                i++;\n            }\n            else {\n                node = new node_1.BranchNode(nodes[i], node.right);\n            }\n        }\n        else {\n            node = new node_1.BranchNode(node.left, nodes[i]);\n        }\n        // Here `node` is the new BranchNode at depthi `depthiParent`\n        // Now climb upwards until finding the common node with the next index\n        // For the last iteration, climb to the root at `depthiRoot`\n        const isLastIndex = i >= indexes.length - 1;\n        const diffDepthi = isLastIndex ? depthiRoot : findDiffDepthi(index, indexes[i + 1]);\n        // When climbing up from a left node there are two possible paths\n        // 1. Go to the right of the parent: Store left node to rebind latter\n        // 2. Go another level up: Will never visit the left node again, so must rebind now\n        // 🡼 \\     Rebind left only, will never visit this node again\n        // 🡽 /\\\n        //\n        //    / 🡽  Rebind left only (same as above)\n        // 🡽 /\\\n        //\n        // 🡽 /\\ 🡾  Store left node to rebind the entire node when returning\n        //\n        // 🡼 \\     Rebind right with left if exists, will never visit this node again\n        //   /\\ 🡼\n        //\n        //    / 🡽  Rebind right with left if exists (same as above)\n        //   /\\ 🡼\n        for (let d = depthiParent + 1; d <= diffDepthi; d++) {\n            // If node is on the left, store for latter\n            // If node is on the right merge with stored left node\n            if (isLeftNode(d, index)) {\n                if (isLastIndex || d !== diffDepthi) {\n                    // If it's last index, bind with parent since it won't navigate to the right anymore\n                    // Also, if still has to move upwards, rebind since the node won't be visited anymore\n                    node = new node_1.BranchNode(node, parentNodeStack[d].right);\n                }\n                else {\n                    // Only store the left node if it's at d = diffDepth\n                    leftParentNodeStack[d] = node;\n                    node = parentNodeStack[d];\n                }\n            }\n            else {\n                const leftNode = leftParentNodeStack[d];\n                if (leftNode !== undefined) {\n                    node = new node_1.BranchNode(leftNode, node);\n                    leftParentNodeStack[d] = undefined;\n                }\n                else {\n                    node = new node_1.BranchNode(parentNodeStack[d].left, node);\n                }\n            }\n        }\n        // Prepare next loop\n        // Go to the parent of the depth with diff, to switch branches to the right\n        depthi = diffDepthi;\n    }\n    // Done, return new root node\n    return node;\n}\nexports.setNodesAtDepth = setNodesAtDepth;\n/**\n * Fast read-only iteration\n * In-order traversal of nodes at `depth`\n * starting from the `startIndex`-indexed node\n * iterating through `count` nodes\n *\n * **Strategy**\n * 1. Navigate down to parentDepth storing a stack of parents\n * 2. At target level push current node\n * 3. Go up to the first level that navigated left\n * 4. Repeat (1) for next index\n */\nfunction getNodesAtDepth(rootNode, depth, startIndex, count) {\n    // Optimized paths for short trees (x20 times faster)\n    if (depth === 0) {\n        return startIndex === 0 && count > 0 ? [rootNode] : [];\n    }\n    else if (depth === 1) {\n        if (count === 0) {\n            return [];\n        }\n        else if (count === 1) {\n            return startIndex === 0 ? [rootNode.left] : [rootNode.right];\n        }\n        else {\n            return [rootNode.left, rootNode.right];\n        }\n    }\n    // Ignore first bit \"1\", then substract 1 to get to the parent\n    const depthiRoot = depth - 1;\n    const depthiParent = 0;\n    let depthi = depthiRoot;\n    let node = rootNode;\n    // Contiguous filled stack of parent nodes. It get filled in the first descent\n    // Indexed by depthi\n    const parentNodeStack = new Array(depth);\n    const isLeftStack = new Array(depth);\n    const nodes = new Array(count);\n    // Insert root node to make the loop below general\n    parentNodeStack[depthiRoot] = rootNode;\n    for (let i = 0; i < count; i++) {\n        for (let d = depthi; d >= depthiParent; d--) {\n            if (d !== depthi) {\n                parentNodeStack[d] = node;\n            }\n            const isLeft = isLeftNode(d, startIndex + i);\n            isLeftStack[d] = isLeft;\n            node = isLeft ? node.left : node.right;\n        }\n        nodes[i] = node;\n        // Find the first depth where navigation when left.\n        // Store that height and go right from there\n        for (let d = depthiParent; d <= depthiRoot; d++) {\n            if (isLeftStack[d] === true) {\n                depthi = d;\n                break;\n            }\n        }\n        node = parentNodeStack[depthi];\n    }\n    return nodes;\n}\nexports.getNodesAtDepth = getNodesAtDepth;\n/**\n * @see getNodesAtDepth but instead of pushing to an array, it yields\n */\nfunction* iterateNodesAtDepth(rootNode, depth, startIndex, count) {\n    const endIndex = startIndex + count;\n    // Ignore first bit \"1\", then substract 1 to get to the parent\n    const depthiRoot = depth - 1;\n    const depthiParent = 0;\n    let depthi = depthiRoot;\n    let node = rootNode;\n    // Contiguous filled stack of parent nodes. It get filled in the first descent\n    // Indexed by depthi\n    const parentNodeStack = new Array(depth);\n    const isLeftStack = new Array(depth);\n    // Insert root node to make the loop below general\n    parentNodeStack[depthiRoot] = rootNode;\n    for (let index = startIndex; index < endIndex; index++) {\n        for (let d = depthi; d >= depthiParent; d--) {\n            if (d !== depthi) {\n                parentNodeStack[d] = node;\n            }\n            const isLeft = isLeftNode(d, index);\n            isLeftStack[d] = isLeft;\n            node = isLeft ? node.left : node.right;\n        }\n        yield node;\n        // Find the first depth where navigation when left.\n        // Store that height and go right from there\n        for (let d = depthiParent; d <= depthiRoot; d++) {\n            if (isLeftStack[d] === true) {\n                depthi = d;\n                break;\n            }\n        }\n        node = parentNodeStack[depthi];\n    }\n}\nexports.iterateNodesAtDepth = iterateNodesAtDepth;\n/**\n * Zero's all nodes right of index with constant depth of `nodesDepth`.\n *\n * For example, zero-ing this tree at depth 2 after index 0\n * ```\n *    X              X\n *  X   X    ->    X   0\n * X X X X        X 0 0 0\n * ```\n *\n * Or, zero-ing this tree at depth 3 after index 2\n * ```\n *        X                     X\n *    X       X             X       0\n *  X   X   X   X    ->   X   X   0   0\n * X X X X X X X X       X X X 0 0 0 0 0\n * ```\n *\n * The strategy is to first navigate down to `nodesDepth` and `index` and keep a stack of parents.\n * Then navigate up re-binding:\n * - If navigated to the left rebind with zeroNode()\n * - If navigated to the right rebind with parent.left from the stack\n */\nfunction treeZeroAfterIndex(rootNode, nodesDepth, index) {\n    // depth depthi   gindexes   indexes\n    // 0     1           1          0\n    // 1     0         2   3      0   1\n    // 2     -        4 5 6 7    0 1 2 3\n    // '10' means, at depth 1, node is at the left\n    //\n    // For index N check if the bit at position depthi is set to navigate right at depthi\n    // ```\n    // mask = 1 << depthi\n    // goRight = (N & mask) == mask\n    // ```\n    // Degenerate case where tree is zero after a negative index (-1).\n    // All positive indexes are zero, so the entire tree is zero. Return cached zero node as root.\n    if (index < 0) {\n        return zeroNode_1.zeroNode(nodesDepth);\n    }\n    /**\n     * Contiguous filled stack of parent nodes. It get filled in the first descent\n     * Indexed by depthi\n     */\n    const parentNodeStack = new Array(nodesDepth);\n    // Ignore first bit \"1\", then substract 1 to get to the parent\n    const depthiRoot = nodesDepth - 1;\n    const depthiParent = 0;\n    let depthi = depthiRoot;\n    let node = rootNode;\n    // Insert root node to make the loop below general\n    parentNodeStack[depthiRoot] = rootNode;\n    // Navigate down until parent depth, and store the chain of nodes\n    //\n    // Stops at the depthiParent level. To rebind below down to `nodesDepth`\n    for (let d = depthi; d >= depthiParent; d--) {\n        node = isLeftNode(d, index) ? node.left : node.right;\n        parentNodeStack[d - 1] = node;\n    }\n    depthi = depthiParent;\n    // Now climb up re-binding with either zero of existing tree.\n    for (let d = depthiParent; d <= depthiRoot; d++) {\n        if (isLeftNode(d, index)) {\n            // If navigated to the left, then all the child nodes of the right node are NOT part of the new tree.\n            // So re-bind new `node` with a zeroNode at the current depth.\n            node = new node_1.BranchNode(node, zeroNode_1.zeroNode(d));\n        }\n        else {\n            // If navigated to the right, then all the child nodes of the left node are part of the new tree.\n            // So re-bind new `node` with the existing left node of the parent.\n            node = new node_1.BranchNode(parentNodeStack[d].left, node);\n        }\n    }\n    // Done, return new root node\n    return node;\n}\nexports.treeZeroAfterIndex = treeZeroAfterIndex;\n/**\n * Returns true if the `index` at `depth` is a left node, false if it is a right node.\n *\n * Supports index up to `Number.MAX_SAFE_INTEGER`.\n * In Eth2 case the biggest tree's index is 2**40 (VALIDATOR_REGISTRY_LIMIT)\n */\nfunction isLeftNode(depthi, index) {\n    if (depthi > 31) {\n        // Javascript can only do bitwise ops with 32 bit numbers.\n        // Shifting left 1 by 32 wraps around and becomes 1.\n        // Get the high part of `index` and adjust depthi\n        const indexHi = (index / 2 ** 32) >>> 0;\n        const mask = 1 << (depthi - 32);\n        return (indexHi & mask) !== mask;\n    }\n    const mask = 1 << depthi;\n    return (index & mask) !== mask;\n}\n/**\n * depth depthi   gindexes   indexes\n * 0     1           1          0\n * 1     0         2   3      0   1\n * 2     -        4 5 6 7    0 1 2 3\n *\n * **Conditions**:\n * - `from` and `to` must not be equal\n *\n * @param from Index\n * @param to Index\n */\nfunction findDiffDepthi(from, to) {\n    return (\n    // (0,0) -> 0 | (0,1) -> 1 | (0,2) -> 2\n    Math.ceil(Math.log2(-~(from ^ to))) -\n        // Must offset by one to match the depthi scale\n        1);\n}\n"]},"metadata":{},"sourceType":"script"}