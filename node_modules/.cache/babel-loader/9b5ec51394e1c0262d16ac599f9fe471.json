{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.bitwiseOrNodeH = exports.setNodeH = exports.getNodeH = exports.compose = exports.identity = exports.LeafNode = exports.BranchNode = exports.Node = void 0;\n\nconst hash_1 = require(\"./hash\");\n\nconst TWO_POWER_32 = 2 ** 32;\n/**\n * An immutable binary merkle tree node\n */\n\nclass Node {\n  constructor(h0, h1, h2, h3, h4, h5, h6, h7) {\n    this.h0 = h0;\n    this.h1 = h1;\n    this.h2 = h2;\n    this.h3 = h3;\n    this.h4 = h4;\n    this.h5 = h5;\n    this.h6 = h6;\n    this.h7 = h7;\n  }\n\n  applyHash(root) {\n    this.h0 = root.h0;\n    this.h1 = root.h1;\n    this.h2 = root.h2;\n    this.h3 = root.h3;\n    this.h4 = root.h4;\n    this.h5 = root.h5;\n    this.h6 = root.h6;\n    this.h7 = root.h7;\n  }\n\n}\n\nexports.Node = Node;\n/**\n * An immutable binary merkle tree node that has a `left` and `right` child\n */\n\nclass BranchNode extends Node {\n  constructor(_left, _right) {\n    // First null value is to save an extra variable to check if a node has a root or not\n    super(null, 0, 0, 0, 0, 0, 0, 0);\n    this._left = _left;\n    this._right = _right;\n\n    if (!_left) {\n      throw new Error(\"Left node is undefined\");\n    }\n\n    if (!_right) {\n      throw new Error(\"Right node is undefined\");\n    }\n  }\n\n  get rootHashObject() {\n    if (this.h0 === null) {\n      super.applyHash(hash_1.hashTwoObjects(this.left.rootHashObject, this.right.rootHashObject));\n    }\n\n    return this;\n  }\n\n  get root() {\n    return hash_1.hashObjectToUint8Array(this.rootHashObject);\n  }\n\n  isLeaf() {\n    return false;\n  }\n\n  get left() {\n    return this._left;\n  }\n\n  get right() {\n    return this._right;\n  }\n\n}\n\nexports.BranchNode = BranchNode;\n/**\n * An immutable binary merkle tree node that has no children\n */\n\nclass LeafNode extends Node {\n  static fromRoot(root) {\n    return this.fromHashObject(hash_1.uint8ArrayToHashObject(root));\n  }\n  /**\n   * New LeafNode from existing HashObject.\n   */\n\n\n  static fromHashObject(ho) {\n    return new LeafNode(ho.h0, ho.h1, ho.h2, ho.h3, ho.h4, ho.h5, ho.h6, ho.h7);\n  }\n  /**\n   * New LeafNode with its internal value set to zero. Consider using `zeroNode(0)` if you don't need to mutate.\n   */\n\n\n  static fromZero() {\n    return new LeafNode(0, 0, 0, 0, 0, 0, 0, 0);\n  }\n  /**\n   * LeafNode with HashObject `(uint32, 0, 0, 0, 0, 0, 0, 0)`.\n   */\n\n\n  static fromUint32(uint32) {\n    return new LeafNode(uint32, 0, 0, 0, 0, 0, 0, 0);\n  }\n  /**\n   * Create a new LeafNode with the same internal values. The returned instance is safe to mutate\n   */\n\n\n  clone() {\n    return LeafNode.fromHashObject(this);\n  }\n\n  get rootHashObject() {\n    return this;\n  }\n\n  get root() {\n    return hash_1.hashObjectToUint8Array(this);\n  }\n\n  isLeaf() {\n    return true;\n  }\n\n  get left() {\n    throw Error(\"LeafNode has no left node\");\n  }\n\n  get right() {\n    throw Error(\"LeafNode has no right node\");\n  }\n\n  writeToBytes(data, start, size) {\n    // TODO: Optimize\n    data.set(this.root.slice(0, size), start);\n  }\n\n  getUint(uintBytes, offsetBytes, clipInfinity) {\n    const hIndex = Math.floor(offsetBytes / 4); // number has to be masked from an h value\n\n    if (uintBytes < 4) {\n      const bitIndex = offsetBytes % 4 * 8;\n      const h = getNodeH(this, hIndex);\n\n      if (uintBytes === 1) {\n        return 0xff & h >> bitIndex;\n      } else {\n        return 0xffff & h >> bitIndex;\n      }\n    } // number equals the h value\n    else if (uintBytes === 4) {\n        return getNodeH(this, hIndex) >>> 0;\n      } // number spans 2 h values\n      else if (uintBytes === 8) {\n          const low = getNodeH(this, hIndex);\n          const high = getNodeH(this, hIndex + 1);\n\n          if (high === 0) {\n            return low >>> 0;\n          } else if (high === -1 && low === -1 && clipInfinity) {\n            // Limit uint returns\n            return Infinity;\n          } else {\n            return (low >>> 0) + (high >>> 0) * TWO_POWER_32;\n          }\n        } // Bigger uint can't be represented\n        else {\n            throw Error(\"uintBytes > 8\");\n          }\n  }\n\n  getUintBigint(uintBytes, offsetBytes) {\n    const hIndex = Math.floor(offsetBytes / 4); // number has to be masked from an h value\n\n    if (uintBytes < 4) {\n      const bitIndex = offsetBytes % 4 * 8;\n      const h = getNodeH(this, hIndex);\n\n      if (uintBytes === 1) {\n        return BigInt(0xff & h >> bitIndex);\n      } else {\n        return BigInt(0xffff & h >> bitIndex);\n      }\n    } // number equals the h value\n    else if (uintBytes === 4) {\n        return BigInt(getNodeH(this, hIndex) >>> 0);\n      } // number spans multiple h values\n      else {\n          const hRange = Math.ceil(uintBytes / 4);\n          let v = BigInt(0);\n\n          for (let i = 0; i < hRange; i++) {\n            v += BigInt(getNodeH(this, hIndex + i) >>> 0) << BigInt(32 * i);\n          }\n\n          return v;\n        }\n  }\n\n  setUint(uintBytes, offsetBytes, value, clipInfinity) {\n    const hIndex = Math.floor(offsetBytes / 4); // number has to be masked from an h value\n\n    if (uintBytes < 4) {\n      const bitIndex = offsetBytes % 4 * 8;\n      let h = getNodeH(this, hIndex);\n\n      if (uintBytes === 1) {\n        h &= ~(0xff << bitIndex);\n        h |= (0xff && value) << bitIndex;\n      } else {\n        h &= ~(0xffff << bitIndex);\n        h |= (0xffff && value) << bitIndex;\n      }\n\n      setNodeH(this, hIndex, h);\n    } // number equals the h value\n    else if (uintBytes === 4) {\n        setNodeH(this, hIndex, value);\n      } // number spans 2 h values\n      else if (uintBytes === 8) {\n          if (value === Infinity && clipInfinity) {\n            setNodeH(this, hIndex, -1);\n            setNodeH(this, hIndex + 1, -1);\n          } else {\n            setNodeH(this, hIndex, value & 0xffffffff);\n            setNodeH(this, hIndex + 1, value / TWO_POWER_32 & 0xffffffff);\n          }\n        } // Bigger uint can't be represented\n        else {\n            throw Error(\"uintBytes > 8\");\n          }\n  }\n\n  setUintBigint(uintBytes, offsetBytes, valueBN) {\n    const hIndex = Math.floor(offsetBytes / 4); // number has to be masked from an h value\n\n    if (uintBytes < 4) {\n      const value = Number(valueBN);\n      const bitIndex = offsetBytes % 4 * 8;\n      let h = getNodeH(this, hIndex);\n\n      if (uintBytes === 1) {\n        h &= ~(0xff << bitIndex);\n        h |= (0xff && value) << bitIndex;\n      } else {\n        h &= ~(0xffff << bitIndex);\n        h |= (0xffff && value) << bitIndex;\n      }\n\n      setNodeH(this, hIndex, h);\n    } // number equals the h value\n    else if (uintBytes === 4) {\n        setNodeH(this, hIndex, Number(valueBN));\n      } // number spans multiple h values\n      else {\n          const hEnd = hIndex + Math.ceil(uintBytes / 4);\n\n          for (let i = hIndex; i < hEnd; i++) {\n            setNodeH(this, i, Number(valueBN & BigInt(0xffffffff)));\n            valueBN = valueBN >> BigInt(32);\n          }\n        }\n  }\n\n  bitwiseOrUint(uintBytes, offsetBytes, value) {\n    const hIndex = Math.floor(offsetBytes / 4); // number has to be masked from an h value\n\n    if (uintBytes < 4) {\n      const bitIndex = offsetBytes % 4 * 8;\n      bitwiseOrNodeH(this, hIndex, value << bitIndex);\n    } // number equals the h value\n    else if (uintBytes === 4) {\n        bitwiseOrNodeH(this, hIndex, value);\n      } // number spans multiple h values\n      else {\n          const hEnd = hIndex + Math.ceil(uintBytes / 4);\n\n          for (let i = hIndex; i < hEnd; i++) {\n            bitwiseOrNodeH(this, i, value & 0xffffffff);\n            value >>= 32;\n          }\n        }\n  }\n\n}\n\nexports.LeafNode = LeafNode;\n\nfunction identity(n) {\n  return n;\n}\n\nexports.identity = identity;\n\nfunction compose(inner, outer) {\n  return function (n) {\n    return outer(inner(n));\n  };\n}\n\nexports.compose = compose;\n\nfunction getNodeH(node, hIndex) {\n  if (hIndex === 0) return node.h0;else if (hIndex === 1) return node.h1;else if (hIndex === 2) return node.h2;else if (hIndex === 3) return node.h3;else if (hIndex === 4) return node.h4;else if (hIndex === 5) return node.h5;else if (hIndex === 6) return node.h6;else if (hIndex === 7) return node.h7;else throw Error(\"hIndex > 7\");\n}\n\nexports.getNodeH = getNodeH;\n\nfunction setNodeH(node, hIndex, value) {\n  if (hIndex === 0) node.h0 = value;else if (hIndex === 1) node.h1 = value;else if (hIndex === 2) node.h2 = value;else if (hIndex === 3) node.h3 = value;else if (hIndex === 4) node.h4 = value;else if (hIndex === 5) node.h5 = value;else if (hIndex === 6) node.h6 = value;else if (hIndex === 7) node.h7 = value;else throw Error(\"hIndex > 7\");\n}\n\nexports.setNodeH = setNodeH;\n\nfunction bitwiseOrNodeH(node, hIndex, value) {\n  if (hIndex === 0) node.h0 |= value;else if (hIndex === 1) node.h1 |= value;else if (hIndex === 2) node.h2 |= value;else if (hIndex === 3) node.h3 |= value;else if (hIndex === 4) node.h4 |= value;else if (hIndex === 5) node.h5 |= value;else if (hIndex === 6) node.h6 |= value;else if (hIndex === 7) node.h7 |= value;else throw Error(\"hIndex > 7\");\n}\n\nexports.bitwiseOrNodeH = bitwiseOrNodeH;","map":{"version":3,"sources":["/Users/dev3rs/provipdiploma/node_modules/@chainsafe/persistent-merkle-tree/lib/node.js"],"names":["Object","defineProperty","exports","value","bitwiseOrNodeH","setNodeH","getNodeH","compose","identity","LeafNode","BranchNode","Node","hash_1","require","TWO_POWER_32","constructor","h0","h1","h2","h3","h4","h5","h6","h7","applyHash","root","_left","_right","Error","rootHashObject","hashTwoObjects","left","right","hashObjectToUint8Array","isLeaf","fromRoot","fromHashObject","uint8ArrayToHashObject","ho","fromZero","fromUint32","uint32","clone","writeToBytes","data","start","size","set","slice","getUint","uintBytes","offsetBytes","clipInfinity","hIndex","Math","floor","bitIndex","h","low","high","Infinity","getUintBigint","BigInt","hRange","ceil","v","i","setUint","setUintBigint","valueBN","Number","hEnd","bitwiseOrUint","n","inner","outer","node"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.bitwiseOrNodeH = exports.setNodeH = exports.getNodeH = exports.compose = exports.identity = exports.LeafNode = exports.BranchNode = exports.Node = void 0;\nconst hash_1 = require(\"./hash\");\nconst TWO_POWER_32 = 2 ** 32;\n/**\n * An immutable binary merkle tree node\n */\nclass Node {\n    constructor(h0, h1, h2, h3, h4, h5, h6, h7) {\n        this.h0 = h0;\n        this.h1 = h1;\n        this.h2 = h2;\n        this.h3 = h3;\n        this.h4 = h4;\n        this.h5 = h5;\n        this.h6 = h6;\n        this.h7 = h7;\n    }\n    applyHash(root) {\n        this.h0 = root.h0;\n        this.h1 = root.h1;\n        this.h2 = root.h2;\n        this.h3 = root.h3;\n        this.h4 = root.h4;\n        this.h5 = root.h5;\n        this.h6 = root.h6;\n        this.h7 = root.h7;\n    }\n}\nexports.Node = Node;\n/**\n * An immutable binary merkle tree node that has a `left` and `right` child\n */\nclass BranchNode extends Node {\n    constructor(_left, _right) {\n        // First null value is to save an extra variable to check if a node has a root or not\n        super(null, 0, 0, 0, 0, 0, 0, 0);\n        this._left = _left;\n        this._right = _right;\n        if (!_left) {\n            throw new Error(\"Left node is undefined\");\n        }\n        if (!_right) {\n            throw new Error(\"Right node is undefined\");\n        }\n    }\n    get rootHashObject() {\n        if (this.h0 === null) {\n            super.applyHash(hash_1.hashTwoObjects(this.left.rootHashObject, this.right.rootHashObject));\n        }\n        return this;\n    }\n    get root() {\n        return hash_1.hashObjectToUint8Array(this.rootHashObject);\n    }\n    isLeaf() {\n        return false;\n    }\n    get left() {\n        return this._left;\n    }\n    get right() {\n        return this._right;\n    }\n}\nexports.BranchNode = BranchNode;\n/**\n * An immutable binary merkle tree node that has no children\n */\nclass LeafNode extends Node {\n    static fromRoot(root) {\n        return this.fromHashObject(hash_1.uint8ArrayToHashObject(root));\n    }\n    /**\n     * New LeafNode from existing HashObject.\n     */\n    static fromHashObject(ho) {\n        return new LeafNode(ho.h0, ho.h1, ho.h2, ho.h3, ho.h4, ho.h5, ho.h6, ho.h7);\n    }\n    /**\n     * New LeafNode with its internal value set to zero. Consider using `zeroNode(0)` if you don't need to mutate.\n     */\n    static fromZero() {\n        return new LeafNode(0, 0, 0, 0, 0, 0, 0, 0);\n    }\n    /**\n     * LeafNode with HashObject `(uint32, 0, 0, 0, 0, 0, 0, 0)`.\n     */\n    static fromUint32(uint32) {\n        return new LeafNode(uint32, 0, 0, 0, 0, 0, 0, 0);\n    }\n    /**\n     * Create a new LeafNode with the same internal values. The returned instance is safe to mutate\n     */\n    clone() {\n        return LeafNode.fromHashObject(this);\n    }\n    get rootHashObject() {\n        return this;\n    }\n    get root() {\n        return hash_1.hashObjectToUint8Array(this);\n    }\n    isLeaf() {\n        return true;\n    }\n    get left() {\n        throw Error(\"LeafNode has no left node\");\n    }\n    get right() {\n        throw Error(\"LeafNode has no right node\");\n    }\n    writeToBytes(data, start, size) {\n        // TODO: Optimize\n        data.set(this.root.slice(0, size), start);\n    }\n    getUint(uintBytes, offsetBytes, clipInfinity) {\n        const hIndex = Math.floor(offsetBytes / 4);\n        // number has to be masked from an h value\n        if (uintBytes < 4) {\n            const bitIndex = (offsetBytes % 4) * 8;\n            const h = getNodeH(this, hIndex);\n            if (uintBytes === 1) {\n                return 0xff & (h >> bitIndex);\n            }\n            else {\n                return 0xffff & (h >> bitIndex);\n            }\n        }\n        // number equals the h value\n        else if (uintBytes === 4) {\n            return getNodeH(this, hIndex) >>> 0;\n        }\n        // number spans 2 h values\n        else if (uintBytes === 8) {\n            const low = getNodeH(this, hIndex);\n            const high = getNodeH(this, hIndex + 1);\n            if (high === 0) {\n                return low >>> 0;\n            }\n            else if (high === -1 && low === -1 && clipInfinity) {\n                // Limit uint returns\n                return Infinity;\n            }\n            else {\n                return (low >>> 0) + (high >>> 0) * TWO_POWER_32;\n            }\n        }\n        // Bigger uint can't be represented\n        else {\n            throw Error(\"uintBytes > 8\");\n        }\n    }\n    getUintBigint(uintBytes, offsetBytes) {\n        const hIndex = Math.floor(offsetBytes / 4);\n        // number has to be masked from an h value\n        if (uintBytes < 4) {\n            const bitIndex = (offsetBytes % 4) * 8;\n            const h = getNodeH(this, hIndex);\n            if (uintBytes === 1) {\n                return BigInt(0xff & (h >> bitIndex));\n            }\n            else {\n                return BigInt(0xffff & (h >> bitIndex));\n            }\n        }\n        // number equals the h value\n        else if (uintBytes === 4) {\n            return BigInt(getNodeH(this, hIndex) >>> 0);\n        }\n        // number spans multiple h values\n        else {\n            const hRange = Math.ceil(uintBytes / 4);\n            let v = BigInt(0);\n            for (let i = 0; i < hRange; i++) {\n                v += BigInt(getNodeH(this, hIndex + i) >>> 0) << BigInt(32 * i);\n            }\n            return v;\n        }\n    }\n    setUint(uintBytes, offsetBytes, value, clipInfinity) {\n        const hIndex = Math.floor(offsetBytes / 4);\n        // number has to be masked from an h value\n        if (uintBytes < 4) {\n            const bitIndex = (offsetBytes % 4) * 8;\n            let h = getNodeH(this, hIndex);\n            if (uintBytes === 1) {\n                h &= ~(0xff << bitIndex);\n                h |= (0xff && value) << bitIndex;\n            }\n            else {\n                h &= ~(0xffff << bitIndex);\n                h |= (0xffff && value) << bitIndex;\n            }\n            setNodeH(this, hIndex, h);\n        }\n        // number equals the h value\n        else if (uintBytes === 4) {\n            setNodeH(this, hIndex, value);\n        }\n        // number spans 2 h values\n        else if (uintBytes === 8) {\n            if (value === Infinity && clipInfinity) {\n                setNodeH(this, hIndex, -1);\n                setNodeH(this, hIndex + 1, -1);\n            }\n            else {\n                setNodeH(this, hIndex, value & 0xffffffff);\n                setNodeH(this, hIndex + 1, (value / TWO_POWER_32) & 0xffffffff);\n            }\n        }\n        // Bigger uint can't be represented\n        else {\n            throw Error(\"uintBytes > 8\");\n        }\n    }\n    setUintBigint(uintBytes, offsetBytes, valueBN) {\n        const hIndex = Math.floor(offsetBytes / 4);\n        // number has to be masked from an h value\n        if (uintBytes < 4) {\n            const value = Number(valueBN);\n            const bitIndex = (offsetBytes % 4) * 8;\n            let h = getNodeH(this, hIndex);\n            if (uintBytes === 1) {\n                h &= ~(0xff << bitIndex);\n                h |= (0xff && value) << bitIndex;\n            }\n            else {\n                h &= ~(0xffff << bitIndex);\n                h |= (0xffff && value) << bitIndex;\n            }\n            setNodeH(this, hIndex, h);\n        }\n        // number equals the h value\n        else if (uintBytes === 4) {\n            setNodeH(this, hIndex, Number(valueBN));\n        }\n        // number spans multiple h values\n        else {\n            const hEnd = hIndex + Math.ceil(uintBytes / 4);\n            for (let i = hIndex; i < hEnd; i++) {\n                setNodeH(this, i, Number(valueBN & BigInt(0xffffffff)));\n                valueBN = valueBN >> BigInt(32);\n            }\n        }\n    }\n    bitwiseOrUint(uintBytes, offsetBytes, value) {\n        const hIndex = Math.floor(offsetBytes / 4);\n        // number has to be masked from an h value\n        if (uintBytes < 4) {\n            const bitIndex = (offsetBytes % 4) * 8;\n            bitwiseOrNodeH(this, hIndex, value << bitIndex);\n        }\n        // number equals the h value\n        else if (uintBytes === 4) {\n            bitwiseOrNodeH(this, hIndex, value);\n        }\n        // number spans multiple h values\n        else {\n            const hEnd = hIndex + Math.ceil(uintBytes / 4);\n            for (let i = hIndex; i < hEnd; i++) {\n                bitwiseOrNodeH(this, i, value & 0xffffffff);\n                value >>= 32;\n            }\n        }\n    }\n}\nexports.LeafNode = LeafNode;\nfunction identity(n) {\n    return n;\n}\nexports.identity = identity;\nfunction compose(inner, outer) {\n    return function (n) {\n        return outer(inner(n));\n    };\n}\nexports.compose = compose;\nfunction getNodeH(node, hIndex) {\n    if (hIndex === 0)\n        return node.h0;\n    else if (hIndex === 1)\n        return node.h1;\n    else if (hIndex === 2)\n        return node.h2;\n    else if (hIndex === 3)\n        return node.h3;\n    else if (hIndex === 4)\n        return node.h4;\n    else if (hIndex === 5)\n        return node.h5;\n    else if (hIndex === 6)\n        return node.h6;\n    else if (hIndex === 7)\n        return node.h7;\n    else\n        throw Error(\"hIndex > 7\");\n}\nexports.getNodeH = getNodeH;\nfunction setNodeH(node, hIndex, value) {\n    if (hIndex === 0)\n        node.h0 = value;\n    else if (hIndex === 1)\n        node.h1 = value;\n    else if (hIndex === 2)\n        node.h2 = value;\n    else if (hIndex === 3)\n        node.h3 = value;\n    else if (hIndex === 4)\n        node.h4 = value;\n    else if (hIndex === 5)\n        node.h5 = value;\n    else if (hIndex === 6)\n        node.h6 = value;\n    else if (hIndex === 7)\n        node.h7 = value;\n    else\n        throw Error(\"hIndex > 7\");\n}\nexports.setNodeH = setNodeH;\nfunction bitwiseOrNodeH(node, hIndex, value) {\n    if (hIndex === 0)\n        node.h0 |= value;\n    else if (hIndex === 1)\n        node.h1 |= value;\n    else if (hIndex === 2)\n        node.h2 |= value;\n    else if (hIndex === 3)\n        node.h3 |= value;\n    else if (hIndex === 4)\n        node.h4 |= value;\n    else if (hIndex === 5)\n        node.h5 |= value;\n    else if (hIndex === 6)\n        node.h6 |= value;\n    else if (hIndex === 7)\n        node.h7 |= value;\n    else\n        throw Error(\"hIndex > 7\");\n}\nexports.bitwiseOrNodeH = bitwiseOrNodeH;\n"]},"metadata":{},"sourceType":"script"}