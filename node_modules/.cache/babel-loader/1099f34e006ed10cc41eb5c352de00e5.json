{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isCompositeType = exports.CompositeType = exports.LENGTH_GINDEX = void 0;\n\nconst persistent_merkle_tree_1 = require(\"@chainsafe/persistent-merkle-tree\");\n\nconst byteArray_1 = require(\"../util/byteArray\");\n\nconst merkleize_1 = require(\"../util/merkleize\");\n\nconst treePostProcessFromProofNode_1 = require(\"../util/proof/treePostProcessFromProofNode\");\n\nconst abstract_1 = require(\"./abstract\");\n\nexports.LENGTH_GINDEX = BigInt(3);\n/** Dedicated property to cache hashTreeRoot of immutable CompositeType values */\n\nconst symbolCachedPermanentRoot = Symbol(\"ssz_cached_permanent_root\");\n/* eslint-disable @typescript-eslint/member-ordering  */\n\n/**\n * Represents a composite type as defined in the spec:\n * https://github.com/ethereum/consensus-specs/blob/dev/ssz/simple-serialize.md#composite-types\n */\n\nclass CompositeType extends abstract_1.Type {\n  constructor(\n  /**\n   * Caches `hashTreeRoot()` result for struct values.\n   *\n   * WARNING: Must only be used for immutable values. The cached root is never discarded\n   */\n  cachePermanentRootStruct) {\n    super();\n    this.cachePermanentRootStruct = cachePermanentRootStruct;\n    this.isBasic = false;\n  }\n  /** New instance of a recursive zero'ed value converted to Tree View */\n\n\n  defaultView() {\n    return this.toView(this.defaultValue());\n  }\n  /** New instance of a recursive zero'ed value converted to Deferred Update Tree View */\n\n\n  defaultViewDU() {\n    return this.toViewDU(this.defaultValue());\n  }\n  /**\n   * Deserialize binary data to a Tree View.\n   * @see {@link CompositeType.getView}\n   */\n\n\n  deserializeToView(data) {\n    const dataView = new DataView(data.buffer, data.byteOffset, data.byteLength);\n    const node = this.tree_deserializeFromBytes({\n      uint8Array: data,\n      dataView\n    }, 0, data.length);\n    return this.getView(new persistent_merkle_tree_1.Tree(node));\n  }\n  /**\n   * Deserialize binary data to a Deferred Update Tree View.\n   * @see {@link CompositeType.getViewDU}\n   */\n\n\n  deserializeToViewDU(data) {\n    const dataView = new DataView(data.buffer, data.byteOffset, data.byteLength);\n    const node = this.tree_deserializeFromBytes({\n      uint8Array: data,\n      dataView\n    }, 0, data.length);\n    return this.getViewDU(node);\n  }\n  /**\n   * Transform value to a View.\n   * @see {@link CompositeType.getView}\n   */\n\n\n  toView(value) {\n    const node = this.value_toTree(value);\n    return this.getView(new persistent_merkle_tree_1.Tree(node));\n  }\n  /**\n   * Transform value to a ViewDU.\n   * @see {@link CompositeType.getViewDU}\n   */\n\n\n  toViewDU(value) {\n    const node = this.value_toTree(value);\n    return this.getViewDU(node);\n  }\n  /**\n   * Transform value to a View.\n   * @see {@link CompositeType.getView}\n   */\n\n\n  toValueFromView(view) {\n    const node = this.commitView(view);\n    return this.tree_toValue(node);\n  }\n  /**\n   * Transform value to a ViewDU.\n   * @see {@link CompositeType.getViewDU}\n   */\n\n\n  toValueFromViewDU(view) {\n    const node = this.commitViewDU(view);\n    return this.tree_toValue(node);\n  }\n  /**\n   * Transform a ViewDU to a View.\n   * @see {@link CompositeType.getView} and {@link CompositeType.getViewDU}\n   */\n\n\n  toViewFromViewDU(view) {\n    const node = this.commitViewDU(view);\n    return this.getView(new persistent_merkle_tree_1.Tree(node));\n  }\n  /**\n   * Transform a View to a ViewDU.\n   * @see {@link CompositeType.getView} and {@link CompositeType.getViewDU}\n   */\n\n\n  toViewDUFromView(view) {\n    const node = this.commitView(view);\n    return this.getViewDU(node);\n  } // Merkleize API\n\n\n  hashTreeRoot(value) {\n    // Return cached mutable root if any\n    if (this.cachePermanentRootStruct) {\n      const cachedRoot = value[symbolCachedPermanentRoot];\n\n      if (cachedRoot) {\n        return cachedRoot;\n      }\n    }\n\n    const root = merkleize_1.merkleize(this.getRoots(value), this.maxChunkCount);\n\n    if (this.cachePermanentRootStruct) {\n      value[symbolCachedPermanentRoot] = root;\n    }\n\n    return root;\n  } // For debugging and testing this feature\n\n\n  getCachedPermanentRoot(value) {\n    return value[symbolCachedPermanentRoot];\n  } // Proofs API\n\n  /**\n   * Create a Tree View from a Proof. Verifies that the Proof is correct against `root`.\n   * @see {@link CompositeType.getView}\n   */\n\n\n  createFromProof(proof, root) {\n    const rootNodeFromProof = persistent_merkle_tree_1.Tree.createFromProof(proof).rootNode;\n    const rootNode = treePostProcessFromProofNode_1.treePostProcessFromProofNode(rootNodeFromProof, this);\n\n    if (root !== undefined && !byteArray_1.byteArrayEquals(rootNode.root, root)) {\n      throw new Error(\"Proof does not match trusted root\");\n    }\n\n    return this.getView(new persistent_merkle_tree_1.Tree(rootNode));\n  }\n  /** INTERNAL METHOD: For view's API, create proof from a tree */\n\n\n  tree_createProof(node, jsonPaths) {\n    const gindexes = this.tree_createProofGindexes(node, jsonPaths);\n    return persistent_merkle_tree_1.createProof(node, {\n      type: persistent_merkle_tree_1.ProofType.treeOffset,\n      gindices: gindexes\n    });\n  }\n  /** INTERNAL METHOD: For view's API, create proof from a tree */\n\n\n  tree_createProofGindexes(node, jsonPaths) {\n    const gindexes = [];\n\n    for (const jsonPath of jsonPaths) {\n      const {\n        type,\n        gindex\n      } = this.getPathInfo(jsonPath);\n\n      if (!isCompositeType(type)) {\n        gindexes.push(gindex);\n      } else {\n        // if the path subtype is composite, include the gindices of all the leaves\n        const leafGindexes = type.tree_getLeafGindices(gindex, type.fixedSize === null ? persistent_merkle_tree_1.getNode(node, gindex) : undefined);\n\n        for (const gindex of leafGindexes) {\n          gindexes.push(gindex);\n        }\n      }\n    }\n\n    return gindexes;\n  }\n  /**\n   * Navigate to a subtype & gindex using a path\n   */\n\n\n  getPathInfo(path) {\n    const gindices = [];\n    let type = this;\n\n    for (const prop of path) {\n      if (type.isBasic) {\n        throw new Error(\"Invalid path: cannot navigate beyond a basic type\");\n      }\n\n      const gindex = type.getPropertyGindex(prop); // else stop navigating\n\n      if (gindex !== null) {\n        gindices.push(gindex);\n        type = type.getPropertyType(prop);\n      }\n    }\n\n    return {\n      type,\n      gindex: persistent_merkle_tree_1.concatGindices(gindices)\n    };\n  }\n  /**\n   * INTERNAL METHOD: post process `Ç¸ode` instance created from a proof and return either the same node,\n   * and a new node representing the same data is a different `Node` instance. Currently used exclusively\n   * by ContainerNodeStruct to convert `BranchNode` into `BranchNodeStruct`.\n   */\n\n\n  tree_fromProofNode(node) {\n    return {\n      node,\n      done: false\n    };\n  }\n\n}\n\nexports.CompositeType = CompositeType;\n\nfunction isCompositeType(type) {\n  return !type.isBasic;\n}\n\nexports.isCompositeType = isCompositeType;","map":{"version":3,"sources":["../../src/type/composite.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isCompositeType = exports.CompositeType = exports.LENGTH_GINDEX = void 0;\nconst persistent_merkle_tree_1 = require(\"@chainsafe/persistent-merkle-tree\");\nconst byteArray_1 = require(\"../util/byteArray\");\nconst merkleize_1 = require(\"../util/merkleize\");\nconst treePostProcessFromProofNode_1 = require(\"../util/proof/treePostProcessFromProofNode\");\nconst abstract_1 = require(\"./abstract\");\nexports.LENGTH_GINDEX = BigInt(3);\n/** Dedicated property to cache hashTreeRoot of immutable CompositeType values */\nconst symbolCachedPermanentRoot = Symbol(\"ssz_cached_permanent_root\");\n/* eslint-disable @typescript-eslint/member-ordering  */\n/**\n * Represents a composite type as defined in the spec:\n * https://github.com/ethereum/consensus-specs/blob/dev/ssz/simple-serialize.md#composite-types\n */\nclass CompositeType extends abstract_1.Type {\n    constructor(\n    /**\n     * Caches `hashTreeRoot()` result for struct values.\n     *\n     * WARNING: Must only be used for immutable values. The cached root is never discarded\n     */\n    cachePermanentRootStruct) {\n        super();\n        this.cachePermanentRootStruct = cachePermanentRootStruct;\n        this.isBasic = false;\n    }\n    /** New instance of a recursive zero'ed value converted to Tree View */\n    defaultView() {\n        return this.toView(this.defaultValue());\n    }\n    /** New instance of a recursive zero'ed value converted to Deferred Update Tree View */\n    defaultViewDU() {\n        return this.toViewDU(this.defaultValue());\n    }\n    /**\n     * Deserialize binary data to a Tree View.\n     * @see {@link CompositeType.getView}\n     */\n    deserializeToView(data) {\n        const dataView = new DataView(data.buffer, data.byteOffset, data.byteLength);\n        const node = this.tree_deserializeFromBytes({ uint8Array: data, dataView }, 0, data.length);\n        return this.getView(new persistent_merkle_tree_1.Tree(node));\n    }\n    /**\n     * Deserialize binary data to a Deferred Update Tree View.\n     * @see {@link CompositeType.getViewDU}\n     */\n    deserializeToViewDU(data) {\n        const dataView = new DataView(data.buffer, data.byteOffset, data.byteLength);\n        const node = this.tree_deserializeFromBytes({ uint8Array: data, dataView }, 0, data.length);\n        return this.getViewDU(node);\n    }\n    /**\n     * Transform value to a View.\n     * @see {@link CompositeType.getView}\n     */\n    toView(value) {\n        const node = this.value_toTree(value);\n        return this.getView(new persistent_merkle_tree_1.Tree(node));\n    }\n    /**\n     * Transform value to a ViewDU.\n     * @see {@link CompositeType.getViewDU}\n     */\n    toViewDU(value) {\n        const node = this.value_toTree(value);\n        return this.getViewDU(node);\n    }\n    /**\n     * Transform value to a View.\n     * @see {@link CompositeType.getView}\n     */\n    toValueFromView(view) {\n        const node = this.commitView(view);\n        return this.tree_toValue(node);\n    }\n    /**\n     * Transform value to a ViewDU.\n     * @see {@link CompositeType.getViewDU}\n     */\n    toValueFromViewDU(view) {\n        const node = this.commitViewDU(view);\n        return this.tree_toValue(node);\n    }\n    /**\n     * Transform a ViewDU to a View.\n     * @see {@link CompositeType.getView} and {@link CompositeType.getViewDU}\n     */\n    toViewFromViewDU(view) {\n        const node = this.commitViewDU(view);\n        return this.getView(new persistent_merkle_tree_1.Tree(node));\n    }\n    /**\n     * Transform a View to a ViewDU.\n     * @see {@link CompositeType.getView} and {@link CompositeType.getViewDU}\n     */\n    toViewDUFromView(view) {\n        const node = this.commitView(view);\n        return this.getViewDU(node);\n    }\n    // Merkleize API\n    hashTreeRoot(value) {\n        // Return cached mutable root if any\n        if (this.cachePermanentRootStruct) {\n            const cachedRoot = value[symbolCachedPermanentRoot];\n            if (cachedRoot) {\n                return cachedRoot;\n            }\n        }\n        const root = merkleize_1.merkleize(this.getRoots(value), this.maxChunkCount);\n        if (this.cachePermanentRootStruct) {\n            value[symbolCachedPermanentRoot] = root;\n        }\n        return root;\n    }\n    // For debugging and testing this feature\n    getCachedPermanentRoot(value) {\n        return value[symbolCachedPermanentRoot];\n    }\n    // Proofs API\n    /**\n     * Create a Tree View from a Proof. Verifies that the Proof is correct against `root`.\n     * @see {@link CompositeType.getView}\n     */\n    createFromProof(proof, root) {\n        const rootNodeFromProof = persistent_merkle_tree_1.Tree.createFromProof(proof).rootNode;\n        const rootNode = treePostProcessFromProofNode_1.treePostProcessFromProofNode(rootNodeFromProof, this);\n        if (root !== undefined && !byteArray_1.byteArrayEquals(rootNode.root, root)) {\n            throw new Error(\"Proof does not match trusted root\");\n        }\n        return this.getView(new persistent_merkle_tree_1.Tree(rootNode));\n    }\n    /** INTERNAL METHOD: For view's API, create proof from a tree */\n    tree_createProof(node, jsonPaths) {\n        const gindexes = this.tree_createProofGindexes(node, jsonPaths);\n        return persistent_merkle_tree_1.createProof(node, {\n            type: persistent_merkle_tree_1.ProofType.treeOffset,\n            gindices: gindexes,\n        });\n    }\n    /** INTERNAL METHOD: For view's API, create proof from a tree */\n    tree_createProofGindexes(node, jsonPaths) {\n        const gindexes = [];\n        for (const jsonPath of jsonPaths) {\n            const { type, gindex } = this.getPathInfo(jsonPath);\n            if (!isCompositeType(type)) {\n                gindexes.push(gindex);\n            }\n            else {\n                // if the path subtype is composite, include the gindices of all the leaves\n                const leafGindexes = type.tree_getLeafGindices(gindex, type.fixedSize === null ? persistent_merkle_tree_1.getNode(node, gindex) : undefined);\n                for (const gindex of leafGindexes) {\n                    gindexes.push(gindex);\n                }\n            }\n        }\n        return gindexes;\n    }\n    /**\n     * Navigate to a subtype & gindex using a path\n     */\n    getPathInfo(path) {\n        const gindices = [];\n        let type = this;\n        for (const prop of path) {\n            if (type.isBasic) {\n                throw new Error(\"Invalid path: cannot navigate beyond a basic type\");\n            }\n            const gindex = type.getPropertyGindex(prop);\n            // else stop navigating\n            if (gindex !== null) {\n                gindices.push(gindex);\n                type = type.getPropertyType(prop);\n            }\n        }\n        return {\n            type,\n            gindex: persistent_merkle_tree_1.concatGindices(gindices),\n        };\n    }\n    /**\n     * INTERNAL METHOD: post process `Ç¸ode` instance created from a proof and return either the same node,\n     * and a new node representing the same data is a different `Node` instance. Currently used exclusively\n     * by ContainerNodeStruct to convert `BranchNode` into `BranchNodeStruct`.\n     */\n    tree_fromProofNode(node) {\n        return { node, done: false };\n    }\n}\nexports.CompositeType = CompositeType;\nfunction isCompositeType(type) {\n    return !type.isBasic;\n}\nexports.isCompositeType = isCompositeType;\n//# sourceMappingURL=composite.js.map"]},"metadata":{},"sourceType":"script"}