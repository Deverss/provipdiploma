{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.VectorBasicType = void 0;\n\nconst merkleize_1 = require(\"../util/merkleize\");\n\nconst named_1 = require(\"../util/named\");\n\nconst arrayBasic_1 = require(\"./arrayBasic\");\n\nconst arrayBasic_2 = require(\"../view/arrayBasic\");\n\nconst arrayBasic_3 = require(\"../viewDU/arrayBasic\");\n\nconst array_1 = require(\"./array\");\n/**\n * Vector: Ordered fixed-length homogeneous collection, with N values\n *\n * Array of Basic type:\n * - Basic types are max 32 bytes long so multiple values may be packed in the same node.\n * - Basic types are never returned in a view wrapper, but their value representation\n */\n\n\nclass VectorBasicType extends array_1.ArrayType {\n  constructor(elementType, length, opts) {\n    super(elementType);\n    this.elementType = elementType;\n    this.length = length;\n    this.isList = false;\n    this.isViewMutable = true;\n    if (!elementType.isBasic) throw Error(\"elementType must be basic\");\n    if (length === 0) throw Error(\"Vector length must be > 0\");\n    this.typeName = (opts === null || opts === void 0 ? void 0 : opts.typeName) ?? `Vector[${elementType.typeName}, ${length}]`; // TODO Check that itemsPerChunk is an integer\n\n    this.itemsPerChunk = 32 / elementType.byteLength;\n    this.maxChunkCount = Math.ceil(length * elementType.byteLength / 32);\n    this.chunkDepth = merkleize_1.maxChunksToDepth(this.maxChunkCount);\n    this.depth = this.chunkDepth;\n    this.fixedSize = length * elementType.byteLength;\n    this.minSize = this.fixedSize;\n    this.maxSize = this.fixedSize;\n    this.defaultLen = length;\n  }\n\n  static named(elementType, limit, opts) {\n    return new (named_1.namedClass(VectorBasicType, opts.typeName))(elementType, limit, opts);\n  }\n\n  getView(tree) {\n    return new arrayBasic_2.ArrayBasicTreeView(this, tree);\n  }\n\n  getViewDU(node, cache) {\n    // cache type should be validated (if applicate) in the view\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return new arrayBasic_3.ArrayBasicTreeViewDU(this, node, cache);\n  }\n\n  commitView(view) {\n    return view.node;\n  }\n\n  commitViewDU(view) {\n    view.commit();\n    return view.node;\n  }\n\n  cacheOfViewDU(view) {\n    return view.cache;\n  } // Serialization + deserialization\n\n\n  value_serializedSize() {\n    return this.fixedSize;\n  }\n\n  value_serializeToBytes(output, offset, value) {\n    return arrayBasic_1.value_serializeToBytesArrayBasic(this.elementType, this.length, output, offset, value);\n  }\n\n  value_deserializeFromBytes(data, start, end) {\n    return arrayBasic_1.value_deserializeFromBytesArrayBasic(this.elementType, data, start, end, this);\n  }\n\n  tree_serializedSize() {\n    return this.fixedSize;\n  }\n\n  tree_serializeToBytes(output, offset, node) {\n    return arrayBasic_1.tree_serializeToBytesArrayBasic(this.elementType, this.length, this.depth, output, offset, node);\n  }\n\n  tree_deserializeFromBytes(data, start, end) {\n    return arrayBasic_1.tree_deserializeFromBytesArrayBasic(this.elementType, this.depth, data, start, end, this);\n  } // Helpers for TreeView\n\n\n  tree_getLength() {\n    return this.length;\n  }\n\n  tree_setLength() {// Vector's length is immutable, ignore this call\n  }\n\n  tree_getChunksNode(node) {\n    return node;\n  }\n\n  tree_setChunksNode(rootNode, chunksNode) {\n    return chunksNode;\n  } // Merkleization\n\n\n  getRoots(value) {\n    const uint8Array = new Uint8Array(this.fixedSize);\n    const dataView = new DataView(uint8Array.buffer, uint8Array.byteOffset, uint8Array.byteLength);\n    arrayBasic_1.value_serializeToBytesArrayBasic(this.elementType, this.length, {\n      uint8Array,\n      dataView\n    }, 0, value);\n    return merkleize_1.splitIntoRootChunks(uint8Array);\n  }\n\n}\n\nexports.VectorBasicType = VectorBasicType;","map":{"version":3,"sources":["../../src/type/vectorBasic.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.VectorBasicType = void 0;\nconst merkleize_1 = require(\"../util/merkleize\");\nconst named_1 = require(\"../util/named\");\nconst arrayBasic_1 = require(\"./arrayBasic\");\nconst arrayBasic_2 = require(\"../view/arrayBasic\");\nconst arrayBasic_3 = require(\"../viewDU/arrayBasic\");\nconst array_1 = require(\"./array\");\n/**\n * Vector: Ordered fixed-length homogeneous collection, with N values\n *\n * Array of Basic type:\n * - Basic types are max 32 bytes long so multiple values may be packed in the same node.\n * - Basic types are never returned in a view wrapper, but their value representation\n */\nclass VectorBasicType extends array_1.ArrayType {\n    constructor(elementType, length, opts) {\n        super(elementType);\n        this.elementType = elementType;\n        this.length = length;\n        this.isList = false;\n        this.isViewMutable = true;\n        if (!elementType.isBasic)\n            throw Error(\"elementType must be basic\");\n        if (length === 0)\n            throw Error(\"Vector length must be > 0\");\n        this.typeName = opts?.typeName ?? `Vector[${elementType.typeName}, ${length}]`;\n        // TODO Check that itemsPerChunk is an integer\n        this.itemsPerChunk = 32 / elementType.byteLength;\n        this.maxChunkCount = Math.ceil((length * elementType.byteLength) / 32);\n        this.chunkDepth = merkleize_1.maxChunksToDepth(this.maxChunkCount);\n        this.depth = this.chunkDepth;\n        this.fixedSize = length * elementType.byteLength;\n        this.minSize = this.fixedSize;\n        this.maxSize = this.fixedSize;\n        this.defaultLen = length;\n    }\n    static named(elementType, limit, opts) {\n        return new (named_1.namedClass(VectorBasicType, opts.typeName))(elementType, limit, opts);\n    }\n    getView(tree) {\n        return new arrayBasic_2.ArrayBasicTreeView(this, tree);\n    }\n    getViewDU(node, cache) {\n        // cache type should be validated (if applicate) in the view\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        return new arrayBasic_3.ArrayBasicTreeViewDU(this, node, cache);\n    }\n    commitView(view) {\n        return view.node;\n    }\n    commitViewDU(view) {\n        view.commit();\n        return view.node;\n    }\n    cacheOfViewDU(view) {\n        return view.cache;\n    }\n    // Serialization + deserialization\n    value_serializedSize() {\n        return this.fixedSize;\n    }\n    value_serializeToBytes(output, offset, value) {\n        return arrayBasic_1.value_serializeToBytesArrayBasic(this.elementType, this.length, output, offset, value);\n    }\n    value_deserializeFromBytes(data, start, end) {\n        return arrayBasic_1.value_deserializeFromBytesArrayBasic(this.elementType, data, start, end, this);\n    }\n    tree_serializedSize() {\n        return this.fixedSize;\n    }\n    tree_serializeToBytes(output, offset, node) {\n        return arrayBasic_1.tree_serializeToBytesArrayBasic(this.elementType, this.length, this.depth, output, offset, node);\n    }\n    tree_deserializeFromBytes(data, start, end) {\n        return arrayBasic_1.tree_deserializeFromBytesArrayBasic(this.elementType, this.depth, data, start, end, this);\n    }\n    // Helpers for TreeView\n    tree_getLength() {\n        return this.length;\n    }\n    tree_setLength() {\n        // Vector's length is immutable, ignore this call\n    }\n    tree_getChunksNode(node) {\n        return node;\n    }\n    tree_setChunksNode(rootNode, chunksNode) {\n        return chunksNode;\n    }\n    // Merkleization\n    getRoots(value) {\n        const uint8Array = new Uint8Array(this.fixedSize);\n        const dataView = new DataView(uint8Array.buffer, uint8Array.byteOffset, uint8Array.byteLength);\n        arrayBasic_1.value_serializeToBytesArrayBasic(this.elementType, this.length, { uint8Array, dataView }, 0, value);\n        return merkleize_1.splitIntoRootChunks(uint8Array);\n    }\n}\nexports.VectorBasicType = VectorBasicType;\n//# sourceMappingURL=vectorBasic.js.map"]},"metadata":{},"sourceType":"script"}