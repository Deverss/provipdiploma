{"ast":null,"code":"import { ChaCha20Poly1305 as ie } from \"@stablelib/chacha20poly1305\";\nimport { HKDF as fn } from \"@stablelib/hkdf\";\nimport { randomBytes as ce } from \"@stablelib/random\";\nimport { SHA256 as pn, hash as ae } from \"@stablelib/sha256\";\nimport * as ue from \"@stablelib/x25519\";\nimport { toString as E, fromString as h, concat as de } from \"uint8arrays\";\nimport { detect as mn } from \"detect-browser\";\nimport { toMiliseconds as q, FIVE_MINUTES as le, fromMiliseconds as yn } from \"@walletconnect/time\";\nimport { getDocument as En, getNavigator as fe, getLocation as pe } from \"@walletconnect/window-getters\";\nimport { getWindowMetadata as hn } from \"@walletconnect/window-metadata\";\nimport * as $ from \"query-string\";\nimport { RELAY_JSONRPC as vn } from \"@walletconnect/relay-api\";\nconst D = \":\";\n\nfunction me(e) {\n  const [n, t] = e.split(D);\n  return {\n    namespace: n,\n    reference: t\n  };\n}\n\nfunction ye(e) {\n  const {\n    namespace: n,\n    reference: t\n  } = e;\n  return [n, t].join(D);\n}\n\nfunction z(e) {\n  const [n, t, r] = e.split(D);\n  return {\n    namespace: n,\n    reference: t,\n    address: r\n  };\n}\n\nfunction Ee(e) {\n  const {\n    namespace: n,\n    reference: t,\n    address: r\n  } = e;\n  return [n, t, r].join(D);\n}\n\nfunction B(e, n) {\n  const t = [];\n  return e.forEach(r => {\n    const o = n(r);\n    t.includes(o) || t.push(o);\n  }), t;\n}\n\nfunction he(e) {\n  const {\n    address: n\n  } = z(e);\n  return n;\n}\n\nfunction ve(e) {\n  const {\n    namespace: n,\n    reference: t\n  } = z(e);\n  return ye({\n    namespace: n,\n    reference: t\n  });\n}\n\nfunction gn(e, n) {\n  const {\n    namespace: t,\n    reference: r\n  } = me(n);\n  return Ee({\n    namespace: t,\n    reference: r,\n    address: e\n  });\n}\n\nfunction Nn(e) {\n  return B(e, he);\n}\n\nfunction ge(e) {\n  return B(e, ve);\n}\n\nfunction bn(e, n = []) {\n  const t = [];\n  return Object.keys(e).forEach(r => {\n    if (n.length && !n.includes(r)) return;\n    const o = e[r];\n    t.push(...o.accounts);\n  }), t;\n}\n\nfunction On(e, n = []) {\n  const t = [];\n  return Object.keys(e).forEach(r => {\n    if (n.length && !n.includes(r)) return;\n    const o = e[r];\n    t.push(...ge(o.accounts));\n  }), t;\n}\n\nfunction Sn(e, n = []) {\n  const t = [];\n  return Object.keys(e).forEach(r => {\n    if (n.length && !n.includes(r)) return;\n    const o = e[r];\n    t.push(...V(r, o));\n  }), t;\n}\n\nfunction V(e, n) {\n  return e.includes(\":\") ? [e] : n.chains || [];\n}\n\nconst M = e => e === null || e === void 0 ? void 0 : e.split(\":\"),\n      Ne = e => {\n  const n = e && M(e);\n  if (n) return n[3];\n},\n      In = e => {\n  const n = e && M(e);\n  if (n) return n[2] + \":\" + n[3];\n},\n      be = e => {\n  const n = e && M(e);\n  if (n) return n.pop();\n},\n      Pn = (e, n) => {\n  const t = `${e.domain} wants you to sign in with your Ethereum account:`,\n        r = be(n),\n        o = e.statement,\n        s = `URI: ${e.aud}`,\n        c = `Version: ${e.version}`,\n        d = `Chain ID: ${Ne(n)}`,\n        l = `Nonce: ${e.nonce}`,\n        i = `Issued At: ${e.iat}`,\n        u = e.resources && e.resources.length > 0 ? `Resources:\n${e.resources.map(a => `- ${a}`).join(`\n`)}` : void 0;\n  return [t, r, \"\", o, \"\", s, c, d, l, i, u].filter(a => a != null).join(`\n`);\n},\n      G = \"base10\",\n      f = \"base16\",\n      K = \"base64pad\",\n      k = \"utf8\",\n      Y = 0,\n      U = 1,\n      Tn = 0,\n      Oe = 1,\n      W = 12,\n      J = 32;\n\nfunction Rn() {\n  const e = ue.generateKeyPair();\n  return {\n    privateKey: E(e.secretKey, f),\n    publicKey: E(e.publicKey, f)\n  };\n}\n\nfunction An() {\n  const e = ce(J);\n  return E(e, f);\n}\n\nfunction Un(e, n) {\n  const t = ue.sharedKey(h(e, f), h(n, f)),\n        r = new fn(pn, t).expand(J);\n  return E(r, f);\n}\n\nfunction _n(e) {\n  const n = ae(h(e, f));\n  return E(n, f);\n}\n\nfunction wn(e) {\n  const n = ae(h(e, k));\n  return E(n, f);\n}\n\nfunction Se(e) {\n  return h(`${e}`, G);\n}\n\nfunction j(e) {\n  return Number(E(e, G));\n}\n\nfunction jn(e) {\n  const n = Se(typeof e.type < \"u\" ? e.type : Y);\n  if (j(n) === U && typeof e.senderPublicKey > \"u\") throw new Error(\"Missing sender public key for type 1 envelope\");\n  const t = typeof e.senderPublicKey < \"u\" ? h(e.senderPublicKey, f) : void 0,\n        r = typeof e.iv < \"u\" ? h(e.iv, f) : ce(W),\n        o = new ie(h(e.symKey, f)).seal(r, h(e.message, k));\n  return Ie({\n    type: n,\n    sealed: o,\n    iv: r,\n    senderPublicKey: t\n  });\n}\n\nfunction Cn(e) {\n  const n = new ie(h(e.symKey, f)),\n        {\n    sealed: t,\n    iv: r\n  } = Q(e.encoded),\n        o = n.open(r, t);\n  if (o === null) throw new Error(\"Failed to decrypt\");\n  return E(o, k);\n}\n\nfunction Ie(e) {\n  if (j(e.type) === U) {\n    if (typeof e.senderPublicKey > \"u\") throw new Error(\"Missing sender public key for type 1 envelope\");\n    return E(de([e.type, e.senderPublicKey, e.iv, e.sealed]), K);\n  }\n\n  return E(de([e.type, e.iv, e.sealed]), K);\n}\n\nfunction Q(e) {\n  const n = h(e, K),\n        t = n.slice(Tn, Oe),\n        r = Oe;\n\n  if (j(t) === U) {\n    const d = r + J,\n          l = d + W,\n          i = n.slice(r, d),\n          u = n.slice(d, l),\n          a = n.slice(l);\n    return {\n      type: t,\n      sealed: a,\n      iv: u,\n      senderPublicKey: i\n    };\n  }\n\n  const o = r + W,\n        s = n.slice(r, o),\n        c = n.slice(o);\n  return {\n    type: t,\n    sealed: c,\n    iv: s\n  };\n}\n\nfunction $n(e, n) {\n  const t = Q(e);\n  return Pe({\n    type: j(t.type),\n    senderPublicKey: typeof t.senderPublicKey < \"u\" ? E(t.senderPublicKey, f) : void 0,\n    receiverPublicKey: n === null || n === void 0 ? void 0 : n.receiverPublicKey\n  });\n}\n\nfunction Pe(e) {\n  const n = (e === null || e === void 0 ? void 0 : e.type) || Y;\n\n  if (n === U) {\n    if (typeof (e === null || e === void 0 ? void 0 : e.senderPublicKey) > \"u\") throw new Error(\"missing sender public key\");\n    if (typeof (e === null || e === void 0 ? void 0 : e.receiverPublicKey) > \"u\") throw new Error(\"missing receiver public key\");\n  }\n\n  return {\n    type: n,\n    senderPublicKey: e === null || e === void 0 ? void 0 : e.senderPublicKey,\n    receiverPublicKey: e === null || e === void 0 ? void 0 : e.receiverPublicKey\n  };\n}\n\nfunction Dn(e) {\n  return e.type === U && typeof e.senderPublicKey == \"string\" && typeof e.receiverPublicKey == \"string\";\n}\n\nvar Vn = Object.defineProperty,\n    Te = Object.getOwnPropertySymbols,\n    Mn = Object.prototype.hasOwnProperty,\n    Kn = Object.prototype.propertyIsEnumerable,\n    Re = (e, n, t) => n in e ? Vn(e, n, {\n  enumerable: !0,\n  configurable: !0,\n  writable: !0,\n  value: t\n}) : e[n] = t,\n    Ae = (e, n) => {\n  for (var t in n || (n = {})) Mn.call(n, t) && Re(e, t, n[t]);\n\n  if (Te) for (var t of Te(n)) Kn.call(n, t) && Re(e, t, n[t]);\n  return e;\n};\n\nconst Ue = \"ReactNative\",\n      _ = {\n  reactNative: \"react-native\",\n  node: \"node\",\n  browser: \"browser\",\n  unknown: \"unknown\"\n},\n      L = \" \",\n      kn = \":\",\n      _e = \"/\",\n      Z = 2,\n      Ln = 1e3,\n      we = \"js\";\n\nfunction X() {\n  return typeof process < \"u\" && typeof process.versions < \"u\" && typeof process.versions.node < \"u\";\n}\n\nfunction je() {\n  return !En() && !!fe() && navigator.product === Ue;\n}\n\nfunction Ce() {\n  return !X() && !!fe();\n}\n\nfunction ee() {\n  return je() ? _.reactNative : X() ? _.node : Ce() ? _.browser : _.unknown;\n}\n\nfunction $e(e, n) {\n  let t = $.parse(e);\n  return t = Ae(Ae({}, t), n), e = $.stringify(t), e;\n}\n\nfunction xn() {\n  return hn() || {\n    name: \"\",\n    description: \"\",\n    url: \"\",\n    icons: [\"\"]\n  };\n}\n\nfunction Fn(e, n) {\n  var t;\n  const r = ee(),\n        o = {\n    protocol: e,\n    version: n,\n    env: r\n  };\n  return r === \"browser\" && (o.host = ((t = pe()) == null ? void 0 : t.host) || \"unknown\"), o;\n}\n\nfunction De() {\n  const e = mn();\n  if (e === null) return \"unknown\";\n  const n = e.os ? e.os.replace(\" \", \"\").toLowerCase() : \"unknown\";\n  return e.type === \"browser\" ? [n, e.name, e.version].join(\"-\") : [n, e.version].join(\"-\");\n}\n\nfunction Ve() {\n  var e;\n  const n = ee();\n  return n === _.browser ? [n, ((e = pe()) == null ? void 0 : e.host) || \"unknown\"].join(\":\") : n;\n}\n\nfunction Me(e, n, t) {\n  const r = De(),\n        o = Ve();\n  return [[e, n].join(\"-\"), [we, t].join(\"-\"), r, o].join(\"/\");\n}\n\nfunction Hn({\n  protocol: e,\n  version: n,\n  relayUrl: t,\n  sdkVersion: r,\n  auth: o,\n  projectId: s,\n  useOnCloseEvent: c\n}) {\n  const d = t.split(\"?\"),\n        l = Me(e, n, r),\n        i = {\n    auth: o,\n    ua: l,\n    projectId: s,\n    useOnCloseEvent: c || void 0\n  },\n        u = $e(d[1] || \"\", i);\n  return d[0] + \"?\" + u;\n}\n\nfunction qn(e) {\n  let n = (e.match(/^[^:]+(?=:\\/\\/)/gi) || [])[0];\n  const t = typeof n < \"u\" ? e.split(\"://\")[1] : e;\n  return n = n === \"wss\" ? \"https\" : \"http\", [n, t].join(\"://\");\n}\n\nfunction zn(e, n, t) {\n  if (!e[n] || typeof e[n] !== t) throw new Error(`Missing or invalid \"${n}\" param`);\n}\n\nfunction Ke(e, n = Z) {\n  return ke(e.split(_e), n);\n}\n\nfunction Bn(e) {\n  return Ke(e).join(L);\n}\n\nfunction b(e, n) {\n  return e.filter(t => n.includes(t)).length === e.length;\n}\n\nfunction ke(e, n = Z) {\n  return e.slice(Math.max(e.length - n, 0));\n}\n\nfunction Gn(e) {\n  return Object.fromEntries(e.entries());\n}\n\nfunction Yn(e) {\n  return new Map(Object.entries(e));\n}\n\nfunction Wn(e, n) {\n  const t = {};\n  return Object.keys(e).forEach(r => {\n    t[r] = n(e[r]);\n  }), t;\n}\n\nconst Jn = e => e;\n\nfunction Le(e) {\n  return e.trim().replace(/^\\w/, n => n.toUpperCase());\n}\n\nfunction Qn(e) {\n  return e.split(L).map(n => Le(n)).join(L);\n}\n\nfunction Zn(e = le, n) {\n  const t = q(e || le);\n  let r, o, s;\n  return {\n    resolve: c => {\n      s && r && (clearTimeout(s), r(c));\n    },\n    reject: c => {\n      s && o && (clearTimeout(s), o(c));\n    },\n    done: () => new Promise((c, d) => {\n      s = setTimeout(() => {\n        d(new Error(n));\n      }, t), r = c, o = d;\n    })\n  };\n}\n\nfunction Xn(e, n, t) {\n  return new Promise(async (r, o) => {\n    const s = setTimeout(() => o(new Error(t)), n);\n\n    try {\n      const c = await e;\n      r(c);\n    } catch (c) {\n      o(c);\n    }\n\n    clearTimeout(s);\n  });\n}\n\nfunction ne(e, n) {\n  if (typeof n == \"string\" && n.startsWith(`${e}:`)) return n;\n\n  if (e.toLowerCase() === \"topic\") {\n    if (typeof n != \"string\") throw new Error('Value must be \"string\" for expirer target type: topic');\n    return `topic:${n}`;\n  } else if (e.toLowerCase() === \"id\") {\n    if (typeof n != \"number\") throw new Error('Value must be \"number\" for expirer target type: id');\n    return `id:${n}`;\n  }\n\n  throw new Error(`Unknown expirer target type: ${e}`);\n}\n\nfunction et(e) {\n  return ne(\"topic\", e);\n}\n\nfunction nt(e) {\n  return ne(\"id\", e);\n}\n\nfunction tt(e) {\n  const [n, t] = e.split(\":\"),\n        r = {\n    id: void 0,\n    topic: void 0\n  };\n  if (n === \"topic\" && typeof t == \"string\") r.topic = t;else if (n === \"id\" && Number.isInteger(Number(t))) r.id = Number(t);else throw new Error(`Invalid target, expected id:number or topic:string, got ${n}:${t}`);\n  return r;\n}\n\nfunction rt(e, n) {\n  return yn((n || Date.now()) + q(e));\n}\n\nfunction ot(e) {\n  return Date.now() >= q(e);\n}\n\nfunction st(e, n) {\n  return `${e}${n ? `:${n}` : \"\"}`;\n}\n\nfunction O(e = [], n = []) {\n  return [...new Set([...e, ...n])];\n}\n\nconst xe = \"irn\";\n\nfunction it(e) {\n  return (e === null || e === void 0 ? void 0 : e.relay) || {\n    protocol: xe\n  };\n}\n\nfunction ct(e) {\n  const n = vn[e];\n  if (typeof n > \"u\") throw new Error(`Relay Protocol not supported: ${e}`);\n  return n;\n}\n\nvar at = Object.defineProperty,\n    Fe = Object.getOwnPropertySymbols,\n    ut = Object.prototype.hasOwnProperty,\n    dt = Object.prototype.propertyIsEnumerable,\n    He = (e, n, t) => n in e ? at(e, n, {\n  enumerable: !0,\n  configurable: !0,\n  writable: !0,\n  value: t\n}) : e[n] = t,\n    lt = (e, n) => {\n  for (var t in n || (n = {})) ut.call(n, t) && He(e, t, n[t]);\n\n  if (Fe) for (var t of Fe(n)) dt.call(n, t) && He(e, t, n[t]);\n  return e;\n};\n\nfunction qe(e, n = \"-\") {\n  const t = {},\n        r = \"relay\" + n;\n  return Object.keys(e).forEach(o => {\n    if (o.startsWith(r)) {\n      const s = o.replace(r, \"\"),\n            c = e[o];\n      t[s] = c;\n    }\n  }), t;\n}\n\nfunction ft(e) {\n  const n = e.indexOf(\":\"),\n        t = e.indexOf(\"?\") !== -1 ? e.indexOf(\"?\") : void 0,\n        r = e.substring(0, n),\n        o = e.substring(n + 1, t).split(\"@\"),\n        s = typeof t < \"u\" ? e.substring(t) : \"\",\n        c = $.parse(s);\n  return {\n    protocol: r,\n    topic: o[0],\n    version: parseInt(o[1], 10),\n    symKey: c.symKey,\n    relay: qe(c)\n  };\n}\n\nfunction ze(e, n = \"-\") {\n  const t = \"relay\",\n        r = {};\n  return Object.keys(e).forEach(o => {\n    const s = t + n + o;\n    e[o] && (r[s] = e[o]);\n  }), r;\n}\n\nfunction pt(e) {\n  return `${e.protocol}:${e.topic}@${e.version}?` + $.stringify(lt({\n    symKey: e.symKey\n  }, ze(e.relay)));\n}\n\nvar mt = Object.defineProperty,\n    yt = Object.defineProperties,\n    Et = Object.getOwnPropertyDescriptors,\n    Be = Object.getOwnPropertySymbols,\n    ht = Object.prototype.hasOwnProperty,\n    vt = Object.prototype.propertyIsEnumerable,\n    Ge = (e, n, t) => n in e ? mt(e, n, {\n  enumerable: !0,\n  configurable: !0,\n  writable: !0,\n  value: t\n}) : e[n] = t,\n    gt = (e, n) => {\n  for (var t in n || (n = {})) ht.call(n, t) && Ge(e, t, n[t]);\n\n  if (Be) for (var t of Be(n)) vt.call(n, t) && Ge(e, t, n[t]);\n  return e;\n},\n    Nt = (e, n) => yt(e, Et(n));\n\nfunction T(e) {\n  const n = [];\n  return e.forEach(t => {\n    const [r, o] = t.split(\":\");\n    n.push(`${r}:${o}`);\n  }), n;\n}\n\nfunction Ye(e) {\n  const n = [];\n  return Object.values(e).forEach(t => {\n    n.push(...T(t.accounts));\n  }), n;\n}\n\nfunction We(e, n) {\n  const t = [];\n  return Object.values(e).forEach(r => {\n    T(r.accounts).includes(n) && t.push(...r.methods);\n  }), t;\n}\n\nfunction Je(e, n) {\n  const t = [];\n  return Object.values(e).forEach(r => {\n    T(r.accounts).includes(n) && t.push(...r.events);\n  }), t;\n}\n\nfunction bt(e, n) {\n  const t = on(e, n);\n  if (t) throw new Error(t.message);\n  const r = {};\n\n  for (const [o, s] of Object.entries(e)) r[o] = {\n    methods: s.methods,\n    events: s.events,\n    chains: s.accounts.map(c => `${c.split(\":\")[0]}:${c.split(\":\")[1]}`)\n  };\n\n  return r;\n}\n\nfunction Ot(e) {\n  const {\n    proposal: {\n      requiredNamespaces: n,\n      optionalNamespaces: t = {}\n    },\n    supportedNamespaces: r\n  } = e,\n        o = re(n),\n        s = re(t),\n        c = {};\n  Object.keys(r).forEach(i => {\n    const u = r[i].chains,\n          a = r[i].methods,\n          g = r[i].events,\n          A = r[i].accounts;\n    c[i] = {\n      chains: u,\n      methods: a,\n      events: g,\n      accounts: A\n    };\n  });\n  const d = cn(n, c, \"approve()\");\n  if (d) throw new Error(d.message);\n  const l = {};\n  return Object.keys(o).forEach(i => {\n    const u = r[i].chains.filter(v => {\n      var p, y;\n      return (y = (p = o[i]) == null ? void 0 : p.chains) == null ? void 0 : y.includes(v);\n    }),\n          a = r[i].methods.filter(v => {\n      var p, y;\n      return (y = (p = o[i]) == null ? void 0 : p.methods) == null ? void 0 : y.includes(v);\n    }),\n          g = r[i].events.filter(v => {\n      var p, y;\n      return (y = (p = o[i]) == null ? void 0 : p.events) == null ? void 0 : y.includes(v);\n    }),\n          A = u.map(v => r[i].accounts.filter(p => p.includes(v))).flat();\n    l[i] = {\n      chains: u,\n      methods: a,\n      events: g,\n      accounts: A\n    };\n  }), Object.keys(s).forEach(i => {\n    var u, a, g, A, v, p;\n    if (!r[i]) return;\n    const y = (a = (u = s[i]) == null ? void 0 : u.chains) == null ? void 0 : a.filter(I => r[i].chains.includes(I)),\n          un = r[i].methods.filter(I => {\n      var P, w;\n      return (w = (P = s[i]) == null ? void 0 : P.methods) == null ? void 0 : w.includes(I);\n    }),\n          dn = r[i].events.filter(I => {\n      var P, w;\n      return (w = (P = s[i]) == null ? void 0 : P.events) == null ? void 0 : w.includes(I);\n    }),\n          ln = y === null || y === void 0 ? void 0 : y.map(I => r[i].accounts.filter(P => P.includes(I))).flat();\n    l[i] = {\n      chains: O((g = l[i]) == null ? void 0 : g.chains, y),\n      methods: O((A = l[i]) == null ? void 0 : A.methods, un),\n      events: O((v = l[i]) == null ? void 0 : v.events, dn),\n      accounts: O((p = l[i]) == null ? void 0 : p.accounts, ln)\n    };\n  }), l;\n}\n\nfunction te(e) {\n  return e.includes(\":\");\n}\n\nfunction Qe(e) {\n  return te(e) ? e.split(\":\")[0] : e;\n}\n\nfunction re(e) {\n  var n, t, r;\n  const o = {};\n  if (!x(e)) return o;\n\n  for (const [s, c] of Object.entries(e)) {\n    const d = te(s) ? [s] : c.chains,\n          l = c.methods || [],\n          i = c.events || [],\n          u = Qe(s);\n    o[u] = Nt(gt({}, o[u]), {\n      chains: O(d, (n = o[u]) == null ? void 0 : n.chains),\n      methods: O(l, (t = o[u]) == null ? void 0 : t.methods),\n      events: O(i, (r = o[u]) == null ? void 0 : r.events)\n    });\n  }\n\n  return o;\n}\n\nconst St = {\n  INVALID_METHOD: {\n    message: \"Invalid method.\",\n    code: 1001\n  },\n  INVALID_EVENT: {\n    message: \"Invalid event.\",\n    code: 1002\n  },\n  INVALID_UPDATE_REQUEST: {\n    message: \"Invalid update request.\",\n    code: 1003\n  },\n  INVALID_EXTEND_REQUEST: {\n    message: \"Invalid extend request.\",\n    code: 1004\n  },\n  INVALID_SESSION_SETTLE_REQUEST: {\n    message: \"Invalid session settle request.\",\n    code: 1005\n  },\n  UNAUTHORIZED_METHOD: {\n    message: \"Unauthorized method.\",\n    code: 3001\n  },\n  UNAUTHORIZED_EVENT: {\n    message: \"Unauthorized event.\",\n    code: 3002\n  },\n  UNAUTHORIZED_UPDATE_REQUEST: {\n    message: \"Unauthorized update request.\",\n    code: 3003\n  },\n  UNAUTHORIZED_EXTEND_REQUEST: {\n    message: \"Unauthorized extend request.\",\n    code: 3004\n  },\n  USER_REJECTED: {\n    message: \"User rejected.\",\n    code: 5e3\n  },\n  USER_REJECTED_CHAINS: {\n    message: \"User rejected chains.\",\n    code: 5001\n  },\n  USER_REJECTED_METHODS: {\n    message: \"User rejected methods.\",\n    code: 5002\n  },\n  USER_REJECTED_EVENTS: {\n    message: \"User rejected events.\",\n    code: 5003\n  },\n  UNSUPPORTED_CHAINS: {\n    message: \"Unsupported chains.\",\n    code: 5100\n  },\n  UNSUPPORTED_METHODS: {\n    message: \"Unsupported methods.\",\n    code: 5101\n  },\n  UNSUPPORTED_EVENTS: {\n    message: \"Unsupported events.\",\n    code: 5102\n  },\n  UNSUPPORTED_ACCOUNTS: {\n    message: \"Unsupported accounts.\",\n    code: 5103\n  },\n  UNSUPPORTED_NAMESPACE_KEY: {\n    message: \"Unsupported namespace key.\",\n    code: 5104\n  },\n  USER_DISCONNECTED: {\n    message: \"User disconnected.\",\n    code: 6e3\n  },\n  SESSION_SETTLEMENT_FAILED: {\n    message: \"Session settlement failed.\",\n    code: 7e3\n  },\n  WC_METHOD_UNSUPPORTED: {\n    message: \"Unsupported wc_ method.\",\n    code: 10001\n  }\n},\n      It = {\n  NOT_INITIALIZED: {\n    message: \"Not initialized.\",\n    code: 1\n  },\n  NO_MATCHING_KEY: {\n    message: \"No matching key.\",\n    code: 2\n  },\n  RESTORE_WILL_OVERRIDE: {\n    message: \"Restore will override.\",\n    code: 3\n  },\n  RESUBSCRIBED: {\n    message: \"Resubscribed.\",\n    code: 4\n  },\n  MISSING_OR_INVALID: {\n    message: \"Missing or invalid.\",\n    code: 5\n  },\n  EXPIRED: {\n    message: \"Expired.\",\n    code: 6\n  },\n  UNKNOWN_TYPE: {\n    message: \"Unknown type.\",\n    code: 7\n  },\n  MISMATCHED_TOPIC: {\n    message: \"Mismatched topic.\",\n    code: 8\n  },\n  NON_CONFORMING_NAMESPACES: {\n    message: \"Non conforming namespaces.\",\n    code: 9\n  }\n};\n\nfunction N(e, n) {\n  const {\n    message: t,\n    code: r\n  } = It[e];\n  return {\n    message: n ? `${t} ${n}` : t,\n    code: r\n  };\n}\n\nfunction R(e, n) {\n  const {\n    message: t,\n    code: r\n  } = St[e];\n  return {\n    message: n ? `${t} ${n}` : t,\n    code: r\n  };\n}\n\nfunction C(e, n) {\n  return Array.isArray(e) ? typeof n < \"u\" && e.length ? e.every(n) : !0 : !1;\n}\n\nfunction x(e) {\n  return Object.getPrototypeOf(e) === Object.prototype && Object.keys(e).length;\n}\n\nfunction S(e) {\n  return typeof e > \"u\";\n}\n\nfunction m(e, n) {\n  return n && S(e) ? !0 : typeof e == \"string\" && Boolean(e.trim().length);\n}\n\nfunction F(e, n) {\n  return n && S(e) ? !0 : typeof e == \"number\" && !isNaN(e);\n}\n\nfunction Pt(e, n) {\n  const {\n    requiredNamespaces: t\n  } = n,\n        r = Object.keys(e.namespaces),\n        o = Object.keys(t);\n  let s = !0;\n  return b(o, r) ? (r.forEach(c => {\n    const {\n      accounts: d,\n      methods: l,\n      events: i\n    } = e.namespaces[c],\n          u = T(d),\n          a = t[c];\n    (!b(V(c, a), u) || !b(a.methods, l) || !b(a.events, i)) && (s = !1);\n  }), s) : !1;\n}\n\nfunction H(e) {\n  return m(e, !1) && e.includes(\":\") ? e.split(\":\").length === 2 : !1;\n}\n\nfunction Ze(e) {\n  if (m(e, !1) && e.includes(\":\")) {\n    const n = e.split(\":\");\n\n    if (n.length === 3) {\n      const t = n[0] + \":\" + n[1];\n      return !!n[2] && H(t);\n    }\n  }\n\n  return !1;\n}\n\nfunction Tt(e) {\n  if (m(e, !1)) try {\n    return typeof new URL(e) < \"u\";\n  } catch {\n    return !1;\n  }\n  return !1;\n}\n\nfunction Rt(e) {\n  var n;\n  return (n = e === null || e === void 0 ? void 0 : e.proposer) == null ? void 0 : n.publicKey;\n}\n\nfunction At(e) {\n  return e === null || e === void 0 ? void 0 : e.topic;\n}\n\nfunction Ut(e, n) {\n  let t = null;\n  return m(e === null || e === void 0 ? void 0 : e.publicKey, !1) || (t = N(\"MISSING_OR_INVALID\", `${n} controller public key should be a string`)), t;\n}\n\nfunction oe(e) {\n  let n = !0;\n  return C(e) ? e.length && (n = e.every(t => m(t, !1))) : n = !1, n;\n}\n\nfunction Xe(e, n, t) {\n  let r = null;\n  return C(n) ? n.forEach(o => {\n    r || (!H(o) || !o.includes(e)) && (r = R(\"UNSUPPORTED_CHAINS\", `${t}, chain ${o} should be a string and conform to \"namespace:chainId\" format`));\n  }) : r = R(\"UNSUPPORTED_CHAINS\", `${t}, chains ${n} should be an array of strings conforming to \"namespace:chainId\" format`), r;\n}\n\nfunction en(e, n) {\n  let t = null;\n  return Object.entries(e).forEach(([r, o]) => {\n    if (t) return;\n    const s = Xe(r, V(r, o), `${n} requiredNamespace`);\n    s && (t = s);\n  }), t;\n}\n\nfunction nn(e, n) {\n  let t = null;\n  return C(e) ? e.forEach(r => {\n    t || Ze(r) || (t = R(\"UNSUPPORTED_ACCOUNTS\", `${n}, account ${r} should be a string and conform to \"namespace:chainId:address\" format`));\n  }) : t = R(\"UNSUPPORTED_ACCOUNTS\", `${n}, accounts should be an array of strings conforming to \"namespace:chainId:address\" format`), t;\n}\n\nfunction tn(e, n) {\n  let t = null;\n  return Object.values(e).forEach(r => {\n    if (t) return;\n    const o = nn(r === null || r === void 0 ? void 0 : r.accounts, `${n} namespace`);\n    o && (t = o);\n  }), t;\n}\n\nfunction rn(e, n) {\n  let t = null;\n  return oe(e === null || e === void 0 ? void 0 : e.methods) ? oe(e === null || e === void 0 ? void 0 : e.events) || (t = R(\"UNSUPPORTED_EVENTS\", `${n}, events should be an array of strings or empty array for no events`)) : t = R(\"UNSUPPORTED_METHODS\", `${n}, methods should be an array of strings or empty array for no methods`), t;\n}\n\nfunction se(e, n) {\n  let t = null;\n  return Object.values(e).forEach(r => {\n    if (t) return;\n    const o = rn(r, `${n}, namespace`);\n    o && (t = o);\n  }), t;\n}\n\nfunction _t(e, n, t) {\n  let r = null;\n\n  if (e && x(e)) {\n    const o = se(e, n);\n    o && (r = o);\n    const s = en(e, n);\n    s && (r = s);\n  } else r = N(\"MISSING_OR_INVALID\", `${n}, ${t} should be an object with data`);\n\n  return r;\n}\n\nfunction on(e, n) {\n  let t = null;\n\n  if (e && x(e)) {\n    const r = se(e, n);\n    r && (t = r);\n    const o = tn(e, n);\n    o && (t = o);\n  } else t = N(\"MISSING_OR_INVALID\", `${n}, namespaces should be an object with data`);\n\n  return t;\n}\n\nfunction sn(e) {\n  return m(e.protocol, !0);\n}\n\nfunction wt(e, n) {\n  let t = !1;\n  return n && !e ? t = !0 : e && C(e) && e.length && e.forEach(r => {\n    t = sn(r);\n  }), t;\n}\n\nfunction jt(e) {\n  return typeof e == \"number\";\n}\n\nfunction Ct(e) {\n  return typeof e < \"u\" && typeof e !== null;\n}\n\nfunction $t(e) {\n  return !(!e || typeof e != \"object\" || !e.code || !F(e.code, !1) || !e.message || !m(e.message, !1));\n}\n\nfunction Dt(e) {\n  return !(S(e) || !m(e.method, !1));\n}\n\nfunction Vt(e) {\n  return !(S(e) || S(e.result) && S(e.error) || !F(e.id, !1) || !m(e.jsonrpc, !1));\n}\n\nfunction Mt(e) {\n  return !(S(e) || !m(e.name, !1));\n}\n\nfunction Kt(e, n) {\n  return !(!H(n) || !Ye(e).includes(n));\n}\n\nfunction kt(e, n, t) {\n  return m(t, !1) ? We(e, n).includes(t) : !1;\n}\n\nfunction Lt(e, n, t) {\n  return m(t, !1) ? Je(e, n).includes(t) : !1;\n}\n\nfunction cn(e, n, t) {\n  let r = null;\n  const o = xt(e),\n        s = Ft(n),\n        c = Object.keys(o),\n        d = Object.keys(s),\n        l = an(Object.keys(e)),\n        i = an(Object.keys(n)),\n        u = l.filter(a => !i.includes(a));\n  return u.length && (r = N(\"NON_CONFORMING_NAMESPACES\", `${t} namespaces keys don't satisfy requiredNamespaces.\n      Required: ${u.toString()}\n      Received: ${Object.keys(n).toString()}`)), b(c, d) || (r = N(\"NON_CONFORMING_NAMESPACES\", `${t} namespaces chains don't satisfy required namespaces.\n      Required: ${c.toString()}\n      Approved: ${d.toString()}`)), Object.keys(n).forEach(a => {\n    if (!a.includes(\":\") || r) return;\n    const g = T(n[a].accounts);\n    g.includes(a) || (r = N(\"NON_CONFORMING_NAMESPACES\", `${t} namespaces accounts don't satisfy namespace accounts for ${a}\n        Required: ${a}\n        Approved: ${g.toString()}`));\n  }), c.forEach(a => {\n    r || (b(o[a].methods, s[a].methods) ? b(o[a].events, s[a].events) || (r = N(\"NON_CONFORMING_NAMESPACES\", `${t} namespaces events don't satisfy namespace events for ${a}`)) : r = N(\"NON_CONFORMING_NAMESPACES\", `${t} namespaces methods don't satisfy namespace methods for ${a}`));\n  }), r;\n}\n\nfunction xt(e) {\n  const n = {};\n  return Object.keys(e).forEach(t => {\n    var r;\n    t.includes(\":\") ? n[t] = e[t] : (r = e[t].chains) == null || r.forEach(o => {\n      n[o] = {\n        methods: e[t].methods,\n        events: e[t].events\n      };\n    });\n  }), n;\n}\n\nfunction an(e) {\n  return [...new Set(e.map(n => n.includes(\":\") ? n.split(\":\")[0] : n))];\n}\n\nfunction Ft(e) {\n  const n = {};\n  return Object.keys(e).forEach(t => {\n    if (t.includes(\":\")) n[t] = e[t];else {\n      const r = T(e[t].accounts);\n      r === null || r === void 0 ? void 0 : r.forEach(o => {\n        n[o] = {\n          accounts: e[t].accounts.filter(s => s.includes(`${o}:`)),\n          methods: e[t].methods,\n          events: e[t].events\n        };\n      });\n    }\n  }), n;\n}\n\nfunction Ht(e, n) {\n  return F(e, !1) && e <= n.max && e >= n.min;\n}\n\nexport { G as BASE10, f as BASE16, K as BASE64, kn as COLON, Z as DEFAULT_DEPTH, L as EMPTY_SPACE, _ as ENV_MAP, Ln as ONE_THOUSAND, Ue as REACT_NATIVE_PRODUCT, xe as RELAYER_DEFAULT_PROTOCOL, we as SDK_TYPE, _e as SLASH, Y as TYPE_0, U as TYPE_1, k as UTF8, $e as appendToQueryString, zn as assertType, Ot as buildApprovedNamespaces, rt as calcExpiry, Qn as capitalize, Le as capitalizeWord, Zn as createDelayedPromise, Xn as createExpiringPromise, j as decodeTypeByte, Cn as decrypt, Un as deriveSymKey, Q as deserialize, Se as encodeTypeByte, jn as encrypt, st as engineEvent, Jn as enumify, Ee as formatAccountId, gn as formatAccountWithChain, ye as formatChainId, ne as formatExpirerTarget, nt as formatIdTarget, Pn as formatMessage, Bn as formatMessageContext, ze as formatRelayParams, Hn as formatRelayRpcUrl, et as formatTopicTarget, Me as formatUA, pt as formatUri, Rn as generateKeyPair, An as generateRandomBytes32, T as getAccountsChains, bn as getAccountsFromNamespaces, he as getAddressFromAccount, Nn as getAddressesFromAccounts, xn as getAppMetadata, ve as getChainFromAccount, ge as getChainsFromAccounts, V as getChainsFromNamespace, On as getChainsFromNamespaces, Sn as getChainsFromRequiredNamespaces, be as getDidAddress, M as getDidAddressSegments, Ne as getDidChainId, ee as getEnvironment, qn as getHttpUrl, N as getInternalError, Ve as getJavascriptID, De as getJavascriptOS, ke as getLastItems, In as getNamespacedDidChainId, Ye as getNamespacesChains, Je as getNamespacesEventsForChainId, We as getNamespacesMethodsForChainId, Fn as getRelayClientMetadata, ct as getRelayProtocolApi, it as getRelayProtocolName, bt as getRequiredNamespacesFromNamespaces, R as getSdkError, B as getUniqueValues, b as hasOverlap, _n as hashKey, wn as hashMessage, Ce as isBrowser, te as isCaipNamespace, cn as isConformingNamespaces, ot as isExpired, X as isNode, Rt as isProposalStruct, je as isReactNative, Pt as isSessionCompatible, At as isSessionStruct, Dn as isTypeOneEnvelope, S as isUndefined, Ze as isValidAccountId, nn as isValidAccounts, rn as isValidActions, C as isValidArray, H as isValidChainId, Xe as isValidChains, Ut as isValidController, $t as isValidErrorReason, Mt as isValidEvent, jt as isValidId, tn as isValidNamespaceAccounts, se as isValidNamespaceActions, en as isValidNamespaceChains, oe as isValidNamespaceMethodsOrEvents, on as isValidNamespaces, Kt as isValidNamespacesChainId, Lt as isValidNamespacesEvent, kt as isValidNamespacesRequest, F as isValidNumber, x as isValidObject, Ct as isValidParams, sn as isValidRelay, wt as isValidRelays, Dt as isValidRequest, Ht as isValidRequestExpiry, _t as isValidRequiredNamespaces, Vt as isValidResponse, m as isValidString, Tt as isValidUrl, Wn as mapEntries, Gn as mapToObj, O as mergeArrays, re as normalizeNamespaces, Yn as objToMap, z as parseAccountId, me as parseChainId, Ke as parseContextNames, tt as parseExpirerTarget, Qe as parseNamespaceKey, qe as parseRelayParams, ft as parseUri, Ie as serialize, $n as validateDecoding, Pe as validateEncoding };","map":{"version":3,"sources":[],"names":[],"mappings":"","sourcesContent":["import{ChaCha20Poly1305 as ie}from\"@stablelib/chacha20poly1305\";import{HKDF as fn}from\"@stablelib/hkdf\";import{randomBytes as ce}from\"@stablelib/random\";import{SHA256 as pn,hash as ae}from\"@stablelib/sha256\";import*as ue from\"@stablelib/x25519\";import{toString as E,fromString as h,concat as de}from\"uint8arrays\";import{detect as mn}from\"detect-browser\";import{toMiliseconds as q,FIVE_MINUTES as le,fromMiliseconds as yn}from\"@walletconnect/time\";import{getDocument as En,getNavigator as fe,getLocation as pe}from\"@walletconnect/window-getters\";import{getWindowMetadata as hn}from\"@walletconnect/window-metadata\";import*as $ from\"query-string\";import{RELAY_JSONRPC as vn}from\"@walletconnect/relay-api\";const D=\":\";function me(e){const[n,t]=e.split(D);return{namespace:n,reference:t}}function ye(e){const{namespace:n,reference:t}=e;return[n,t].join(D)}function z(e){const[n,t,r]=e.split(D);return{namespace:n,reference:t,address:r}}function Ee(e){const{namespace:n,reference:t,address:r}=e;return[n,t,r].join(D)}function B(e,n){const t=[];return e.forEach(r=>{const o=n(r);t.includes(o)||t.push(o)}),t}function he(e){const{address:n}=z(e);return n}function ve(e){const{namespace:n,reference:t}=z(e);return ye({namespace:n,reference:t})}function gn(e,n){const{namespace:t,reference:r}=me(n);return Ee({namespace:t,reference:r,address:e})}function Nn(e){return B(e,he)}function ge(e){return B(e,ve)}function bn(e,n=[]){const t=[];return Object.keys(e).forEach(r=>{if(n.length&&!n.includes(r))return;const o=e[r];t.push(...o.accounts)}),t}function On(e,n=[]){const t=[];return Object.keys(e).forEach(r=>{if(n.length&&!n.includes(r))return;const o=e[r];t.push(...ge(o.accounts))}),t}function Sn(e,n=[]){const t=[];return Object.keys(e).forEach(r=>{if(n.length&&!n.includes(r))return;const o=e[r];t.push(...V(r,o))}),t}function V(e,n){return e.includes(\":\")?[e]:n.chains||[]}const M=e=>e?.split(\":\"),Ne=e=>{const n=e&&M(e);if(n)return n[3]},In=e=>{const n=e&&M(e);if(n)return n[2]+\":\"+n[3]},be=e=>{const n=e&&M(e);if(n)return n.pop()},Pn=(e,n)=>{const t=`${e.domain} wants you to sign in with your Ethereum account:`,r=be(n),o=e.statement,s=`URI: ${e.aud}`,c=`Version: ${e.version}`,d=`Chain ID: ${Ne(n)}`,l=`Nonce: ${e.nonce}`,i=`Issued At: ${e.iat}`,u=e.resources&&e.resources.length>0?`Resources:\n${e.resources.map(a=>`- ${a}`).join(`\n`)}`:void 0;return[t,r,\"\",o,\"\",s,c,d,l,i,u].filter(a=>a!=null).join(`\n`)},G=\"base10\",f=\"base16\",K=\"base64pad\",k=\"utf8\",Y=0,U=1,Tn=0,Oe=1,W=12,J=32;function Rn(){const e=ue.generateKeyPair();return{privateKey:E(e.secretKey,f),publicKey:E(e.publicKey,f)}}function An(){const e=ce(J);return E(e,f)}function Un(e,n){const t=ue.sharedKey(h(e,f),h(n,f)),r=new fn(pn,t).expand(J);return E(r,f)}function _n(e){const n=ae(h(e,f));return E(n,f)}function wn(e){const n=ae(h(e,k));return E(n,f)}function Se(e){return h(`${e}`,G)}function j(e){return Number(E(e,G))}function jn(e){const n=Se(typeof e.type<\"u\"?e.type:Y);if(j(n)===U&&typeof e.senderPublicKey>\"u\")throw new Error(\"Missing sender public key for type 1 envelope\");const t=typeof e.senderPublicKey<\"u\"?h(e.senderPublicKey,f):void 0,r=typeof e.iv<\"u\"?h(e.iv,f):ce(W),o=new ie(h(e.symKey,f)).seal(r,h(e.message,k));return Ie({type:n,sealed:o,iv:r,senderPublicKey:t})}function Cn(e){const n=new ie(h(e.symKey,f)),{sealed:t,iv:r}=Q(e.encoded),o=n.open(r,t);if(o===null)throw new Error(\"Failed to decrypt\");return E(o,k)}function Ie(e){if(j(e.type)===U){if(typeof e.senderPublicKey>\"u\")throw new Error(\"Missing sender public key for type 1 envelope\");return E(de([e.type,e.senderPublicKey,e.iv,e.sealed]),K)}return E(de([e.type,e.iv,e.sealed]),K)}function Q(e){const n=h(e,K),t=n.slice(Tn,Oe),r=Oe;if(j(t)===U){const d=r+J,l=d+W,i=n.slice(r,d),u=n.slice(d,l),a=n.slice(l);return{type:t,sealed:a,iv:u,senderPublicKey:i}}const o=r+W,s=n.slice(r,o),c=n.slice(o);return{type:t,sealed:c,iv:s}}function $n(e,n){const t=Q(e);return Pe({type:j(t.type),senderPublicKey:typeof t.senderPublicKey<\"u\"?E(t.senderPublicKey,f):void 0,receiverPublicKey:n?.receiverPublicKey})}function Pe(e){const n=e?.type||Y;if(n===U){if(typeof e?.senderPublicKey>\"u\")throw new Error(\"missing sender public key\");if(typeof e?.receiverPublicKey>\"u\")throw new Error(\"missing receiver public key\")}return{type:n,senderPublicKey:e?.senderPublicKey,receiverPublicKey:e?.receiverPublicKey}}function Dn(e){return e.type===U&&typeof e.senderPublicKey==\"string\"&&typeof e.receiverPublicKey==\"string\"}var Vn=Object.defineProperty,Te=Object.getOwnPropertySymbols,Mn=Object.prototype.hasOwnProperty,Kn=Object.prototype.propertyIsEnumerable,Re=(e,n,t)=>n in e?Vn(e,n,{enumerable:!0,configurable:!0,writable:!0,value:t}):e[n]=t,Ae=(e,n)=>{for(var t in n||(n={}))Mn.call(n,t)&&Re(e,t,n[t]);if(Te)for(var t of Te(n))Kn.call(n,t)&&Re(e,t,n[t]);return e};const Ue=\"ReactNative\",_={reactNative:\"react-native\",node:\"node\",browser:\"browser\",unknown:\"unknown\"},L=\" \",kn=\":\",_e=\"/\",Z=2,Ln=1e3,we=\"js\";function X(){return typeof process<\"u\"&&typeof process.versions<\"u\"&&typeof process.versions.node<\"u\"}function je(){return!En()&&!!fe()&&navigator.product===Ue}function Ce(){return!X()&&!!fe()}function ee(){return je()?_.reactNative:X()?_.node:Ce()?_.browser:_.unknown}function $e(e,n){let t=$.parse(e);return t=Ae(Ae({},t),n),e=$.stringify(t),e}function xn(){return hn()||{name:\"\",description:\"\",url:\"\",icons:[\"\"]}}function Fn(e,n){var t;const r=ee(),o={protocol:e,version:n,env:r};return r===\"browser\"&&(o.host=((t=pe())==null?void 0:t.host)||\"unknown\"),o}function De(){const e=mn();if(e===null)return\"unknown\";const n=e.os?e.os.replace(\" \",\"\").toLowerCase():\"unknown\";return e.type===\"browser\"?[n,e.name,e.version].join(\"-\"):[n,e.version].join(\"-\")}function Ve(){var e;const n=ee();return n===_.browser?[n,((e=pe())==null?void 0:e.host)||\"unknown\"].join(\":\"):n}function Me(e,n,t){const r=De(),o=Ve();return[[e,n].join(\"-\"),[we,t].join(\"-\"),r,o].join(\"/\")}function Hn({protocol:e,version:n,relayUrl:t,sdkVersion:r,auth:o,projectId:s,useOnCloseEvent:c}){const d=t.split(\"?\"),l=Me(e,n,r),i={auth:o,ua:l,projectId:s,useOnCloseEvent:c||void 0},u=$e(d[1]||\"\",i);return d[0]+\"?\"+u}function qn(e){let n=(e.match(/^[^:]+(?=:\\/\\/)/gi)||[])[0];const t=typeof n<\"u\"?e.split(\"://\")[1]:e;return n=n===\"wss\"?\"https\":\"http\",[n,t].join(\"://\")}function zn(e,n,t){if(!e[n]||typeof e[n]!==t)throw new Error(`Missing or invalid \"${n}\" param`)}function Ke(e,n=Z){return ke(e.split(_e),n)}function Bn(e){return Ke(e).join(L)}function b(e,n){return e.filter(t=>n.includes(t)).length===e.length}function ke(e,n=Z){return e.slice(Math.max(e.length-n,0))}function Gn(e){return Object.fromEntries(e.entries())}function Yn(e){return new Map(Object.entries(e))}function Wn(e,n){const t={};return Object.keys(e).forEach(r=>{t[r]=n(e[r])}),t}const Jn=e=>e;function Le(e){return e.trim().replace(/^\\w/,n=>n.toUpperCase())}function Qn(e){return e.split(L).map(n=>Le(n)).join(L)}function Zn(e=le,n){const t=q(e||le);let r,o,s;return{resolve:c=>{s&&r&&(clearTimeout(s),r(c))},reject:c=>{s&&o&&(clearTimeout(s),o(c))},done:()=>new Promise((c,d)=>{s=setTimeout(()=>{d(new Error(n))},t),r=c,o=d})}}function Xn(e,n,t){return new Promise(async(r,o)=>{const s=setTimeout(()=>o(new Error(t)),n);try{const c=await e;r(c)}catch(c){o(c)}clearTimeout(s)})}function ne(e,n){if(typeof n==\"string\"&&n.startsWith(`${e}:`))return n;if(e.toLowerCase()===\"topic\"){if(typeof n!=\"string\")throw new Error('Value must be \"string\" for expirer target type: topic');return`topic:${n}`}else if(e.toLowerCase()===\"id\"){if(typeof n!=\"number\")throw new Error('Value must be \"number\" for expirer target type: id');return`id:${n}`}throw new Error(`Unknown expirer target type: ${e}`)}function et(e){return ne(\"topic\",e)}function nt(e){return ne(\"id\",e)}function tt(e){const[n,t]=e.split(\":\"),r={id:void 0,topic:void 0};if(n===\"topic\"&&typeof t==\"string\")r.topic=t;else if(n===\"id\"&&Number.isInteger(Number(t)))r.id=Number(t);else throw new Error(`Invalid target, expected id:number or topic:string, got ${n}:${t}`);return r}function rt(e,n){return yn((n||Date.now())+q(e))}function ot(e){return Date.now()>=q(e)}function st(e,n){return`${e}${n?`:${n}`:\"\"}`}function O(e=[],n=[]){return[...new Set([...e,...n])]}const xe=\"irn\";function it(e){return e?.relay||{protocol:xe}}function ct(e){const n=vn[e];if(typeof n>\"u\")throw new Error(`Relay Protocol not supported: ${e}`);return n}var at=Object.defineProperty,Fe=Object.getOwnPropertySymbols,ut=Object.prototype.hasOwnProperty,dt=Object.prototype.propertyIsEnumerable,He=(e,n,t)=>n in e?at(e,n,{enumerable:!0,configurable:!0,writable:!0,value:t}):e[n]=t,lt=(e,n)=>{for(var t in n||(n={}))ut.call(n,t)&&He(e,t,n[t]);if(Fe)for(var t of Fe(n))dt.call(n,t)&&He(e,t,n[t]);return e};function qe(e,n=\"-\"){const t={},r=\"relay\"+n;return Object.keys(e).forEach(o=>{if(o.startsWith(r)){const s=o.replace(r,\"\"),c=e[o];t[s]=c}}),t}function ft(e){const n=e.indexOf(\":\"),t=e.indexOf(\"?\")!==-1?e.indexOf(\"?\"):void 0,r=e.substring(0,n),o=e.substring(n+1,t).split(\"@\"),s=typeof t<\"u\"?e.substring(t):\"\",c=$.parse(s);return{protocol:r,topic:o[0],version:parseInt(o[1],10),symKey:c.symKey,relay:qe(c)}}function ze(e,n=\"-\"){const t=\"relay\",r={};return Object.keys(e).forEach(o=>{const s=t+n+o;e[o]&&(r[s]=e[o])}),r}function pt(e){return`${e.protocol}:${e.topic}@${e.version}?`+$.stringify(lt({symKey:e.symKey},ze(e.relay)))}var mt=Object.defineProperty,yt=Object.defineProperties,Et=Object.getOwnPropertyDescriptors,Be=Object.getOwnPropertySymbols,ht=Object.prototype.hasOwnProperty,vt=Object.prototype.propertyIsEnumerable,Ge=(e,n,t)=>n in e?mt(e,n,{enumerable:!0,configurable:!0,writable:!0,value:t}):e[n]=t,gt=(e,n)=>{for(var t in n||(n={}))ht.call(n,t)&&Ge(e,t,n[t]);if(Be)for(var t of Be(n))vt.call(n,t)&&Ge(e,t,n[t]);return e},Nt=(e,n)=>yt(e,Et(n));function T(e){const n=[];return e.forEach(t=>{const[r,o]=t.split(\":\");n.push(`${r}:${o}`)}),n}function Ye(e){const n=[];return Object.values(e).forEach(t=>{n.push(...T(t.accounts))}),n}function We(e,n){const t=[];return Object.values(e).forEach(r=>{T(r.accounts).includes(n)&&t.push(...r.methods)}),t}function Je(e,n){const t=[];return Object.values(e).forEach(r=>{T(r.accounts).includes(n)&&t.push(...r.events)}),t}function bt(e,n){const t=on(e,n);if(t)throw new Error(t.message);const r={};for(const[o,s]of Object.entries(e))r[o]={methods:s.methods,events:s.events,chains:s.accounts.map(c=>`${c.split(\":\")[0]}:${c.split(\":\")[1]}`)};return r}function Ot(e){const{proposal:{requiredNamespaces:n,optionalNamespaces:t={}},supportedNamespaces:r}=e,o=re(n),s=re(t),c={};Object.keys(r).forEach(i=>{const u=r[i].chains,a=r[i].methods,g=r[i].events,A=r[i].accounts;c[i]={chains:u,methods:a,events:g,accounts:A}});const d=cn(n,c,\"approve()\");if(d)throw new Error(d.message);const l={};return Object.keys(o).forEach(i=>{const u=r[i].chains.filter(v=>{var p,y;return(y=(p=o[i])==null?void 0:p.chains)==null?void 0:y.includes(v)}),a=r[i].methods.filter(v=>{var p,y;return(y=(p=o[i])==null?void 0:p.methods)==null?void 0:y.includes(v)}),g=r[i].events.filter(v=>{var p,y;return(y=(p=o[i])==null?void 0:p.events)==null?void 0:y.includes(v)}),A=u.map(v=>r[i].accounts.filter(p=>p.includes(v))).flat();l[i]={chains:u,methods:a,events:g,accounts:A}}),Object.keys(s).forEach(i=>{var u,a,g,A,v,p;if(!r[i])return;const y=(a=(u=s[i])==null?void 0:u.chains)==null?void 0:a.filter(I=>r[i].chains.includes(I)),un=r[i].methods.filter(I=>{var P,w;return(w=(P=s[i])==null?void 0:P.methods)==null?void 0:w.includes(I)}),dn=r[i].events.filter(I=>{var P,w;return(w=(P=s[i])==null?void 0:P.events)==null?void 0:w.includes(I)}),ln=y?.map(I=>r[i].accounts.filter(P=>P.includes(I))).flat();l[i]={chains:O((g=l[i])==null?void 0:g.chains,y),methods:O((A=l[i])==null?void 0:A.methods,un),events:O((v=l[i])==null?void 0:v.events,dn),accounts:O((p=l[i])==null?void 0:p.accounts,ln)}}),l}function te(e){return e.includes(\":\")}function Qe(e){return te(e)?e.split(\":\")[0]:e}function re(e){var n,t,r;const o={};if(!x(e))return o;for(const[s,c]of Object.entries(e)){const d=te(s)?[s]:c.chains,l=c.methods||[],i=c.events||[],u=Qe(s);o[u]=Nt(gt({},o[u]),{chains:O(d,(n=o[u])==null?void 0:n.chains),methods:O(l,(t=o[u])==null?void 0:t.methods),events:O(i,(r=o[u])==null?void 0:r.events)})}return o}const St={INVALID_METHOD:{message:\"Invalid method.\",code:1001},INVALID_EVENT:{message:\"Invalid event.\",code:1002},INVALID_UPDATE_REQUEST:{message:\"Invalid update request.\",code:1003},INVALID_EXTEND_REQUEST:{message:\"Invalid extend request.\",code:1004},INVALID_SESSION_SETTLE_REQUEST:{message:\"Invalid session settle request.\",code:1005},UNAUTHORIZED_METHOD:{message:\"Unauthorized method.\",code:3001},UNAUTHORIZED_EVENT:{message:\"Unauthorized event.\",code:3002},UNAUTHORIZED_UPDATE_REQUEST:{message:\"Unauthorized update request.\",code:3003},UNAUTHORIZED_EXTEND_REQUEST:{message:\"Unauthorized extend request.\",code:3004},USER_REJECTED:{message:\"User rejected.\",code:5e3},USER_REJECTED_CHAINS:{message:\"User rejected chains.\",code:5001},USER_REJECTED_METHODS:{message:\"User rejected methods.\",code:5002},USER_REJECTED_EVENTS:{message:\"User rejected events.\",code:5003},UNSUPPORTED_CHAINS:{message:\"Unsupported chains.\",code:5100},UNSUPPORTED_METHODS:{message:\"Unsupported methods.\",code:5101},UNSUPPORTED_EVENTS:{message:\"Unsupported events.\",code:5102},UNSUPPORTED_ACCOUNTS:{message:\"Unsupported accounts.\",code:5103},UNSUPPORTED_NAMESPACE_KEY:{message:\"Unsupported namespace key.\",code:5104},USER_DISCONNECTED:{message:\"User disconnected.\",code:6e3},SESSION_SETTLEMENT_FAILED:{message:\"Session settlement failed.\",code:7e3},WC_METHOD_UNSUPPORTED:{message:\"Unsupported wc_ method.\",code:10001}},It={NOT_INITIALIZED:{message:\"Not initialized.\",code:1},NO_MATCHING_KEY:{message:\"No matching key.\",code:2},RESTORE_WILL_OVERRIDE:{message:\"Restore will override.\",code:3},RESUBSCRIBED:{message:\"Resubscribed.\",code:4},MISSING_OR_INVALID:{message:\"Missing or invalid.\",code:5},EXPIRED:{message:\"Expired.\",code:6},UNKNOWN_TYPE:{message:\"Unknown type.\",code:7},MISMATCHED_TOPIC:{message:\"Mismatched topic.\",code:8},NON_CONFORMING_NAMESPACES:{message:\"Non conforming namespaces.\",code:9}};function N(e,n){const{message:t,code:r}=It[e];return{message:n?`${t} ${n}`:t,code:r}}function R(e,n){const{message:t,code:r}=St[e];return{message:n?`${t} ${n}`:t,code:r}}function C(e,n){return Array.isArray(e)?typeof n<\"u\"&&e.length?e.every(n):!0:!1}function x(e){return Object.getPrototypeOf(e)===Object.prototype&&Object.keys(e).length}function S(e){return typeof e>\"u\"}function m(e,n){return n&&S(e)?!0:typeof e==\"string\"&&Boolean(e.trim().length)}function F(e,n){return n&&S(e)?!0:typeof e==\"number\"&&!isNaN(e)}function Pt(e,n){const{requiredNamespaces:t}=n,r=Object.keys(e.namespaces),o=Object.keys(t);let s=!0;return b(o,r)?(r.forEach(c=>{const{accounts:d,methods:l,events:i}=e.namespaces[c],u=T(d),a=t[c];(!b(V(c,a),u)||!b(a.methods,l)||!b(a.events,i))&&(s=!1)}),s):!1}function H(e){return m(e,!1)&&e.includes(\":\")?e.split(\":\").length===2:!1}function Ze(e){if(m(e,!1)&&e.includes(\":\")){const n=e.split(\":\");if(n.length===3){const t=n[0]+\":\"+n[1];return!!n[2]&&H(t)}}return!1}function Tt(e){if(m(e,!1))try{return typeof new URL(e)<\"u\"}catch{return!1}return!1}function Rt(e){var n;return(n=e?.proposer)==null?void 0:n.publicKey}function At(e){return e?.topic}function Ut(e,n){let t=null;return m(e?.publicKey,!1)||(t=N(\"MISSING_OR_INVALID\",`${n} controller public key should be a string`)),t}function oe(e){let n=!0;return C(e)?e.length&&(n=e.every(t=>m(t,!1))):n=!1,n}function Xe(e,n,t){let r=null;return C(n)?n.forEach(o=>{r||(!H(o)||!o.includes(e))&&(r=R(\"UNSUPPORTED_CHAINS\",`${t}, chain ${o} should be a string and conform to \"namespace:chainId\" format`))}):r=R(\"UNSUPPORTED_CHAINS\",`${t}, chains ${n} should be an array of strings conforming to \"namespace:chainId\" format`),r}function en(e,n){let t=null;return Object.entries(e).forEach(([r,o])=>{if(t)return;const s=Xe(r,V(r,o),`${n} requiredNamespace`);s&&(t=s)}),t}function nn(e,n){let t=null;return C(e)?e.forEach(r=>{t||Ze(r)||(t=R(\"UNSUPPORTED_ACCOUNTS\",`${n}, account ${r} should be a string and conform to \"namespace:chainId:address\" format`))}):t=R(\"UNSUPPORTED_ACCOUNTS\",`${n}, accounts should be an array of strings conforming to \"namespace:chainId:address\" format`),t}function tn(e,n){let t=null;return Object.values(e).forEach(r=>{if(t)return;const o=nn(r?.accounts,`${n} namespace`);o&&(t=o)}),t}function rn(e,n){let t=null;return oe(e?.methods)?oe(e?.events)||(t=R(\"UNSUPPORTED_EVENTS\",`${n}, events should be an array of strings or empty array for no events`)):t=R(\"UNSUPPORTED_METHODS\",`${n}, methods should be an array of strings or empty array for no methods`),t}function se(e,n){let t=null;return Object.values(e).forEach(r=>{if(t)return;const o=rn(r,`${n}, namespace`);o&&(t=o)}),t}function _t(e,n,t){let r=null;if(e&&x(e)){const o=se(e,n);o&&(r=o);const s=en(e,n);s&&(r=s)}else r=N(\"MISSING_OR_INVALID\",`${n}, ${t} should be an object with data`);return r}function on(e,n){let t=null;if(e&&x(e)){const r=se(e,n);r&&(t=r);const o=tn(e,n);o&&(t=o)}else t=N(\"MISSING_OR_INVALID\",`${n}, namespaces should be an object with data`);return t}function sn(e){return m(e.protocol,!0)}function wt(e,n){let t=!1;return n&&!e?t=!0:e&&C(e)&&e.length&&e.forEach(r=>{t=sn(r)}),t}function jt(e){return typeof e==\"number\"}function Ct(e){return typeof e<\"u\"&&typeof e!==null}function $t(e){return!(!e||typeof e!=\"object\"||!e.code||!F(e.code,!1)||!e.message||!m(e.message,!1))}function Dt(e){return!(S(e)||!m(e.method,!1))}function Vt(e){return!(S(e)||S(e.result)&&S(e.error)||!F(e.id,!1)||!m(e.jsonrpc,!1))}function Mt(e){return!(S(e)||!m(e.name,!1))}function Kt(e,n){return!(!H(n)||!Ye(e).includes(n))}function kt(e,n,t){return m(t,!1)?We(e,n).includes(t):!1}function Lt(e,n,t){return m(t,!1)?Je(e,n).includes(t):!1}function cn(e,n,t){let r=null;const o=xt(e),s=Ft(n),c=Object.keys(o),d=Object.keys(s),l=an(Object.keys(e)),i=an(Object.keys(n)),u=l.filter(a=>!i.includes(a));return u.length&&(r=N(\"NON_CONFORMING_NAMESPACES\",`${t} namespaces keys don't satisfy requiredNamespaces.\n      Required: ${u.toString()}\n      Received: ${Object.keys(n).toString()}`)),b(c,d)||(r=N(\"NON_CONFORMING_NAMESPACES\",`${t} namespaces chains don't satisfy required namespaces.\n      Required: ${c.toString()}\n      Approved: ${d.toString()}`)),Object.keys(n).forEach(a=>{if(!a.includes(\":\")||r)return;const g=T(n[a].accounts);g.includes(a)||(r=N(\"NON_CONFORMING_NAMESPACES\",`${t} namespaces accounts don't satisfy namespace accounts for ${a}\n        Required: ${a}\n        Approved: ${g.toString()}`))}),c.forEach(a=>{r||(b(o[a].methods,s[a].methods)?b(o[a].events,s[a].events)||(r=N(\"NON_CONFORMING_NAMESPACES\",`${t} namespaces events don't satisfy namespace events for ${a}`)):r=N(\"NON_CONFORMING_NAMESPACES\",`${t} namespaces methods don't satisfy namespace methods for ${a}`))}),r}function xt(e){const n={};return Object.keys(e).forEach(t=>{var r;t.includes(\":\")?n[t]=e[t]:(r=e[t].chains)==null||r.forEach(o=>{n[o]={methods:e[t].methods,events:e[t].events}})}),n}function an(e){return[...new Set(e.map(n=>n.includes(\":\")?n.split(\":\")[0]:n))]}function Ft(e){const n={};return Object.keys(e).forEach(t=>{if(t.includes(\":\"))n[t]=e[t];else{const r=T(e[t].accounts);r?.forEach(o=>{n[o]={accounts:e[t].accounts.filter(s=>s.includes(`${o}:`)),methods:e[t].methods,events:e[t].events}})}}),n}function Ht(e,n){return F(e,!1)&&e<=n.max&&e>=n.min}export{G as BASE10,f as BASE16,K as BASE64,kn as COLON,Z as DEFAULT_DEPTH,L as EMPTY_SPACE,_ as ENV_MAP,Ln as ONE_THOUSAND,Ue as REACT_NATIVE_PRODUCT,xe as RELAYER_DEFAULT_PROTOCOL,we as SDK_TYPE,_e as SLASH,Y as TYPE_0,U as TYPE_1,k as UTF8,$e as appendToQueryString,zn as assertType,Ot as buildApprovedNamespaces,rt as calcExpiry,Qn as capitalize,Le as capitalizeWord,Zn as createDelayedPromise,Xn as createExpiringPromise,j as decodeTypeByte,Cn as decrypt,Un as deriveSymKey,Q as deserialize,Se as encodeTypeByte,jn as encrypt,st as engineEvent,Jn as enumify,Ee as formatAccountId,gn as formatAccountWithChain,ye as formatChainId,ne as formatExpirerTarget,nt as formatIdTarget,Pn as formatMessage,Bn as formatMessageContext,ze as formatRelayParams,Hn as formatRelayRpcUrl,et as formatTopicTarget,Me as formatUA,pt as formatUri,Rn as generateKeyPair,An as generateRandomBytes32,T as getAccountsChains,bn as getAccountsFromNamespaces,he as getAddressFromAccount,Nn as getAddressesFromAccounts,xn as getAppMetadata,ve as getChainFromAccount,ge as getChainsFromAccounts,V as getChainsFromNamespace,On as getChainsFromNamespaces,Sn as getChainsFromRequiredNamespaces,be as getDidAddress,M as getDidAddressSegments,Ne as getDidChainId,ee as getEnvironment,qn as getHttpUrl,N as getInternalError,Ve as getJavascriptID,De as getJavascriptOS,ke as getLastItems,In as getNamespacedDidChainId,Ye as getNamespacesChains,Je as getNamespacesEventsForChainId,We as getNamespacesMethodsForChainId,Fn as getRelayClientMetadata,ct as getRelayProtocolApi,it as getRelayProtocolName,bt as getRequiredNamespacesFromNamespaces,R as getSdkError,B as getUniqueValues,b as hasOverlap,_n as hashKey,wn as hashMessage,Ce as isBrowser,te as isCaipNamespace,cn as isConformingNamespaces,ot as isExpired,X as isNode,Rt as isProposalStruct,je as isReactNative,Pt as isSessionCompatible,At as isSessionStruct,Dn as isTypeOneEnvelope,S as isUndefined,Ze as isValidAccountId,nn as isValidAccounts,rn as isValidActions,C as isValidArray,H as isValidChainId,Xe as isValidChains,Ut as isValidController,$t as isValidErrorReason,Mt as isValidEvent,jt as isValidId,tn as isValidNamespaceAccounts,se as isValidNamespaceActions,en as isValidNamespaceChains,oe as isValidNamespaceMethodsOrEvents,on as isValidNamespaces,Kt as isValidNamespacesChainId,Lt as isValidNamespacesEvent,kt as isValidNamespacesRequest,F as isValidNumber,x as isValidObject,Ct as isValidParams,sn as isValidRelay,wt as isValidRelays,Dt as isValidRequest,Ht as isValidRequestExpiry,_t as isValidRequiredNamespaces,Vt as isValidResponse,m as isValidString,Tt as isValidUrl,Wn as mapEntries,Gn as mapToObj,O as mergeArrays,re as normalizeNamespaces,Yn as objToMap,z as parseAccountId,me as parseChainId,Ke as parseContextNames,tt as parseExpirerTarget,Qe as parseNamespaceKey,qe as parseRelayParams,ft as parseUri,Ie as serialize,$n as validateDecoding,Pe as validateEncoding};\n//# sourceMappingURL=index.es.js.map\n"]},"metadata":{},"sourceType":"module"}