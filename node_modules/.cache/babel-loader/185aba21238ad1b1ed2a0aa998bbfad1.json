{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Address = void 0;\n\nconst account_1 = require(\"./account\");\n\nconst bytes_1 = require(\"./bytes\");\n/**\n * Handling and generating Ethereum addresses\n */\n\n\nclass Address {\n  constructor(buf) {\n    if (buf.length !== 20) {\n      throw new Error('Invalid address length');\n    }\n\n    this.buf = buf;\n  }\n  /**\n   * Returns the zero address.\n   */\n\n\n  static zero() {\n    return new Address((0, bytes_1.zeros)(20));\n  }\n  /**\n   * Returns an Address object from a hex-encoded string.\n   * @param str - Hex-encoded address\n   */\n\n\n  static fromString(str) {\n    if (!(0, account_1.isValidAddress)(str)) {\n      throw new Error('Invalid address');\n    }\n\n    return new Address((0, bytes_1.toBuffer)(str));\n  }\n  /**\n   * Returns an address for a given public key.\n   * @param pubKey The two points of an uncompressed key\n   */\n\n\n  static fromPublicKey(pubKey) {\n    if (!Buffer.isBuffer(pubKey)) {\n      throw new Error('Public key should be Buffer');\n    }\n\n    const buf = (0, account_1.pubToAddress)(pubKey);\n    return new Address(buf);\n  }\n  /**\n   * Returns an address for a given private key.\n   * @param privateKey A private key must be 256 bits wide\n   */\n\n\n  static fromPrivateKey(privateKey) {\n    if (!Buffer.isBuffer(privateKey)) {\n      throw new Error('Private key should be Buffer');\n    }\n\n    const buf = (0, account_1.privateToAddress)(privateKey);\n    return new Address(buf);\n  }\n  /**\n   * Generates an address for a newly created contract.\n   * @param from The address which is creating this new address\n   * @param nonce The nonce of the from account\n   */\n\n\n  static generate(from, nonce) {\n    if (typeof nonce !== 'bigint') {\n      throw new Error('Expected nonce to be a bigint');\n    }\n\n    return new Address((0, account_1.generateAddress)(from.buf, (0, bytes_1.bigIntToBuffer)(nonce)));\n  }\n  /**\n   * Generates an address for a contract created using CREATE2.\n   * @param from The address which is creating this new address\n   * @param salt A salt\n   * @param initCode The init code of the contract being created\n   */\n\n\n  static generate2(from, salt, initCode) {\n    if (!Buffer.isBuffer(salt)) {\n      throw new Error('Expected salt to be a Buffer');\n    }\n\n    if (!Buffer.isBuffer(initCode)) {\n      throw new Error('Expected initCode to be a Buffer');\n    }\n\n    return new Address((0, account_1.generateAddress2)(from.buf, salt, initCode));\n  }\n  /**\n   * Is address equal to another.\n   */\n\n\n  equals(address) {\n    return this.buf.equals(address.buf);\n  }\n  /**\n   * Is address zero.\n   */\n\n\n  isZero() {\n    return this.equals(Address.zero());\n  }\n  /**\n   * True if address is in the address range defined\n   * by EIP-1352\n   */\n\n\n  isPrecompileOrSystemAddress() {\n    const address = (0, bytes_1.bufferToBigInt)(this.buf);\n    const rangeMin = BigInt(0);\n    const rangeMax = BigInt('0xffff');\n    return address >= rangeMin && address <= rangeMax;\n  }\n  /**\n   * Returns hex encoding of address.\n   */\n\n\n  toString() {\n    return '0x' + this.buf.toString('hex');\n  }\n  /**\n   * Returns Buffer representation of address.\n   */\n\n\n  toBuffer() {\n    return Buffer.from(this.buf);\n  }\n\n}\n\nexports.Address = Address;","map":{"version":3,"sources":["../src/address.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Address = void 0;\nconst account_1 = require(\"./account\");\nconst bytes_1 = require(\"./bytes\");\n/**\n * Handling and generating Ethereum addresses\n */\nclass Address {\n    constructor(buf) {\n        if (buf.length !== 20) {\n            throw new Error('Invalid address length');\n        }\n        this.buf = buf;\n    }\n    /**\n     * Returns the zero address.\n     */\n    static zero() {\n        return new Address((0, bytes_1.zeros)(20));\n    }\n    /**\n     * Returns an Address object from a hex-encoded string.\n     * @param str - Hex-encoded address\n     */\n    static fromString(str) {\n        if (!(0, account_1.isValidAddress)(str)) {\n            throw new Error('Invalid address');\n        }\n        return new Address((0, bytes_1.toBuffer)(str));\n    }\n    /**\n     * Returns an address for a given public key.\n     * @param pubKey The two points of an uncompressed key\n     */\n    static fromPublicKey(pubKey) {\n        if (!Buffer.isBuffer(pubKey)) {\n            throw new Error('Public key should be Buffer');\n        }\n        const buf = (0, account_1.pubToAddress)(pubKey);\n        return new Address(buf);\n    }\n    /**\n     * Returns an address for a given private key.\n     * @param privateKey A private key must be 256 bits wide\n     */\n    static fromPrivateKey(privateKey) {\n        if (!Buffer.isBuffer(privateKey)) {\n            throw new Error('Private key should be Buffer');\n        }\n        const buf = (0, account_1.privateToAddress)(privateKey);\n        return new Address(buf);\n    }\n    /**\n     * Generates an address for a newly created contract.\n     * @param from The address which is creating this new address\n     * @param nonce The nonce of the from account\n     */\n    static generate(from, nonce) {\n        if (typeof nonce !== 'bigint') {\n            throw new Error('Expected nonce to be a bigint');\n        }\n        return new Address((0, account_1.generateAddress)(from.buf, (0, bytes_1.bigIntToBuffer)(nonce)));\n    }\n    /**\n     * Generates an address for a contract created using CREATE2.\n     * @param from The address which is creating this new address\n     * @param salt A salt\n     * @param initCode The init code of the contract being created\n     */\n    static generate2(from, salt, initCode) {\n        if (!Buffer.isBuffer(salt)) {\n            throw new Error('Expected salt to be a Buffer');\n        }\n        if (!Buffer.isBuffer(initCode)) {\n            throw new Error('Expected initCode to be a Buffer');\n        }\n        return new Address((0, account_1.generateAddress2)(from.buf, salt, initCode));\n    }\n    /**\n     * Is address equal to another.\n     */\n    equals(address) {\n        return this.buf.equals(address.buf);\n    }\n    /**\n     * Is address zero.\n     */\n    isZero() {\n        return this.equals(Address.zero());\n    }\n    /**\n     * True if address is in the address range defined\n     * by EIP-1352\n     */\n    isPrecompileOrSystemAddress() {\n        const address = (0, bytes_1.bufferToBigInt)(this.buf);\n        const rangeMin = BigInt(0);\n        const rangeMax = BigInt('0xffff');\n        return address >= rangeMin && address <= rangeMax;\n    }\n    /**\n     * Returns hex encoding of address.\n     */\n    toString() {\n        return '0x' + this.buf.toString('hex');\n    }\n    /**\n     * Returns Buffer representation of address.\n     */\n    toBuffer() {\n        return Buffer.from(this.buf);\n    }\n}\nexports.Address = Address;\n//# sourceMappingURL=address.js.map"]},"metadata":{},"sourceType":"script"}