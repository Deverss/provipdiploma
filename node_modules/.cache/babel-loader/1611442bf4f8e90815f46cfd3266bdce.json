{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ContainerNodeStructType = void 0;\n\nconst composite_1 = require(\"./composite\");\n\nconst container_1 = require(\"./container\");\n\nconst named_1 = require(\"../util/named\");\n\nconst containerNodeStruct_1 = require(\"../view/containerNodeStruct\");\n\nconst containerNodeStruct_2 = require(\"../viewDU/containerNodeStruct\");\n\nconst branchNodeStruct_1 = require(\"../branchNodeStruct\");\n/**\n * ContainerNodeStruct: ordered heterogeneous collection of values.\n * - Notation: Custom name per instance\n *\n * A ContainerNodeStruct is identical to a Container type except that it represents tree data with a custom\n * BranchNodeStruct node. This special branch node represents the data of its entire sub tree as a value, instead\n * of a tree of nodes. This approach is a tradeoff:\n *\n * - More memory efficient\n * - Faster reads, since it doesn't require parsing merkleized data\n * - Slower hashing, since it has to merkleize the entire value everytime and has not intermediary hashing cache\n *\n * This tradeoff is good for data that is read often, written rarely, and consumes a lot of memory (i.e. Validator)\n */\n\n\nclass ContainerNodeStructType extends container_1.ContainerType {\n  constructor(fields, opts) {\n    super(fields, {\n      // Overwrite default \"Container\" typeName\n      // Render detailed typeName. Consumers should overwrite since it can get long\n      typeName: (opts === null || opts === void 0 ? void 0 : opts.typeName) ?? container_1.renderContainerTypeName(fields, \"ContainerNodeStruct\"),\n      ...opts,\n      getContainerTreeViewClass: containerNodeStruct_1.getContainerTreeViewClass,\n      getContainerTreeViewDUClass: containerNodeStruct_2.getContainerTreeViewDUClass\n    });\n    this.fields = fields; // ContainerNodeStructType TreeViews don't handle recursive mutable TreeViews like ContainerType does.\n    // Using ContainerNodeStructType for fields that have mutable views (like a ListBasic), will result in\n    // unnexpected behaviour if those child views are mutated.\n    //\n    // For example, this example below won't persist the pushed values to the list:\n    // ```ts\n    // const type = ContainerNodeStructType({a: new ListBasicType(byteType, 1)});\n    // const view = type.defaultViewDU();\n    // view.a.push(0)\n    // ```\n    // because the ListBasicViewDU in view.a will never propagate the changes upwards to its ContainerNodeStructType.\n\n    for (const {\n      fieldName,\n      fieldType\n    } of this.fieldsEntries) {\n      if (composite_1.isCompositeType(fieldType) && fieldType.isViewMutable) {\n        throw Error(`ContainerNodeStructType field '${fieldName}' ${fieldType.typeName} view is mutable`);\n      }\n    }\n  }\n\n  static named(fields, opts) {\n    return new (named_1.namedClass(container_1.ContainerType, opts.typeName))(fields, opts);\n  }\n\n  tree_serializedSize(node) {\n    return this.value_serializedSize(node.value);\n  }\n\n  tree_serializeToBytes(output, offset, node) {\n    const {\n      value\n    } = node;\n    return this.value_serializeToBytes(output, offset, value);\n  }\n\n  tree_deserializeFromBytes(data, start, end) {\n    const value = this.value_deserializeFromBytes(data, start, end);\n    return new branchNodeStruct_1.BranchNodeStruct(this.valueToTree.bind(this), value);\n  } // Proofs\n  // ContainerNodeStructType can only parse proofs that contain all the data.\n  // TODO: Support converting a partial tree to a partial value\n\n\n  getPropertyGindex() {\n    return null;\n  } // Post process tree to convert regular BranchNode to BranchNodeStruct\n  // TODO: Optimize conversions\n\n\n  tree_fromProofNode(node) {\n    // TODO: Figure out from `node` alone if it contains complete data.\n    // Otherwise throw a nice error \"ContainerNodeStruct type requires proofs for all its data\"\n    const uint8Array = new Uint8Array(super.tree_serializedSize(node));\n    const dataView = new DataView(uint8Array.buffer, uint8Array.byteOffset, uint8Array.byteLength);\n    super.tree_serializeToBytes({\n      uint8Array,\n      dataView\n    }, 0, node);\n    const value = this.value_deserializeFromBytes({\n      uint8Array,\n      dataView\n    }, 0, uint8Array.length);\n    return {\n      node: new branchNodeStruct_1.BranchNodeStruct(this.valueToTree.bind(this), value),\n      done: true\n    };\n  } // Overwrites for fast conversion node <-> value\n\n\n  tree_toValue(node) {\n    return node.value;\n  }\n\n  value_toTree(value) {\n    return new branchNodeStruct_1.BranchNodeStruct(this.valueToTree.bind(this), value);\n  } // TODO: Optimize conversion\n\n\n  valueToTree(value) {\n    const uint8Array = new Uint8Array(this.value_serializedSize(value));\n    const dataView = new DataView(uint8Array.buffer, uint8Array.byteOffset, uint8Array.byteLength);\n    this.value_serializeToBytes({\n      uint8Array,\n      dataView\n    }, 0, value);\n    return super.tree_deserializeFromBytes({\n      uint8Array,\n      dataView\n    }, 0, uint8Array.length);\n  }\n\n}\n\nexports.ContainerNodeStructType = ContainerNodeStructType;","map":{"version":3,"sources":["../../src/type/containerNodeStruct.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ContainerNodeStructType = void 0;\nconst composite_1 = require(\"./composite\");\nconst container_1 = require(\"./container\");\nconst named_1 = require(\"../util/named\");\nconst containerNodeStruct_1 = require(\"../view/containerNodeStruct\");\nconst containerNodeStruct_2 = require(\"../viewDU/containerNodeStruct\");\nconst branchNodeStruct_1 = require(\"../branchNodeStruct\");\n/**\n * ContainerNodeStruct: ordered heterogeneous collection of values.\n * - Notation: Custom name per instance\n *\n * A ContainerNodeStruct is identical to a Container type except that it represents tree data with a custom\n * BranchNodeStruct node. This special branch node represents the data of its entire sub tree as a value, instead\n * of a tree of nodes. This approach is a tradeoff:\n *\n * - More memory efficient\n * - Faster reads, since it doesn't require parsing merkleized data\n * - Slower hashing, since it has to merkleize the entire value everytime and has not intermediary hashing cache\n *\n * This tradeoff is good for data that is read often, written rarely, and consumes a lot of memory (i.e. Validator)\n */\nclass ContainerNodeStructType extends container_1.ContainerType {\n    constructor(fields, opts) {\n        super(fields, {\n            // Overwrite default \"Container\" typeName\n            // Render detailed typeName. Consumers should overwrite since it can get long\n            typeName: opts?.typeName ?? container_1.renderContainerTypeName(fields, \"ContainerNodeStruct\"),\n            ...opts,\n            getContainerTreeViewClass: containerNodeStruct_1.getContainerTreeViewClass,\n            getContainerTreeViewDUClass: containerNodeStruct_2.getContainerTreeViewDUClass,\n        });\n        this.fields = fields;\n        // ContainerNodeStructType TreeViews don't handle recursive mutable TreeViews like ContainerType does.\n        // Using ContainerNodeStructType for fields that have mutable views (like a ListBasic), will result in\n        // unnexpected behaviour if those child views are mutated.\n        //\n        // For example, this example below won't persist the pushed values to the list:\n        // ```ts\n        // const type = ContainerNodeStructType({a: new ListBasicType(byteType, 1)});\n        // const view = type.defaultViewDU();\n        // view.a.push(0)\n        // ```\n        // because the ListBasicViewDU in view.a will never propagate the changes upwards to its ContainerNodeStructType.\n        for (const { fieldName, fieldType } of this.fieldsEntries) {\n            if (composite_1.isCompositeType(fieldType) && fieldType.isViewMutable) {\n                throw Error(`ContainerNodeStructType field '${fieldName}' ${fieldType.typeName} view is mutable`);\n            }\n        }\n    }\n    static named(fields, opts) {\n        return new (named_1.namedClass(container_1.ContainerType, opts.typeName))(fields, opts);\n    }\n    tree_serializedSize(node) {\n        return this.value_serializedSize(node.value);\n    }\n    tree_serializeToBytes(output, offset, node) {\n        const { value } = node;\n        return this.value_serializeToBytes(output, offset, value);\n    }\n    tree_deserializeFromBytes(data, start, end) {\n        const value = this.value_deserializeFromBytes(data, start, end);\n        return new branchNodeStruct_1.BranchNodeStruct(this.valueToTree.bind(this), value);\n    }\n    // Proofs\n    // ContainerNodeStructType can only parse proofs that contain all the data.\n    // TODO: Support converting a partial tree to a partial value\n    getPropertyGindex() {\n        return null;\n    }\n    // Post process tree to convert regular BranchNode to BranchNodeStruct\n    // TODO: Optimize conversions\n    tree_fromProofNode(node) {\n        // TODO: Figure out from `node` alone if it contains complete data.\n        // Otherwise throw a nice error \"ContainerNodeStruct type requires proofs for all its data\"\n        const uint8Array = new Uint8Array(super.tree_serializedSize(node));\n        const dataView = new DataView(uint8Array.buffer, uint8Array.byteOffset, uint8Array.byteLength);\n        super.tree_serializeToBytes({ uint8Array, dataView }, 0, node);\n        const value = this.value_deserializeFromBytes({ uint8Array, dataView }, 0, uint8Array.length);\n        return {\n            node: new branchNodeStruct_1.BranchNodeStruct(this.valueToTree.bind(this), value),\n            done: true,\n        };\n    }\n    // Overwrites for fast conversion node <-> value\n    tree_toValue(node) {\n        return node.value;\n    }\n    value_toTree(value) {\n        return new branchNodeStruct_1.BranchNodeStruct(this.valueToTree.bind(this), value);\n    }\n    // TODO: Optimize conversion\n    valueToTree(value) {\n        const uint8Array = new Uint8Array(this.value_serializedSize(value));\n        const dataView = new DataView(uint8Array.buffer, uint8Array.byteOffset, uint8Array.byteLength);\n        this.value_serializeToBytes({ uint8Array, dataView }, 0, value);\n        return super.tree_deserializeFromBytes({ uint8Array, dataView }, 0, uint8Array.length);\n    }\n}\nexports.ContainerNodeStructType = ContainerNodeStructType;\n//# sourceMappingURL=containerNodeStruct.js.map"]},"metadata":{},"sourceType":"script"}