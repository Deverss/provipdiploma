{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.subtreeFillToContents = exports.subtreeFillToLength = exports.subtreeFillToDepth = void 0;\n\nconst node_1 = require(\"./node\");\n\nconst zeroNode_1 = require(\"./zeroNode\");\n\nfunction subtreeFillToDepth(bottom, depth) {\n  let node = bottom;\n\n  while (depth > 0) {\n    node = new node_1.BranchNode(node, node);\n    depth--;\n  }\n\n  return node;\n}\n\nexports.subtreeFillToDepth = subtreeFillToDepth;\n\nfunction subtreeFillToLength(bottom, depth, length) {\n  const maxLength = 1 << depth;\n  if (length > maxLength) throw new Error(\"ERR_TOO_MANY_NODES\");\n  if (length === maxLength) return subtreeFillToDepth(bottom, depth);\n\n  if (depth === 0) {\n    if (length === 1) return bottom;else throw new Error(\"ERR_NAVIGATION\");\n  }\n\n  if (depth === 1) {\n    return new node_1.BranchNode(bottom, length > 1 ? bottom : zeroNode_1.zeroNode(0));\n  }\n\n  const pivot = maxLength >> 1;\n\n  if (length <= pivot) {\n    return new node_1.BranchNode(subtreeFillToLength(bottom, depth - 1, length), zeroNode_1.zeroNode(depth - 1));\n  } else {\n    return new node_1.BranchNode(subtreeFillToDepth(bottom, depth - 1), subtreeFillToLength(bottom, depth - 1, length - pivot));\n  }\n}\n\nexports.subtreeFillToLength = subtreeFillToLength;\n/**\n * WARNING: Mutates the provided nodes array.\n * TODO: Don't mutate the nodes array.\n */\n\nfunction subtreeFillToContents(nodes, depth) {\n  const maxLength = 2 ** depth;\n\n  if (nodes.length > maxLength) {\n    throw new Error(`nodes.length ${nodes.length} over maxIndex at depth ${depth}`);\n  }\n\n  if (nodes.length === 0) {\n    return zeroNode_1.zeroNode(depth);\n  }\n\n  if (depth === 0) {\n    return nodes[0];\n  }\n\n  if (depth === 1) {\n    return nodes.length > 1 ? // All nodes at depth 1 available\n    new node_1.BranchNode(nodes[0], nodes[1]) : // Pad with zero node\n    new node_1.BranchNode(nodes[0], zeroNode_1.zeroNode(0));\n  }\n\n  let count = nodes.length;\n\n  for (let d = depth; d > 0; d--) {\n    const countRemainder = count % 2;\n    const countEven = count - countRemainder; // For each depth level compute the new BranchNodes and overwrite the nodes array\n\n    for (let i = 0; i < countEven; i += 2) {\n      nodes[i / 2] = new node_1.BranchNode(nodes[i], nodes[i + 1]);\n    }\n\n    if (countRemainder > 0) {\n      nodes[countEven / 2] = new node_1.BranchNode(nodes[countEven], zeroNode_1.zeroNode(depth - d));\n    } // If there was remainer, 2 nodes are added to the count\n\n\n    count = countEven / 2 + countRemainder;\n  }\n\n  return nodes[0];\n}\n\nexports.subtreeFillToContents = subtreeFillToContents;","map":{"version":3,"sources":["/Users/dev3rs/provipdiploma/node_modules/@chainsafe/persistent-merkle-tree/lib/subtree.js"],"names":["Object","defineProperty","exports","value","subtreeFillToContents","subtreeFillToLength","subtreeFillToDepth","node_1","require","zeroNode_1","bottom","depth","node","BranchNode","length","maxLength","Error","zeroNode","pivot","nodes","count","d","countRemainder","countEven","i"],"mappings":"AAAA;;AACAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;AACAD,OAAO,CAACE,qBAAR,GAAgCF,OAAO,CAACG,mBAAR,GAA8BH,OAAO,CAACI,kBAAR,GAA6B,KAAK,CAAhG;;AACA,MAAMC,MAAM,GAAGC,OAAO,CAAC,QAAD,CAAtB;;AACA,MAAMC,UAAU,GAAGD,OAAO,CAAC,YAAD,CAA1B;;AACA,SAASF,kBAAT,CAA4BI,MAA5B,EAAoCC,KAApC,EAA2C;AACvC,MAAIC,IAAI,GAAGF,MAAX;;AACA,SAAOC,KAAK,GAAG,CAAf,EAAkB;AACdC,IAAAA,IAAI,GAAG,IAAIL,MAAM,CAACM,UAAX,CAAsBD,IAAtB,EAA4BA,IAA5B,CAAP;AACAD,IAAAA,KAAK;AACR;;AACD,SAAOC,IAAP;AACH;;AACDV,OAAO,CAACI,kBAAR,GAA6BA,kBAA7B;;AACA,SAASD,mBAAT,CAA6BK,MAA7B,EAAqCC,KAArC,EAA4CG,MAA5C,EAAoD;AAChD,QAAMC,SAAS,GAAG,KAAKJ,KAAvB;AACA,MAAIG,MAAM,GAAGC,SAAb,EACI,MAAM,IAAIC,KAAJ,CAAU,oBAAV,CAAN;AACJ,MAAIF,MAAM,KAAKC,SAAf,EACI,OAAOT,kBAAkB,CAACI,MAAD,EAASC,KAAT,CAAzB;;AACJ,MAAIA,KAAK,KAAK,CAAd,EAAiB;AACb,QAAIG,MAAM,KAAK,CAAf,EACI,OAAOJ,MAAP,CADJ,KAGI,MAAM,IAAIM,KAAJ,CAAU,gBAAV,CAAN;AACP;;AACD,MAAIL,KAAK,KAAK,CAAd,EAAiB;AACb,WAAO,IAAIJ,MAAM,CAACM,UAAX,CAAsBH,MAAtB,EAA8BI,MAAM,GAAG,CAAT,GAAaJ,MAAb,GAAsBD,UAAU,CAACQ,QAAX,CAAoB,CAApB,CAApD,CAAP;AACH;;AACD,QAAMC,KAAK,GAAGH,SAAS,IAAI,CAA3B;;AACA,MAAID,MAAM,IAAII,KAAd,EAAqB;AACjB,WAAO,IAAIX,MAAM,CAACM,UAAX,CAAsBR,mBAAmB,CAACK,MAAD,EAASC,KAAK,GAAG,CAAjB,EAAoBG,MAApB,CAAzC,EAAsEL,UAAU,CAACQ,QAAX,CAAoBN,KAAK,GAAG,CAA5B,CAAtE,CAAP;AACH,GAFD,MAGK;AACD,WAAO,IAAIJ,MAAM,CAACM,UAAX,CAAsBP,kBAAkB,CAACI,MAAD,EAASC,KAAK,GAAG,CAAjB,CAAxC,EAA6DN,mBAAmB,CAACK,MAAD,EAASC,KAAK,GAAG,CAAjB,EAAoBG,MAAM,GAAGI,KAA7B,CAAhF,CAAP;AACH;AACJ;;AACDhB,OAAO,CAACG,mBAAR,GAA8BA,mBAA9B;AACA;AACA;AACA;AACA;;AACA,SAASD,qBAAT,CAA+Be,KAA/B,EAAsCR,KAAtC,EAA6C;AACzC,QAAMI,SAAS,GAAG,KAAKJ,KAAvB;;AACA,MAAIQ,KAAK,CAACL,MAAN,GAAeC,SAAnB,EAA8B;AAC1B,UAAM,IAAIC,KAAJ,CAAW,gBAAeG,KAAK,CAACL,MAAO,2BAA0BH,KAAM,EAAvE,CAAN;AACH;;AACD,MAAIQ,KAAK,CAACL,MAAN,KAAiB,CAArB,EAAwB;AACpB,WAAOL,UAAU,CAACQ,QAAX,CAAoBN,KAApB,CAAP;AACH;;AACD,MAAIA,KAAK,KAAK,CAAd,EAAiB;AACb,WAAOQ,KAAK,CAAC,CAAD,CAAZ;AACH;;AACD,MAAIR,KAAK,KAAK,CAAd,EAAiB;AACb,WAAOQ,KAAK,CAACL,MAAN,GAAe,CAAf,GACD;AACE,QAAIP,MAAM,CAACM,UAAX,CAAsBM,KAAK,CAAC,CAAD,CAA3B,EAAgCA,KAAK,CAAC,CAAD,CAArC,CAFD,GAGD;AACE,QAAIZ,MAAM,CAACM,UAAX,CAAsBM,KAAK,CAAC,CAAD,CAA3B,EAAgCV,UAAU,CAACQ,QAAX,CAAoB,CAApB,CAAhC,CAJR;AAKH;;AACD,MAAIG,KAAK,GAAGD,KAAK,CAACL,MAAlB;;AACA,OAAK,IAAIO,CAAC,GAAGV,KAAb,EAAoBU,CAAC,GAAG,CAAxB,EAA2BA,CAAC,EAA5B,EAAgC;AAC5B,UAAMC,cAAc,GAAGF,KAAK,GAAG,CAA/B;AACA,UAAMG,SAAS,GAAGH,KAAK,GAAGE,cAA1B,CAF4B,CAG5B;;AACA,SAAK,IAAIE,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGD,SAApB,EAA+BC,CAAC,IAAI,CAApC,EAAuC;AACnCL,MAAAA,KAAK,CAACK,CAAC,GAAG,CAAL,CAAL,GAAe,IAAIjB,MAAM,CAACM,UAAX,CAAsBM,KAAK,CAACK,CAAD,CAA3B,EAAgCL,KAAK,CAACK,CAAC,GAAG,CAAL,CAArC,CAAf;AACH;;AACD,QAAIF,cAAc,GAAG,CAArB,EAAwB;AACpBH,MAAAA,KAAK,CAACI,SAAS,GAAG,CAAb,CAAL,GAAuB,IAAIhB,MAAM,CAACM,UAAX,CAAsBM,KAAK,CAACI,SAAD,CAA3B,EAAwCd,UAAU,CAACQ,QAAX,CAAoBN,KAAK,GAAGU,CAA5B,CAAxC,CAAvB;AACH,KAT2B,CAU5B;;;AACAD,IAAAA,KAAK,GAAGG,SAAS,GAAG,CAAZ,GAAgBD,cAAxB;AACH;;AACD,SAAOH,KAAK,CAAC,CAAD,CAAZ;AACH;;AACDjB,OAAO,CAACE,qBAAR,GAAgCA,qBAAhC","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.subtreeFillToContents = exports.subtreeFillToLength = exports.subtreeFillToDepth = void 0;\nconst node_1 = require(\"./node\");\nconst zeroNode_1 = require(\"./zeroNode\");\nfunction subtreeFillToDepth(bottom, depth) {\n    let node = bottom;\n    while (depth > 0) {\n        node = new node_1.BranchNode(node, node);\n        depth--;\n    }\n    return node;\n}\nexports.subtreeFillToDepth = subtreeFillToDepth;\nfunction subtreeFillToLength(bottom, depth, length) {\n    const maxLength = 1 << depth;\n    if (length > maxLength)\n        throw new Error(\"ERR_TOO_MANY_NODES\");\n    if (length === maxLength)\n        return subtreeFillToDepth(bottom, depth);\n    if (depth === 0) {\n        if (length === 1)\n            return bottom;\n        else\n            throw new Error(\"ERR_NAVIGATION\");\n    }\n    if (depth === 1) {\n        return new node_1.BranchNode(bottom, length > 1 ? bottom : zeroNode_1.zeroNode(0));\n    }\n    const pivot = maxLength >> 1;\n    if (length <= pivot) {\n        return new node_1.BranchNode(subtreeFillToLength(bottom, depth - 1, length), zeroNode_1.zeroNode(depth - 1));\n    }\n    else {\n        return new node_1.BranchNode(subtreeFillToDepth(bottom, depth - 1), subtreeFillToLength(bottom, depth - 1, length - pivot));\n    }\n}\nexports.subtreeFillToLength = subtreeFillToLength;\n/**\n * WARNING: Mutates the provided nodes array.\n * TODO: Don't mutate the nodes array.\n */\nfunction subtreeFillToContents(nodes, depth) {\n    const maxLength = 2 ** depth;\n    if (nodes.length > maxLength) {\n        throw new Error(`nodes.length ${nodes.length} over maxIndex at depth ${depth}`);\n    }\n    if (nodes.length === 0) {\n        return zeroNode_1.zeroNode(depth);\n    }\n    if (depth === 0) {\n        return nodes[0];\n    }\n    if (depth === 1) {\n        return nodes.length > 1\n            ? // All nodes at depth 1 available\n                new node_1.BranchNode(nodes[0], nodes[1])\n            : // Pad with zero node\n                new node_1.BranchNode(nodes[0], zeroNode_1.zeroNode(0));\n    }\n    let count = nodes.length;\n    for (let d = depth; d > 0; d--) {\n        const countRemainder = count % 2;\n        const countEven = count - countRemainder;\n        // For each depth level compute the new BranchNodes and overwrite the nodes array\n        for (let i = 0; i < countEven; i += 2) {\n            nodes[i / 2] = new node_1.BranchNode(nodes[i], nodes[i + 1]);\n        }\n        if (countRemainder > 0) {\n            nodes[countEven / 2] = new node_1.BranchNode(nodes[countEven], zeroNode_1.zeroNode(depth - d));\n        }\n        // If there was remainer, 2 nodes are added to the count\n        count = countEven / 2 + countRemainder;\n    }\n    return nodes[0];\n}\nexports.subtreeFillToContents = subtreeFillToContents;\n"]},"metadata":{},"sourceType":"script"}