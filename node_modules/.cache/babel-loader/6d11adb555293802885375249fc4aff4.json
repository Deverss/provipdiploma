{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.toType = exports.TypeOutput = void 0;\n\nconst bytes_1 = require(\"./bytes\");\n\nconst internal_1 = require(\"./internal\");\n/**\n * Type output options\n */\n\n\nvar TypeOutput;\n\n(function (TypeOutput) {\n  TypeOutput[TypeOutput[\"Number\"] = 0] = \"Number\";\n  TypeOutput[TypeOutput[\"BigInt\"] = 1] = \"BigInt\";\n  TypeOutput[TypeOutput[\"Buffer\"] = 2] = \"Buffer\";\n  TypeOutput[TypeOutput[\"PrefixedHexString\"] = 3] = \"PrefixedHexString\";\n})(TypeOutput = exports.TypeOutput || (exports.TypeOutput = {}));\n\nfunction toType(input, outputType) {\n  if (input === null) {\n    return null;\n  }\n\n  if (input === undefined) {\n    return undefined;\n  }\n\n  if (typeof input === 'string' && !(0, internal_1.isHexString)(input)) {\n    throw new Error(`A string must be provided with a 0x-prefix, given: ${input}`);\n  } else if (typeof input === 'number' && !Number.isSafeInteger(input)) {\n    throw new Error('The provided number is greater than MAX_SAFE_INTEGER (please use an alternative input type)');\n  }\n\n  const output = (0, bytes_1.toBuffer)(input);\n\n  switch (outputType) {\n    case TypeOutput.Buffer:\n      return output;\n\n    case TypeOutput.BigInt:\n      return (0, bytes_1.bufferToBigInt)(output);\n\n    case TypeOutput.Number:\n      {\n        const bigInt = (0, bytes_1.bufferToBigInt)(output);\n\n        if (bigInt > BigInt(Number.MAX_SAFE_INTEGER)) {\n          throw new Error('The provided number is greater than MAX_SAFE_INTEGER (please use an alternative output type)');\n        }\n\n        return Number(bigInt);\n      }\n\n    case TypeOutput.PrefixedHexString:\n      return (0, bytes_1.bufferToHex)(output);\n\n    default:\n      throw new Error('unknown outputType');\n  }\n}\n\nexports.toType = toType;","map":{"version":3,"sources":["../src/types.ts"],"names":[],"mappings":";;;;;;;AAAA,MAAA,OAAA,GAAA,OAAA,CAAA,SAAA,CAAA;;AACA,MAAA,UAAA,GAAA,OAAA,CAAA,YAAA,CAAA;AAmDA;;AAEG;;;AACH,IAAY,UAAZ;;AAAA,CAAA,UAAY,UAAZ,EAAsB;AACpB,EAAA,UAAA,CAAA,UAAA,CAAA,QAAA,CAAA,GAAA,CAAA,CAAA,GAAA,QAAA;AACA,EAAA,UAAA,CAAA,UAAA,CAAA,QAAA,CAAA,GAAA,CAAA,CAAA,GAAA,QAAA;AACA,EAAA,UAAA,CAAA,UAAA,CAAA,QAAA,CAAA,GAAA,CAAA,CAAA,GAAA,QAAA;AACA,EAAA,UAAA,CAAA,UAAA,CAAA,mBAAA,CAAA,GAAA,CAAA,CAAA,GAAA,mBAAA;AACD,CALD,EAAY,UAAU,GAAV,OAAA,CAAA,UAAA,KAAA,OAAA,CAAA,UAAA,GAAU,EAAV,CAAZ;;AA0BA,SAAgB,MAAhB,CACE,KADF,EAEE,UAFF,EAEe;AAEb,MAAI,KAAK,KAAK,IAAd,EAAoB;AAClB,WAAO,IAAP;AACD;;AACD,MAAI,KAAK,KAAK,SAAd,EAAyB;AACvB,WAAO,SAAP;AACD;;AAED,MAAI,OAAO,KAAP,KAAiB,QAAjB,IAA6B,CAAC,CAAA,GAAA,UAAA,CAAA,WAAA,EAAY,KAAZ,CAAlC,EAAsD;AACpD,UAAM,IAAI,KAAJ,CAAU,sDAAsD,KAAK,EAArE,CAAN;AACD,GAFD,MAEO,IAAI,OAAO,KAAP,KAAiB,QAAjB,IAA6B,CAAC,MAAM,CAAC,aAAP,CAAqB,KAArB,CAAlC,EAA+D;AACpE,UAAM,IAAI,KAAJ,CACJ,6FADI,CAAN;AAGD;;AAED,QAAM,MAAM,GAAG,CAAA,GAAA,OAAA,CAAA,QAAA,EAAS,KAAT,CAAf;;AAEA,UAAQ,UAAR;AACE,SAAK,UAAU,CAAC,MAAhB;AACE,aAAO,MAAP;;AACF,SAAK,UAAU,CAAC,MAAhB;AACE,aAAO,CAAA,GAAA,OAAA,CAAA,cAAA,EAAe,MAAf,CAAP;;AACF,SAAK,UAAU,CAAC,MAAhB;AAAwB;AACtB,cAAM,MAAM,GAAG,CAAA,GAAA,OAAA,CAAA,cAAA,EAAe,MAAf,CAAf;;AACA,YAAI,MAAM,GAAG,MAAM,CAAC,MAAM,CAAC,gBAAR,CAAnB,EAA8C;AAC5C,gBAAM,IAAI,KAAJ,CACJ,8FADI,CAAN;AAGD;;AACD,eAAO,MAAM,CAAC,MAAD,CAAb;AACD;;AACD,SAAK,UAAU,CAAC,iBAAhB;AACE,aAAO,CAAA,GAAA,OAAA,CAAA,WAAA,EAAY,MAAZ,CAAP;;AACF;AACE,YAAM,IAAI,KAAJ,CAAU,oBAAV,CAAN;AAjBJ;AAmBD;;AAxCD,OAAA,CAAA,MAAA,GAAA,MAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.toType = exports.TypeOutput = void 0;\nconst bytes_1 = require(\"./bytes\");\nconst internal_1 = require(\"./internal\");\n/**\n * Type output options\n */\nvar TypeOutput;\n(function (TypeOutput) {\n    TypeOutput[TypeOutput[\"Number\"] = 0] = \"Number\";\n    TypeOutput[TypeOutput[\"BigInt\"] = 1] = \"BigInt\";\n    TypeOutput[TypeOutput[\"Buffer\"] = 2] = \"Buffer\";\n    TypeOutput[TypeOutput[\"PrefixedHexString\"] = 3] = \"PrefixedHexString\";\n})(TypeOutput = exports.TypeOutput || (exports.TypeOutput = {}));\nfunction toType(input, outputType) {\n    if (input === null) {\n        return null;\n    }\n    if (input === undefined) {\n        return undefined;\n    }\n    if (typeof input === 'string' && !(0, internal_1.isHexString)(input)) {\n        throw new Error(`A string must be provided with a 0x-prefix, given: ${input}`);\n    }\n    else if (typeof input === 'number' && !Number.isSafeInteger(input)) {\n        throw new Error('The provided number is greater than MAX_SAFE_INTEGER (please use an alternative input type)');\n    }\n    const output = (0, bytes_1.toBuffer)(input);\n    switch (outputType) {\n        case TypeOutput.Buffer:\n            return output;\n        case TypeOutput.BigInt:\n            return (0, bytes_1.bufferToBigInt)(output);\n        case TypeOutput.Number: {\n            const bigInt = (0, bytes_1.bufferToBigInt)(output);\n            if (bigInt > BigInt(Number.MAX_SAFE_INTEGER)) {\n                throw new Error('The provided number is greater than MAX_SAFE_INTEGER (please use an alternative output type)');\n            }\n            return Number(bigInt);\n        }\n        case TypeOutput.PrefixedHexString:\n            return (0, bytes_1.bufferToHex)(output);\n        default:\n            throw new Error('unknown outputType');\n    }\n}\nexports.toType = toType;\n//# sourceMappingURL=types.js.map"]},"metadata":{},"sourceType":"script"}