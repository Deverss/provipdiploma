{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.accountBodyToRLP = exports.accountBodyToSlim = exports.accountBodyFromSlim = exports.isZeroAddress = exports.zeroAddress = exports.importPublic = exports.privateToAddress = exports.privateToPublic = exports.publicToAddress = exports.pubToAddress = exports.isValidPublic = exports.isValidPrivate = exports.generateAddress2 = exports.generateAddress = exports.isValidChecksumAddress = exports.toChecksumAddress = exports.isValidAddress = exports.Account = void 0;\n\nconst rlp_1 = require(\"@ethereumjs/rlp\");\n\nconst keccak_1 = require(\"ethereum-cryptography/keccak\");\n\nconst secp256k1_1 = require(\"ethereum-cryptography/secp256k1\");\n\nconst utils_1 = require(\"ethereum-cryptography/utils\");\n\nconst bytes_1 = require(\"./bytes\");\n\nconst constants_1 = require(\"./constants\");\n\nconst helpers_1 = require(\"./helpers\");\n\nconst internal_1 = require(\"./internal\");\n\nconst _0n = BigInt(0);\n\nclass Account {\n  /**\n   * This constructor assigns and validates the values.\n   * Use the static factory methods to assist in creating an Account from varying data types.\n   */\n  constructor(nonce = _0n, balance = _0n, storageRoot = constants_1.KECCAK256_RLP, codeHash = constants_1.KECCAK256_NULL) {\n    this.nonce = nonce;\n    this.balance = balance;\n    this.storageRoot = storageRoot;\n    this.codeHash = codeHash;\n\n    this._validate();\n  }\n\n  static fromAccountData(accountData) {\n    const {\n      nonce,\n      balance,\n      storageRoot,\n      codeHash\n    } = accountData;\n    return new Account(nonce !== undefined ? (0, bytes_1.bufferToBigInt)((0, bytes_1.toBuffer)(nonce)) : undefined, balance !== undefined ? (0, bytes_1.bufferToBigInt)((0, bytes_1.toBuffer)(balance)) : undefined, storageRoot !== undefined ? (0, bytes_1.toBuffer)(storageRoot) : undefined, codeHash !== undefined ? (0, bytes_1.toBuffer)(codeHash) : undefined);\n  }\n\n  static fromRlpSerializedAccount(serialized) {\n    const values = (0, bytes_1.arrToBufArr)(rlp_1.RLP.decode(Uint8Array.from(serialized)));\n\n    if (!Array.isArray(values)) {\n      throw new Error('Invalid serialized account input. Must be array');\n    }\n\n    return this.fromValuesArray(values);\n  }\n\n  static fromValuesArray(values) {\n    const [nonce, balance, storageRoot, codeHash] = values;\n    return new Account((0, bytes_1.bufferToBigInt)(nonce), (0, bytes_1.bufferToBigInt)(balance), storageRoot, codeHash);\n  }\n\n  _validate() {\n    if (this.nonce < _0n) {\n      throw new Error('nonce must be greater than zero');\n    }\n\n    if (this.balance < _0n) {\n      throw new Error('balance must be greater than zero');\n    }\n\n    if (this.storageRoot.length !== 32) {\n      throw new Error('storageRoot must have a length of 32');\n    }\n\n    if (this.codeHash.length !== 32) {\n      throw new Error('codeHash must have a length of 32');\n    }\n  }\n  /**\n   * Returns a Buffer Array of the raw Buffers for the account, in order.\n   */\n\n\n  raw() {\n    return [(0, bytes_1.bigIntToUnpaddedBuffer)(this.nonce), (0, bytes_1.bigIntToUnpaddedBuffer)(this.balance), this.storageRoot, this.codeHash];\n  }\n  /**\n   * Returns the RLP serialization of the account as a `Buffer`.\n   */\n\n\n  serialize() {\n    return Buffer.from(rlp_1.RLP.encode((0, bytes_1.bufArrToArr)(this.raw())));\n  }\n  /**\n   * Returns a `Boolean` determining if the account is a contract.\n   */\n\n\n  isContract() {\n    return !this.codeHash.equals(constants_1.KECCAK256_NULL);\n  }\n  /**\n   * Returns a `Boolean` determining if the account is empty complying to the definition of\n   * account emptiness in [EIP-161](https://eips.ethereum.org/EIPS/eip-161):\n   * \"An account is considered empty when it has no code and zero nonce and zero balance.\"\n   */\n\n\n  isEmpty() {\n    return this.balance === _0n && this.nonce === _0n && this.codeHash.equals(constants_1.KECCAK256_NULL);\n  }\n\n}\n\nexports.Account = Account;\n/**\n * Checks if the address is a valid. Accepts checksummed addresses too.\n */\n\nconst isValidAddress = function (hexAddress) {\n  try {\n    (0, helpers_1.assertIsString)(hexAddress);\n  } catch (e) {\n    return false;\n  }\n\n  return /^0x[0-9a-fA-F]{40}$/.test(hexAddress);\n};\n\nexports.isValidAddress = isValidAddress;\n/**\n * Returns a checksummed address.\n *\n * If an eip1191ChainId is provided, the chainId will be included in the checksum calculation. This\n * has the effect of checksummed addresses for one chain having invalid checksums for others.\n * For more details see [EIP-1191](https://eips.ethereum.org/EIPS/eip-1191).\n *\n * WARNING: Checksums with and without the chainId will differ and the EIP-1191 checksum is not\n * backwards compatible to the original widely adopted checksum format standard introduced in\n * [EIP-55](https://eips.ethereum.org/EIPS/eip-55), so this will break in existing applications.\n * Usage of this EIP is therefore discouraged unless you have a very targeted use case.\n */\n\nconst toChecksumAddress = function (hexAddress, eip1191ChainId) {\n  (0, helpers_1.assertIsHexString)(hexAddress);\n  const address = (0, internal_1.stripHexPrefix)(hexAddress).toLowerCase();\n  let prefix = '';\n\n  if (eip1191ChainId !== undefined) {\n    const chainId = (0, bytes_1.bufferToBigInt)((0, bytes_1.toBuffer)(eip1191ChainId));\n    prefix = chainId.toString() + '0x';\n  }\n\n  const buf = Buffer.from(prefix + address, 'utf8');\n  const hash = (0, utils_1.bytesToHex)((0, keccak_1.keccak256)(buf));\n  let ret = '0x';\n\n  for (let i = 0; i < address.length; i++) {\n    if (parseInt(hash[i], 16) >= 8) {\n      ret += address[i].toUpperCase();\n    } else {\n      ret += address[i];\n    }\n  }\n\n  return ret;\n};\n\nexports.toChecksumAddress = toChecksumAddress;\n/**\n * Checks if the address is a valid checksummed address.\n *\n * See toChecksumAddress' documentation for details about the eip1191ChainId parameter.\n */\n\nconst isValidChecksumAddress = function (hexAddress, eip1191ChainId) {\n  return (0, exports.isValidAddress)(hexAddress) && (0, exports.toChecksumAddress)(hexAddress, eip1191ChainId) === hexAddress;\n};\n\nexports.isValidChecksumAddress = isValidChecksumAddress;\n/**\n * Generates an address of a newly created contract.\n * @param from The address which is creating this new address\n * @param nonce The nonce of the from account\n */\n\nconst generateAddress = function (from, nonce) {\n  (0, helpers_1.assertIsBuffer)(from);\n  (0, helpers_1.assertIsBuffer)(nonce);\n\n  if ((0, bytes_1.bufferToBigInt)(nonce) === BigInt(0)) {\n    // in RLP we want to encode null in the case of zero nonce\n    // read the RLP documentation for an answer if you dare\n    return Buffer.from((0, keccak_1.keccak256)(rlp_1.RLP.encode((0, bytes_1.bufArrToArr)([from, null])))).slice(-20);\n  } // Only take the lower 160bits of the hash\n\n\n  return Buffer.from((0, keccak_1.keccak256)(rlp_1.RLP.encode((0, bytes_1.bufArrToArr)([from, nonce])))).slice(-20);\n};\n\nexports.generateAddress = generateAddress;\n/**\n * Generates an address for a contract created using CREATE2.\n * @param from The address which is creating this new address\n * @param salt A salt\n * @param initCode The init code of the contract being created\n */\n\nconst generateAddress2 = function (from, salt, initCode) {\n  (0, helpers_1.assertIsBuffer)(from);\n  (0, helpers_1.assertIsBuffer)(salt);\n  (0, helpers_1.assertIsBuffer)(initCode);\n\n  if (from.length !== 20) {\n    throw new Error('Expected from to be of length 20');\n  }\n\n  if (salt.length !== 32) {\n    throw new Error('Expected salt to be of length 32');\n  }\n\n  const address = (0, keccak_1.keccak256)(Buffer.concat([Buffer.from('ff', 'hex'), from, salt, (0, keccak_1.keccak256)(initCode)]));\n  return (0, bytes_1.toBuffer)(address).slice(-20);\n};\n\nexports.generateAddress2 = generateAddress2;\n/**\n * Checks if the private key satisfies the rules of the curve secp256k1.\n */\n\nconst isValidPrivate = function (privateKey) {\n  return secp256k1_1.utils.isValidPrivateKey(privateKey);\n};\n\nexports.isValidPrivate = isValidPrivate;\n/**\n * Checks if the public key satisfies the rules of the curve secp256k1\n * and the requirements of Ethereum.\n * @param publicKey The two points of an uncompressed key, unless sanitize is enabled\n * @param sanitize Accept public keys in other formats\n */\n\nconst isValidPublic = function (publicKey, sanitize = false) {\n  (0, helpers_1.assertIsBuffer)(publicKey);\n\n  if (publicKey.length === 64) {\n    // Convert to SEC1 for secp256k1\n    // Automatically checks whether point is on curve\n    try {\n      secp256k1_1.Point.fromHex(Buffer.concat([Buffer.from([4]), publicKey]));\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  if (!sanitize) {\n    return false;\n  }\n\n  try {\n    secp256k1_1.Point.fromHex(publicKey);\n    return true;\n  } catch (e) {\n    return false;\n  }\n};\n\nexports.isValidPublic = isValidPublic;\n/**\n * Returns the ethereum address of a given public key.\n * Accepts \"Ethereum public keys\" and SEC1 encoded keys.\n * @param pubKey The two points of an uncompressed key, unless sanitize is enabled\n * @param sanitize Accept public keys in other formats\n */\n\nconst pubToAddress = function (pubKey, sanitize = false) {\n  (0, helpers_1.assertIsBuffer)(pubKey);\n\n  if (sanitize && pubKey.length !== 64) {\n    pubKey = Buffer.from(secp256k1_1.Point.fromHex(pubKey).toRawBytes(false).slice(1));\n  }\n\n  if (pubKey.length !== 64) {\n    throw new Error('Expected pubKey to be of length 64');\n  } // Only take the lower 160bits of the hash\n\n\n  return Buffer.from((0, keccak_1.keccak256)(pubKey)).slice(-20);\n};\n\nexports.pubToAddress = pubToAddress;\nexports.publicToAddress = exports.pubToAddress;\n/**\n * Returns the ethereum public key of a given private key.\n * @param privateKey A private key must be 256 bits wide\n */\n\nconst privateToPublic = function (privateKey) {\n  (0, helpers_1.assertIsBuffer)(privateKey); // skip the type flag and use the X, Y points\n\n  return Buffer.from(secp256k1_1.Point.fromPrivateKey(privateKey).toRawBytes(false).slice(1));\n};\n\nexports.privateToPublic = privateToPublic;\n/**\n * Returns the ethereum address of a given private key.\n * @param privateKey A private key must be 256 bits wide\n */\n\nconst privateToAddress = function (privateKey) {\n  return (0, exports.publicToAddress)((0, exports.privateToPublic)(privateKey));\n};\n\nexports.privateToAddress = privateToAddress;\n/**\n * Converts a public key to the Ethereum format.\n */\n\nconst importPublic = function (publicKey) {\n  (0, helpers_1.assertIsBuffer)(publicKey);\n\n  if (publicKey.length !== 64) {\n    publicKey = Buffer.from(secp256k1_1.Point.fromHex(publicKey).toRawBytes(false).slice(1));\n  }\n\n  return publicKey;\n};\n\nexports.importPublic = importPublic;\n/**\n * Returns the zero address.\n */\n\nconst zeroAddress = function () {\n  const addressLength = 20;\n  const addr = (0, bytes_1.zeros)(addressLength);\n  return (0, bytes_1.bufferToHex)(addr);\n};\n\nexports.zeroAddress = zeroAddress;\n/**\n * Checks if a given address is the zero address.\n */\n\nconst isZeroAddress = function (hexAddress) {\n  try {\n    (0, helpers_1.assertIsString)(hexAddress);\n  } catch (e) {\n    return false;\n  }\n\n  const zeroAddr = (0, exports.zeroAddress)();\n  return zeroAddr === hexAddress;\n};\n\nexports.isZeroAddress = isZeroAddress;\n\nfunction accountBodyFromSlim(body) {\n  const [nonce, balance, storageRoot, codeHash] = body;\n  return [nonce, balance, (0, bytes_1.arrToBufArr)(storageRoot).length === 0 ? constants_1.KECCAK256_RLP : storageRoot, (0, bytes_1.arrToBufArr)(codeHash).length === 0 ? constants_1.KECCAK256_NULL : codeHash];\n}\n\nexports.accountBodyFromSlim = accountBodyFromSlim;\nconst emptyUint8Arr = new Uint8Array(0);\n\nfunction accountBodyToSlim(body) {\n  const [nonce, balance, storageRoot, codeHash] = body;\n  return [nonce, balance, (0, bytes_1.arrToBufArr)(storageRoot).equals(constants_1.KECCAK256_RLP) ? emptyUint8Arr : storageRoot, (0, bytes_1.arrToBufArr)(codeHash).equals(constants_1.KECCAK256_NULL) ? emptyUint8Arr : codeHash];\n}\n\nexports.accountBodyToSlim = accountBodyToSlim;\n/**\n * Converts a slim account (per snap protocol spec) to the RLP encoded version of the account\n * @param body Array of 4 Buffer-like items to represent the account\n * @returns RLP encoded version of the account\n */\n\nfunction accountBodyToRLP(body, couldBeSlim = true) {\n  const accountBody = couldBeSlim ? accountBodyFromSlim(body) : body;\n  return (0, bytes_1.arrToBufArr)(rlp_1.RLP.encode(accountBody));\n}\n\nexports.accountBodyToRLP = accountBodyToRLP;","map":{"version":3,"sources":["../src/account.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.accountBodyToRLP = exports.accountBodyToSlim = exports.accountBodyFromSlim = exports.isZeroAddress = exports.zeroAddress = exports.importPublic = exports.privateToAddress = exports.privateToPublic = exports.publicToAddress = exports.pubToAddress = exports.isValidPublic = exports.isValidPrivate = exports.generateAddress2 = exports.generateAddress = exports.isValidChecksumAddress = exports.toChecksumAddress = exports.isValidAddress = exports.Account = void 0;\nconst rlp_1 = require(\"@ethereumjs/rlp\");\nconst keccak_1 = require(\"ethereum-cryptography/keccak\");\nconst secp256k1_1 = require(\"ethereum-cryptography/secp256k1\");\nconst utils_1 = require(\"ethereum-cryptography/utils\");\nconst bytes_1 = require(\"./bytes\");\nconst constants_1 = require(\"./constants\");\nconst helpers_1 = require(\"./helpers\");\nconst internal_1 = require(\"./internal\");\nconst _0n = BigInt(0);\nclass Account {\n    /**\n     * This constructor assigns and validates the values.\n     * Use the static factory methods to assist in creating an Account from varying data types.\n     */\n    constructor(nonce = _0n, balance = _0n, storageRoot = constants_1.KECCAK256_RLP, codeHash = constants_1.KECCAK256_NULL) {\n        this.nonce = nonce;\n        this.balance = balance;\n        this.storageRoot = storageRoot;\n        this.codeHash = codeHash;\n        this._validate();\n    }\n    static fromAccountData(accountData) {\n        const { nonce, balance, storageRoot, codeHash } = accountData;\n        return new Account(nonce !== undefined ? (0, bytes_1.bufferToBigInt)((0, bytes_1.toBuffer)(nonce)) : undefined, balance !== undefined ? (0, bytes_1.bufferToBigInt)((0, bytes_1.toBuffer)(balance)) : undefined, storageRoot !== undefined ? (0, bytes_1.toBuffer)(storageRoot) : undefined, codeHash !== undefined ? (0, bytes_1.toBuffer)(codeHash) : undefined);\n    }\n    static fromRlpSerializedAccount(serialized) {\n        const values = (0, bytes_1.arrToBufArr)(rlp_1.RLP.decode(Uint8Array.from(serialized)));\n        if (!Array.isArray(values)) {\n            throw new Error('Invalid serialized account input. Must be array');\n        }\n        return this.fromValuesArray(values);\n    }\n    static fromValuesArray(values) {\n        const [nonce, balance, storageRoot, codeHash] = values;\n        return new Account((0, bytes_1.bufferToBigInt)(nonce), (0, bytes_1.bufferToBigInt)(balance), storageRoot, codeHash);\n    }\n    _validate() {\n        if (this.nonce < _0n) {\n            throw new Error('nonce must be greater than zero');\n        }\n        if (this.balance < _0n) {\n            throw new Error('balance must be greater than zero');\n        }\n        if (this.storageRoot.length !== 32) {\n            throw new Error('storageRoot must have a length of 32');\n        }\n        if (this.codeHash.length !== 32) {\n            throw new Error('codeHash must have a length of 32');\n        }\n    }\n    /**\n     * Returns a Buffer Array of the raw Buffers for the account, in order.\n     */\n    raw() {\n        return [\n            (0, bytes_1.bigIntToUnpaddedBuffer)(this.nonce),\n            (0, bytes_1.bigIntToUnpaddedBuffer)(this.balance),\n            this.storageRoot,\n            this.codeHash,\n        ];\n    }\n    /**\n     * Returns the RLP serialization of the account as a `Buffer`.\n     */\n    serialize() {\n        return Buffer.from(rlp_1.RLP.encode((0, bytes_1.bufArrToArr)(this.raw())));\n    }\n    /**\n     * Returns a `Boolean` determining if the account is a contract.\n     */\n    isContract() {\n        return !this.codeHash.equals(constants_1.KECCAK256_NULL);\n    }\n    /**\n     * Returns a `Boolean` determining if the account is empty complying to the definition of\n     * account emptiness in [EIP-161](https://eips.ethereum.org/EIPS/eip-161):\n     * \"An account is considered empty when it has no code and zero nonce and zero balance.\"\n     */\n    isEmpty() {\n        return this.balance === _0n && this.nonce === _0n && this.codeHash.equals(constants_1.KECCAK256_NULL);\n    }\n}\nexports.Account = Account;\n/**\n * Checks if the address is a valid. Accepts checksummed addresses too.\n */\nconst isValidAddress = function (hexAddress) {\n    try {\n        (0, helpers_1.assertIsString)(hexAddress);\n    }\n    catch (e) {\n        return false;\n    }\n    return /^0x[0-9a-fA-F]{40}$/.test(hexAddress);\n};\nexports.isValidAddress = isValidAddress;\n/**\n * Returns a checksummed address.\n *\n * If an eip1191ChainId is provided, the chainId will be included in the checksum calculation. This\n * has the effect of checksummed addresses for one chain having invalid checksums for others.\n * For more details see [EIP-1191](https://eips.ethereum.org/EIPS/eip-1191).\n *\n * WARNING: Checksums with and without the chainId will differ and the EIP-1191 checksum is not\n * backwards compatible to the original widely adopted checksum format standard introduced in\n * [EIP-55](https://eips.ethereum.org/EIPS/eip-55), so this will break in existing applications.\n * Usage of this EIP is therefore discouraged unless you have a very targeted use case.\n */\nconst toChecksumAddress = function (hexAddress, eip1191ChainId) {\n    (0, helpers_1.assertIsHexString)(hexAddress);\n    const address = (0, internal_1.stripHexPrefix)(hexAddress).toLowerCase();\n    let prefix = '';\n    if (eip1191ChainId !== undefined) {\n        const chainId = (0, bytes_1.bufferToBigInt)((0, bytes_1.toBuffer)(eip1191ChainId));\n        prefix = chainId.toString() + '0x';\n    }\n    const buf = Buffer.from(prefix + address, 'utf8');\n    const hash = (0, utils_1.bytesToHex)((0, keccak_1.keccak256)(buf));\n    let ret = '0x';\n    for (let i = 0; i < address.length; i++) {\n        if (parseInt(hash[i], 16) >= 8) {\n            ret += address[i].toUpperCase();\n        }\n        else {\n            ret += address[i];\n        }\n    }\n    return ret;\n};\nexports.toChecksumAddress = toChecksumAddress;\n/**\n * Checks if the address is a valid checksummed address.\n *\n * See toChecksumAddress' documentation for details about the eip1191ChainId parameter.\n */\nconst isValidChecksumAddress = function (hexAddress, eip1191ChainId) {\n    return (0, exports.isValidAddress)(hexAddress) && (0, exports.toChecksumAddress)(hexAddress, eip1191ChainId) === hexAddress;\n};\nexports.isValidChecksumAddress = isValidChecksumAddress;\n/**\n * Generates an address of a newly created contract.\n * @param from The address which is creating this new address\n * @param nonce The nonce of the from account\n */\nconst generateAddress = function (from, nonce) {\n    (0, helpers_1.assertIsBuffer)(from);\n    (0, helpers_1.assertIsBuffer)(nonce);\n    if ((0, bytes_1.bufferToBigInt)(nonce) === BigInt(0)) {\n        // in RLP we want to encode null in the case of zero nonce\n        // read the RLP documentation for an answer if you dare\n        return Buffer.from((0, keccak_1.keccak256)(rlp_1.RLP.encode((0, bytes_1.bufArrToArr)([from, null])))).slice(-20);\n    }\n    // Only take the lower 160bits of the hash\n    return Buffer.from((0, keccak_1.keccak256)(rlp_1.RLP.encode((0, bytes_1.bufArrToArr)([from, nonce])))).slice(-20);\n};\nexports.generateAddress = generateAddress;\n/**\n * Generates an address for a contract created using CREATE2.\n * @param from The address which is creating this new address\n * @param salt A salt\n * @param initCode The init code of the contract being created\n */\nconst generateAddress2 = function (from, salt, initCode) {\n    (0, helpers_1.assertIsBuffer)(from);\n    (0, helpers_1.assertIsBuffer)(salt);\n    (0, helpers_1.assertIsBuffer)(initCode);\n    if (from.length !== 20) {\n        throw new Error('Expected from to be of length 20');\n    }\n    if (salt.length !== 32) {\n        throw new Error('Expected salt to be of length 32');\n    }\n    const address = (0, keccak_1.keccak256)(Buffer.concat([Buffer.from('ff', 'hex'), from, salt, (0, keccak_1.keccak256)(initCode)]));\n    return (0, bytes_1.toBuffer)(address).slice(-20);\n};\nexports.generateAddress2 = generateAddress2;\n/**\n * Checks if the private key satisfies the rules of the curve secp256k1.\n */\nconst isValidPrivate = function (privateKey) {\n    return secp256k1_1.utils.isValidPrivateKey(privateKey);\n};\nexports.isValidPrivate = isValidPrivate;\n/**\n * Checks if the public key satisfies the rules of the curve secp256k1\n * and the requirements of Ethereum.\n * @param publicKey The two points of an uncompressed key, unless sanitize is enabled\n * @param sanitize Accept public keys in other formats\n */\nconst isValidPublic = function (publicKey, sanitize = false) {\n    (0, helpers_1.assertIsBuffer)(publicKey);\n    if (publicKey.length === 64) {\n        // Convert to SEC1 for secp256k1\n        // Automatically checks whether point is on curve\n        try {\n            secp256k1_1.Point.fromHex(Buffer.concat([Buffer.from([4]), publicKey]));\n            return true;\n        }\n        catch (e) {\n            return false;\n        }\n    }\n    if (!sanitize) {\n        return false;\n    }\n    try {\n        secp256k1_1.Point.fromHex(publicKey);\n        return true;\n    }\n    catch (e) {\n        return false;\n    }\n};\nexports.isValidPublic = isValidPublic;\n/**\n * Returns the ethereum address of a given public key.\n * Accepts \"Ethereum public keys\" and SEC1 encoded keys.\n * @param pubKey The two points of an uncompressed key, unless sanitize is enabled\n * @param sanitize Accept public keys in other formats\n */\nconst pubToAddress = function (pubKey, sanitize = false) {\n    (0, helpers_1.assertIsBuffer)(pubKey);\n    if (sanitize && pubKey.length !== 64) {\n        pubKey = Buffer.from(secp256k1_1.Point.fromHex(pubKey).toRawBytes(false).slice(1));\n    }\n    if (pubKey.length !== 64) {\n        throw new Error('Expected pubKey to be of length 64');\n    }\n    // Only take the lower 160bits of the hash\n    return Buffer.from((0, keccak_1.keccak256)(pubKey)).slice(-20);\n};\nexports.pubToAddress = pubToAddress;\nexports.publicToAddress = exports.pubToAddress;\n/**\n * Returns the ethereum public key of a given private key.\n * @param privateKey A private key must be 256 bits wide\n */\nconst privateToPublic = function (privateKey) {\n    (0, helpers_1.assertIsBuffer)(privateKey);\n    // skip the type flag and use the X, Y points\n    return Buffer.from(secp256k1_1.Point.fromPrivateKey(privateKey).toRawBytes(false).slice(1));\n};\nexports.privateToPublic = privateToPublic;\n/**\n * Returns the ethereum address of a given private key.\n * @param privateKey A private key must be 256 bits wide\n */\nconst privateToAddress = function (privateKey) {\n    return (0, exports.publicToAddress)((0, exports.privateToPublic)(privateKey));\n};\nexports.privateToAddress = privateToAddress;\n/**\n * Converts a public key to the Ethereum format.\n */\nconst importPublic = function (publicKey) {\n    (0, helpers_1.assertIsBuffer)(publicKey);\n    if (publicKey.length !== 64) {\n        publicKey = Buffer.from(secp256k1_1.Point.fromHex(publicKey).toRawBytes(false).slice(1));\n    }\n    return publicKey;\n};\nexports.importPublic = importPublic;\n/**\n * Returns the zero address.\n */\nconst zeroAddress = function () {\n    const addressLength = 20;\n    const addr = (0, bytes_1.zeros)(addressLength);\n    return (0, bytes_1.bufferToHex)(addr);\n};\nexports.zeroAddress = zeroAddress;\n/**\n * Checks if a given address is the zero address.\n */\nconst isZeroAddress = function (hexAddress) {\n    try {\n        (0, helpers_1.assertIsString)(hexAddress);\n    }\n    catch (e) {\n        return false;\n    }\n    const zeroAddr = (0, exports.zeroAddress)();\n    return zeroAddr === hexAddress;\n};\nexports.isZeroAddress = isZeroAddress;\nfunction accountBodyFromSlim(body) {\n    const [nonce, balance, storageRoot, codeHash] = body;\n    return [\n        nonce,\n        balance,\n        (0, bytes_1.arrToBufArr)(storageRoot).length === 0 ? constants_1.KECCAK256_RLP : storageRoot,\n        (0, bytes_1.arrToBufArr)(codeHash).length === 0 ? constants_1.KECCAK256_NULL : codeHash,\n    ];\n}\nexports.accountBodyFromSlim = accountBodyFromSlim;\nconst emptyUint8Arr = new Uint8Array(0);\nfunction accountBodyToSlim(body) {\n    const [nonce, balance, storageRoot, codeHash] = body;\n    return [\n        nonce,\n        balance,\n        (0, bytes_1.arrToBufArr)(storageRoot).equals(constants_1.KECCAK256_RLP) ? emptyUint8Arr : storageRoot,\n        (0, bytes_1.arrToBufArr)(codeHash).equals(constants_1.KECCAK256_NULL) ? emptyUint8Arr : codeHash,\n    ];\n}\nexports.accountBodyToSlim = accountBodyToSlim;\n/**\n * Converts a slim account (per snap protocol spec) to the RLP encoded version of the account\n * @param body Array of 4 Buffer-like items to represent the account\n * @returns RLP encoded version of the account\n */\nfunction accountBodyToRLP(body, couldBeSlim = true) {\n    const accountBody = couldBeSlim ? accountBodyFromSlim(body) : body;\n    return (0, bytes_1.arrToBufArr)(rlp_1.RLP.encode(accountBody));\n}\nexports.accountBodyToRLP = accountBodyToRLP;\n//# sourceMappingURL=account.js.map"]},"metadata":{},"sourceType":"script"}