{"ast":null,"code":"import _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport WalletConnect from '@walletconnect/client';\nimport { CHAIN_NAMESPACES, WALLET_ADAPTERS, ADAPTER_NAMESPACES, ADAPTER_CATEGORY, ADAPTER_STATUS, ADAPTER_EVENTS, log, WalletInitializationError, Web3AuthError, WalletLoginError, getChainConfig } from '@web3auth/base';\nimport { BaseEvmAdapter } from '@web3auth/base-evm-adapter';\nimport { WalletConnectProvider } from '@web3auth/ethereum-provider';\nconst WALLET_CONNECT_EXTENSION_ADAPTERS = [{\n  name: \"Rainbow\",\n  chains: [CHAIN_NAMESPACES.EIP155],\n  logo: \"https://images.web3auth.io/login-rainbow.svg\",\n  mobile: {\n    native: \"rainbow:\",\n    universal: \"https://rnbwapp.com\"\n  },\n  desktop: {\n    native: \"\",\n    universal: \"\"\n  }\n}, {\n  name: \"MetaMask\",\n  chains: [CHAIN_NAMESPACES.EIP155],\n  logo: \"https://images.web3auth.io/login-metamask.svg\",\n  mobile: {\n    native: \"metamask:\",\n    universal: \"https://metamask.app.link\"\n  },\n  desktop: {\n    native: \"\",\n    universal: \"\"\n  }\n}];\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n}\n\nclass WalletConnectV1Adapter extends BaseEvmAdapter {\n  constructor() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super(options);\n\n    _defineProperty(this, \"name\", WALLET_ADAPTERS.WALLET_CONNECT_V1);\n\n    _defineProperty(this, \"adapterNamespace\", ADAPTER_NAMESPACES.EIP155);\n\n    _defineProperty(this, \"currentChainNamespace\", CHAIN_NAMESPACES.EIP155);\n\n    _defineProperty(this, \"type\", ADAPTER_CATEGORY.EXTERNAL);\n\n    _defineProperty(this, \"adapterOptions\", void 0);\n\n    _defineProperty(this, \"status\", ADAPTER_STATUS.NOT_READY);\n\n    _defineProperty(this, \"adapterData\", {\n      uri: \"\",\n      extensionAdapters: WALLET_CONNECT_EXTENSION_ADAPTERS\n    });\n\n    _defineProperty(this, \"connector\", null);\n\n    _defineProperty(this, \"wcProvider\", null);\n\n    this.adapterOptions = _objectSpread({}, options);\n  }\n\n  get connected() {\n    var _this$connector;\n\n    return !!((_this$connector = this.connector) !== null && _this$connector !== void 0 && _this$connector.connected);\n  }\n\n  get provider() {\n    var _this$wcProvider;\n\n    return ((_this$wcProvider = this.wcProvider) === null || _this$wcProvider === void 0 ? void 0 : _this$wcProvider.provider) || null;\n  }\n\n  set provider(_) {\n    throw new Error(\"Not implemented\");\n  }\n\n  async init() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    await super.init();\n    super.checkInitializationRequirements(); // Create a connector\n\n    this.connector = this.getWalletConnectInstance();\n    this.wcProvider = new WalletConnectProvider({\n      config: {\n        chainConfig: this.chainConfig\n      },\n      connector: this.connector\n    });\n    this.emit(ADAPTER_EVENTS.READY, WALLET_ADAPTERS.WALLET_CONNECT_V1);\n    this.status = ADAPTER_STATUS.READY;\n    log.debug(\"initializing wallet connect v1 adapter\");\n\n    if (options.autoConnect) {\n      if (this.connected) {\n        try {\n          this.rehydrated = true;\n          await this.onConnectHandler({\n            accounts: this.connector.accounts,\n            chainId: this.connector.chainId\n          });\n        } catch (error) {\n          log.error(\"wallet auto connect\", error);\n          this.emit(ADAPTER_EVENTS.ERRORED, error);\n        }\n      } else {\n        this.status = ADAPTER_STATUS.NOT_READY;\n        this.emit(ADAPTER_EVENTS.CACHE_CLEAR);\n      }\n    }\n  }\n\n  async connect() {\n    super.checkConnectionRequirements();\n    if (!this.connector) throw WalletInitializationError.notReady(\"Wallet adapter is not ready yet\");\n\n    if (this.connected) {\n      await this.onConnectHandler({\n        accounts: this.connector.accounts,\n        chainId: this.connector.chainId\n      });\n      return this.provider;\n    }\n\n    if (this.status !== ADAPTER_STATUS.CONNECTING) {\n      var _this$adapterOptions$; // for wallet connect qr code modal we have to create a new connector, coz wallet connect internally does not open\n      // modal again on existing instance if connection is pending.\n\n\n      if ((_this$adapterOptions$ = this.adapterOptions.adapterSettings) !== null && _this$adapterOptions$ !== void 0 && _this$adapterOptions$.qrcodeModal) {\n        var _this$adapterOptions$2;\n\n        this.connector = this.getWalletConnectInstance();\n        this.wcProvider = new WalletConnectProvider({\n          config: {\n            chainConfig: this.chainConfig,\n            // network switching can be skipped with custom ui\n            skipLookupNetwork: (_this$adapterOptions$2 = this.adapterOptions.adapterSettings) === null || _this$adapterOptions$2 === void 0 ? void 0 : _this$adapterOptions$2.skipNetworkSwitching\n          },\n          connector: this.connector\n        });\n      }\n\n      await this.createNewSession();\n      this.status = ADAPTER_STATUS.CONNECTING;\n      this.emit(ADAPTER_EVENTS.CONNECTING, {\n        adapter: WALLET_ADAPTERS.WALLET_CONNECT_V1\n      });\n    }\n\n    return new Promise((resolve, reject) => {\n      if (!this.connector) {\n        reject(WalletInitializationError.notReady(\"Wallet adapter is not ready yet\"));\n        return;\n      } // for wallet connect default modal.\n\n\n      this.connector.on(\"modal_closed\", async () => {\n        this.status = ADAPTER_STATUS.READY;\n        this.emit(ADAPTER_EVENTS.READY, WALLET_ADAPTERS.WALLET_CONNECT_V1);\n        return reject(new Error(\"User closed modal\"));\n      });\n\n      try {\n        // Subscribe to session connection\n        this.connector.on(\"connect\", async (error, payload) => {\n          if (error) {\n            this.emit(ADAPTER_EVENTS.ERRORED, error);\n          }\n\n          log.debug(\"connected event emitted by web3auth\");\n          await this.onConnectHandler(payload.params[0]);\n          return resolve(this.provider);\n        });\n      } catch (error) {\n        log.error(\"Wallet connect v1 adapter error while connecting\", error); // ready again to be connected\n\n        this.status = ADAPTER_STATUS.READY;\n        this.rehydrated = true;\n        this.emit(ADAPTER_EVENTS.ERRORED, error);\n        reject(error instanceof Web3AuthError ? error : WalletLoginError.connectionError(`Failed to login with wallet connect: ${(error === null || error === void 0 ? void 0 : error.message) || \"\"}`));\n      }\n    });\n  }\n\n  async getUserInfo() {\n    if (!this.connected) throw WalletLoginError.notConnectedError(\"Not connected with wallet, Please login/connect first\");\n    return {};\n  }\n\n  async disconnect() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n      cleanup: false\n    };\n    await super.disconnectSession();\n    const {\n      cleanup\n    } = options;\n    if (!this.connector || !this.connected) throw WalletLoginError.notConnectedError(\"Not connected with wallet\");\n    await this.connector.killSession();\n    this.rehydrated = false;\n\n    if (cleanup) {\n      this.connector = null;\n      this.status = ADAPTER_STATUS.NOT_READY;\n      this.wcProvider = null;\n    } else {\n      // ready to connect again\n      this.status = ADAPTER_STATUS.READY;\n    }\n\n    await super.disconnect();\n  }\n\n  async addChain(chainConfig) {\n    var _this$adapterOptions$3, _this$wcProvider2;\n\n    let init = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    super.checkAddChainRequirements(init);\n    const networkSwitch = (_this$adapterOptions$3 = this.adapterOptions.adapterSettings) === null || _this$adapterOptions$3 === void 0 ? void 0 : _this$adapterOptions$3.networkSwitchModal;\n\n    if (networkSwitch) {\n      await networkSwitch.addNetwork({\n        chainConfig,\n        appOrigin: window.location.hostname\n      });\n    }\n\n    await ((_this$wcProvider2 = this.wcProvider) === null || _this$wcProvider2 === void 0 ? void 0 : _this$wcProvider2.addChain(chainConfig));\n    this.addChainConfig(chainConfig);\n  }\n\n  async switchChain(params) {\n    let init = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    super.checkSwitchChainRequirements(params, init);\n    await this._switchChain({\n      chainId: params.chainId\n    }, this.chainConfig);\n    this.setAdapterSettings({\n      chainConfig: this.getChainConfig(params.chainId)\n    });\n  }\n\n  async _switchChain(connectedChainConfig, chainConfig) {\n    var _this$adapterOptions$4, _this$wcProvider3;\n\n    const networkSwitch = (_this$adapterOptions$4 = this.adapterOptions.adapterSettings) === null || _this$adapterOptions$4 === void 0 ? void 0 : _this$adapterOptions$4.networkSwitchModal;\n\n    if (networkSwitch) {\n      await networkSwitch.switchNetwork({\n        currentChainConfig: chainConfig,\n        newChainConfig: connectedChainConfig,\n        appOrigin: window.location.hostname\n      });\n    }\n\n    await ((_this$wcProvider3 = this.wcProvider) === null || _this$wcProvider3 === void 0 ? void 0 : _this$wcProvider3.switchChain({\n      chainId: chainConfig.chainId,\n      lookup: false,\n      addChain: false\n    }));\n  }\n\n  async createNewSession() {\n    var _this$adapterOptions, _this$adapterOptions$5;\n\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n      forceNewSession: false\n    };\n    if (!this.connector) throw WalletInitializationError.notReady(\"Wallet adapter is not ready yet\");\n\n    if (opts.forceNewSession && this.connector.pending) {\n      await this.connector.killSession();\n    } // for wallet connect qr modal\n\n\n    if ((_this$adapterOptions = this.adapterOptions) !== null && _this$adapterOptions !== void 0 && (_this$adapterOptions$5 = _this$adapterOptions.adapterSettings) !== null && _this$adapterOptions$5 !== void 0 && _this$adapterOptions$5.qrcodeModal) {\n      var _this$chainConfig;\n\n      await this.connector.createSession({\n        chainId: parseInt(((_this$chainConfig = this.chainConfig) === null || _this$chainConfig === void 0 ? void 0 : _this$chainConfig.chainId) || \"0x1\", 16)\n      });\n      return;\n    } // for web3auth qr code modal\n\n\n    return new Promise((resolve, reject) => {\n      var _this$chainConfig2;\n\n      if (!this.connector) {\n        reject(WalletInitializationError.notReady(\"Wallet adapter is not ready yet\"));\n        return;\n      }\n\n      log.debug(\"creating new session for web3auth wallet connect\");\n      this.connector.on(\"display_uri\", async (err, payload) => {\n        var _this$connector2;\n\n        if (err) {\n          this.emit(ADAPTER_EVENTS.ERRORED, WalletLoginError.connectionError(\"Failed to display wallet connect qr code\"));\n          return reject(err);\n        }\n\n        const uri = payload.params[0];\n        this.updateAdapterData({\n          uri,\n          extensionAdapters: WALLET_CONNECT_EXTENSION_ADAPTERS\n        });\n        (_this$connector2 = this.connector) === null || _this$connector2 === void 0 ? void 0 : _this$connector2.off(\"display_uri\");\n        return resolve();\n      });\n      this.connector.createSession({\n        chainId: parseInt(((_this$chainConfig2 = this.chainConfig) === null || _this$chainConfig2 === void 0 ? void 0 : _this$chainConfig2.chainId) || \"0x1\", 16)\n      }).catch(error => {\n        log.error(\"error while creating new wallet connect session\", error);\n        this.emit(ADAPTER_EVENTS.ERRORED, error);\n        return reject(error);\n      });\n    });\n  }\n\n  async onConnectHandler(params) {\n    if (!this.connector || !this.wcProvider) throw WalletInitializationError.notReady(\"Wallet adapter is not ready yet\");\n    if (!this.chainConfig) throw WalletInitializationError.invalidParams(\"Chain config is not set\");\n    const {\n      chainId\n    } = params;\n    log.debug(\"connected chainId in hex\"); // This is to check if the connected wallet can return chainId\n    // in string or a number format.\n\n    let isDifferentChain = false;\n\n    if (typeof chainId === \"string\") {\n      isDifferentChain = chainId !== this.chainConfig.chainId;\n    } else if (typeof chainId === \"number\") {\n      isDifferentChain = chainId !== parseInt(this.chainConfig.chainId, 16);\n    }\n\n    if (isDifferentChain) {\n      var _this$adapterOptions$6, _this$adapterOptions2, _this$adapterOptions3;\n\n      const connectedChainConfig = getChainConfig(CHAIN_NAMESPACES.EIP155, chainId) || {\n        chainId: typeof chainId === \"number\" ? `0x${chainId.toString(16)}` : chainId,\n        displayName: \"Unknown Network\"\n      };\n      const isCustomUi = (_this$adapterOptions$6 = this.adapterOptions.adapterSettings) === null || _this$adapterOptions$6 === void 0 ? void 0 : _this$adapterOptions$6.qrcodeModal; // skipping network is not allowed in default ui. We are use network switching modal for default ui.\n\n      if (!isCustomUi || isCustomUi && !((_this$adapterOptions2 = this.adapterOptions) !== null && _this$adapterOptions2 !== void 0 && (_this$adapterOptions3 = _this$adapterOptions2.adapterSettings) !== null && _this$adapterOptions3 !== void 0 && _this$adapterOptions3.skipNetworkSwitching)) {\n        try {\n          await this.addChain(this.chainConfig, true);\n          await this._switchChain(connectedChainConfig, this.chainConfig);\n          this.connector = this.getWalletConnectInstance();\n        } catch (error) {\n          log.error(\"error while chain switching\", error); // we need to create a new session since old session is already used and\n          // user needs to login again with correct chain with new qr code.\n\n          await this.createNewSession({\n            forceNewSession: true\n          });\n          this.emit(ADAPTER_EVENTS.ERRORED, WalletInitializationError.fromCode(5000, `Not connected to correct network. Expected: ${this.chainConfig.displayName}, Current: ${(connectedChainConfig === null || connectedChainConfig === void 0 ? void 0 : connectedChainConfig.displayName) || chainId}, Please switch to correct network from wallet`));\n          this.status = ADAPTER_STATUS.READY;\n          this.rehydrated = true;\n          return;\n        }\n      }\n    }\n\n    await this.wcProvider.setupProvider(this.connector);\n    this.subscribeEvents(this.connector);\n    this.status = ADAPTER_STATUS.CONNECTED;\n    this.emit(ADAPTER_EVENTS.CONNECTED, {\n      adapter: WALLET_ADAPTERS.WALLET_CONNECT_V1,\n      reconnected: this.rehydrated\n    });\n  }\n\n  subscribeEvents(connector) {\n    connector.on(\"session_update\", async error => {\n      if (error) {\n        this.emit(ADAPTER_EVENTS.ERRORED, error);\n      }\n    });\n    connector.on(\"disconnect\", async (error, _) => {\n      if (error) {\n        this.emit(ADAPTER_EVENTS.ERRORED, error);\n      }\n\n      log.debug(\"disconnect event emitted by web3auth\");\n      await super.disconnect();\n      this.status = ADAPTER_EVENTS.READY;\n    });\n  }\n\n  getWalletConnectInstance() {\n    const walletConnectOptions = this.adapterOptions.adapterSettings || {};\n    walletConnectOptions.bridge = walletConnectOptions.bridge || \"https://bridge.walletconnect.org\"; // Create a connector\n\n    return new WalletConnect(walletConnectOptions);\n  }\n\n}\n\nexport { WalletConnectV1Adapter };","map":{"version":3,"sources":["../src/config.ts","../src/walletConnectV1adapter.ts"],"names":["WALLET_CONNECT_EXTENSION_ADAPTERS","name","chains","CHAIN_NAMESPACES","EIP155","logo","mobile","native","universal","desktop","WalletConnectV1Adapter","BaseEvmAdapter","WALLET_ADAPTERS","WALLET_CONNECT_V1","_defineProperty","ADAPTER_NAMESPACES","ADAPTER_CATEGORY","EXTERNAL","ADAPTER_STATUS","NOT_READY","uri","extensionAdapters","constructor","options","adapterOptions","connected","connector","provider","wcProvider","_","Error","init","checkInitializationRequirements","getWalletConnectInstance","WalletConnectProvider","config","chainConfig","emit","ADAPTER_EVENTS","READY","status","log","debug","autoConnect","rehydrated","onConnectHandler","accounts","chainId","error","ERRORED","CACHE_CLEAR","connect","checkConnectionRequirements","WalletInitializationError","notReady","CONNECTING","adapterSettings","qrcodeModal","skipLookupNetwork","skipNetworkSwitching","createNewSession","adapter","Promise","resolve","reject","on","payload","params","Web3AuthError","WalletLoginError","connectionError","message","getUserInfo","notConnectedError","disconnect","cleanup","disconnectSession","killSession","addChain","checkAddChainRequirements","networkSwitch","networkSwitchModal","addNetwork","appOrigin","window","location","hostname","addChainConfig","switchChain","checkSwitchChainRequirements","_switchChain","setAdapterSettings","getChainConfig","connectedChainConfig","switchNetwork","currentChainConfig","newChainConfig","lookup","opts","forceNewSession","pending","createSession","parseInt","err","updateAdapterData","off","catch","invalidParams","isDifferentChain","toString","displayName","isCustomUi","fromCode","setupProvider","subscribeEvents","CONNECTED","reconnected","walletConnectOptions","bridge","WalletConnect"],"mappings":"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","sourcesContent":["import _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport WalletConnect from '@walletconnect/client';\nimport { CHAIN_NAMESPACES, WALLET_ADAPTERS, ADAPTER_NAMESPACES, ADAPTER_CATEGORY, ADAPTER_STATUS, ADAPTER_EVENTS, log, WalletInitializationError, Web3AuthError, WalletLoginError, getChainConfig } from '@web3auth/base';\nimport { BaseEvmAdapter } from '@web3auth/base-evm-adapter';\nimport { WalletConnectProvider } from '@web3auth/ethereum-provider';\n\nconst WALLET_CONNECT_EXTENSION_ADAPTERS = [{\n  name: \"Rainbow\",\n  chains: [CHAIN_NAMESPACES.EIP155],\n  logo: \"https://images.web3auth.io/login-rainbow.svg\",\n  mobile: {\n    native: \"rainbow:\",\n    universal: \"https://rnbwapp.com\"\n  },\n  desktop: {\n    native: \"\",\n    universal: \"\"\n  }\n}, {\n  name: \"MetaMask\",\n  chains: [CHAIN_NAMESPACES.EIP155],\n  logo: \"https://images.web3auth.io/login-metamask.svg\",\n  mobile: {\n    native: \"metamask:\",\n    universal: \"https://metamask.app.link\"\n  },\n  desktop: {\n    native: \"\",\n    universal: \"\"\n  }\n}];\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nclass WalletConnectV1Adapter extends BaseEvmAdapter {\n  constructor() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super(options);\n    _defineProperty(this, \"name\", WALLET_ADAPTERS.WALLET_CONNECT_V1);\n    _defineProperty(this, \"adapterNamespace\", ADAPTER_NAMESPACES.EIP155);\n    _defineProperty(this, \"currentChainNamespace\", CHAIN_NAMESPACES.EIP155);\n    _defineProperty(this, \"type\", ADAPTER_CATEGORY.EXTERNAL);\n    _defineProperty(this, \"adapterOptions\", void 0);\n    _defineProperty(this, \"status\", ADAPTER_STATUS.NOT_READY);\n    _defineProperty(this, \"adapterData\", {\n      uri: \"\",\n      extensionAdapters: WALLET_CONNECT_EXTENSION_ADAPTERS\n    });\n    _defineProperty(this, \"connector\", null);\n    _defineProperty(this, \"wcProvider\", null);\n    this.adapterOptions = _objectSpread({}, options);\n  }\n  get connected() {\n    var _this$connector;\n    return !!((_this$connector = this.connector) !== null && _this$connector !== void 0 && _this$connector.connected);\n  }\n  get provider() {\n    var _this$wcProvider;\n    return ((_this$wcProvider = this.wcProvider) === null || _this$wcProvider === void 0 ? void 0 : _this$wcProvider.provider) || null;\n  }\n  set provider(_) {\n    throw new Error(\"Not implemented\");\n  }\n  async init() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    await super.init();\n    super.checkInitializationRequirements();\n    // Create a connector\n    this.connector = this.getWalletConnectInstance();\n    this.wcProvider = new WalletConnectProvider({\n      config: {\n        chainConfig: this.chainConfig\n      },\n      connector: this.connector\n    });\n    this.emit(ADAPTER_EVENTS.READY, WALLET_ADAPTERS.WALLET_CONNECT_V1);\n    this.status = ADAPTER_STATUS.READY;\n    log.debug(\"initializing wallet connect v1 adapter\");\n    if (options.autoConnect) {\n      if (this.connected) {\n        try {\n          this.rehydrated = true;\n          await this.onConnectHandler({\n            accounts: this.connector.accounts,\n            chainId: this.connector.chainId\n          });\n        } catch (error) {\n          log.error(\"wallet auto connect\", error);\n          this.emit(ADAPTER_EVENTS.ERRORED, error);\n        }\n      } else {\n        this.status = ADAPTER_STATUS.NOT_READY;\n        this.emit(ADAPTER_EVENTS.CACHE_CLEAR);\n      }\n    }\n  }\n  async connect() {\n    super.checkConnectionRequirements();\n    if (!this.connector) throw WalletInitializationError.notReady(\"Wallet adapter is not ready yet\");\n    if (this.connected) {\n      await this.onConnectHandler({\n        accounts: this.connector.accounts,\n        chainId: this.connector.chainId\n      });\n      return this.provider;\n    }\n    if (this.status !== ADAPTER_STATUS.CONNECTING) {\n      var _this$adapterOptions$;\n      // for wallet connect qr code modal we have to create a new connector, coz wallet connect internally does not open\n      // modal again on existing instance if connection is pending.\n      if ((_this$adapterOptions$ = this.adapterOptions.adapterSettings) !== null && _this$adapterOptions$ !== void 0 && _this$adapterOptions$.qrcodeModal) {\n        var _this$adapterOptions$2;\n        this.connector = this.getWalletConnectInstance();\n        this.wcProvider = new WalletConnectProvider({\n          config: {\n            chainConfig: this.chainConfig,\n            // network switching can be skipped with custom ui\n            skipLookupNetwork: (_this$adapterOptions$2 = this.adapterOptions.adapterSettings) === null || _this$adapterOptions$2 === void 0 ? void 0 : _this$adapterOptions$2.skipNetworkSwitching\n          },\n          connector: this.connector\n        });\n      }\n      await this.createNewSession();\n      this.status = ADAPTER_STATUS.CONNECTING;\n      this.emit(ADAPTER_EVENTS.CONNECTING, {\n        adapter: WALLET_ADAPTERS.WALLET_CONNECT_V1\n      });\n    }\n    return new Promise((resolve, reject) => {\n      if (!this.connector) {\n        reject(WalletInitializationError.notReady(\"Wallet adapter is not ready yet\"));\n        return;\n      }\n      // for wallet connect default modal.\n      this.connector.on(\"modal_closed\", async () => {\n        this.status = ADAPTER_STATUS.READY;\n        this.emit(ADAPTER_EVENTS.READY, WALLET_ADAPTERS.WALLET_CONNECT_V1);\n        return reject(new Error(\"User closed modal\"));\n      });\n      try {\n        // Subscribe to session connection\n        this.connector.on(\"connect\", async (error, payload) => {\n          if (error) {\n            this.emit(ADAPTER_EVENTS.ERRORED, error);\n          }\n          log.debug(\"connected event emitted by web3auth\");\n          await this.onConnectHandler(payload.params[0]);\n          return resolve(this.provider);\n        });\n      } catch (error) {\n        log.error(\"Wallet connect v1 adapter error while connecting\", error);\n        // ready again to be connected\n        this.status = ADAPTER_STATUS.READY;\n        this.rehydrated = true;\n        this.emit(ADAPTER_EVENTS.ERRORED, error);\n        reject(error instanceof Web3AuthError ? error : WalletLoginError.connectionError(`Failed to login with wallet connect: ${(error === null || error === void 0 ? void 0 : error.message) || \"\"}`));\n      }\n    });\n  }\n  async getUserInfo() {\n    if (!this.connected) throw WalletLoginError.notConnectedError(\"Not connected with wallet, Please login/connect first\");\n    return {};\n  }\n  async disconnect() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n      cleanup: false\n    };\n    await super.disconnectSession();\n    const {\n      cleanup\n    } = options;\n    if (!this.connector || !this.connected) throw WalletLoginError.notConnectedError(\"Not connected with wallet\");\n    await this.connector.killSession();\n    this.rehydrated = false;\n    if (cleanup) {\n      this.connector = null;\n      this.status = ADAPTER_STATUS.NOT_READY;\n      this.wcProvider = null;\n    } else {\n      // ready to connect again\n      this.status = ADAPTER_STATUS.READY;\n    }\n    await super.disconnect();\n  }\n  async addChain(chainConfig) {\n    var _this$adapterOptions$3, _this$wcProvider2;\n    let init = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    super.checkAddChainRequirements(init);\n    const networkSwitch = (_this$adapterOptions$3 = this.adapterOptions.adapterSettings) === null || _this$adapterOptions$3 === void 0 ? void 0 : _this$adapterOptions$3.networkSwitchModal;\n    if (networkSwitch) {\n      await networkSwitch.addNetwork({\n        chainConfig,\n        appOrigin: window.location.hostname\n      });\n    }\n    await ((_this$wcProvider2 = this.wcProvider) === null || _this$wcProvider2 === void 0 ? void 0 : _this$wcProvider2.addChain(chainConfig));\n    this.addChainConfig(chainConfig);\n  }\n  async switchChain(params) {\n    let init = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    super.checkSwitchChainRequirements(params, init);\n    await this._switchChain({\n      chainId: params.chainId\n    }, this.chainConfig);\n    this.setAdapterSettings({\n      chainConfig: this.getChainConfig(params.chainId)\n    });\n  }\n  async _switchChain(connectedChainConfig, chainConfig) {\n    var _this$adapterOptions$4, _this$wcProvider3;\n    const networkSwitch = (_this$adapterOptions$4 = this.adapterOptions.adapterSettings) === null || _this$adapterOptions$4 === void 0 ? void 0 : _this$adapterOptions$4.networkSwitchModal;\n    if (networkSwitch) {\n      await networkSwitch.switchNetwork({\n        currentChainConfig: chainConfig,\n        newChainConfig: connectedChainConfig,\n        appOrigin: window.location.hostname\n      });\n    }\n    await ((_this$wcProvider3 = this.wcProvider) === null || _this$wcProvider3 === void 0 ? void 0 : _this$wcProvider3.switchChain({\n      chainId: chainConfig.chainId,\n      lookup: false,\n      addChain: false\n    }));\n  }\n  async createNewSession() {\n    var _this$adapterOptions, _this$adapterOptions$5;\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n      forceNewSession: false\n    };\n    if (!this.connector) throw WalletInitializationError.notReady(\"Wallet adapter is not ready yet\");\n    if (opts.forceNewSession && this.connector.pending) {\n      await this.connector.killSession();\n    }\n    // for wallet connect qr modal\n    if ((_this$adapterOptions = this.adapterOptions) !== null && _this$adapterOptions !== void 0 && (_this$adapterOptions$5 = _this$adapterOptions.adapterSettings) !== null && _this$adapterOptions$5 !== void 0 && _this$adapterOptions$5.qrcodeModal) {\n      var _this$chainConfig;\n      await this.connector.createSession({\n        chainId: parseInt(((_this$chainConfig = this.chainConfig) === null || _this$chainConfig === void 0 ? void 0 : _this$chainConfig.chainId) || \"0x1\", 16)\n      });\n      return;\n    }\n    // for web3auth qr code modal\n    return new Promise((resolve, reject) => {\n      var _this$chainConfig2;\n      if (!this.connector) {\n        reject(WalletInitializationError.notReady(\"Wallet adapter is not ready yet\"));\n        return;\n      }\n      log.debug(\"creating new session for web3auth wallet connect\");\n      this.connector.on(\"display_uri\", async (err, payload) => {\n        var _this$connector2;\n        if (err) {\n          this.emit(ADAPTER_EVENTS.ERRORED, WalletLoginError.connectionError(\"Failed to display wallet connect qr code\"));\n          return reject(err);\n        }\n        const uri = payload.params[0];\n        this.updateAdapterData({\n          uri,\n          extensionAdapters: WALLET_CONNECT_EXTENSION_ADAPTERS\n        });\n        (_this$connector2 = this.connector) === null || _this$connector2 === void 0 ? void 0 : _this$connector2.off(\"display_uri\");\n        return resolve();\n      });\n      this.connector.createSession({\n        chainId: parseInt(((_this$chainConfig2 = this.chainConfig) === null || _this$chainConfig2 === void 0 ? void 0 : _this$chainConfig2.chainId) || \"0x1\", 16)\n      }).catch(error => {\n        log.error(\"error while creating new wallet connect session\", error);\n        this.emit(ADAPTER_EVENTS.ERRORED, error);\n        return reject(error);\n      });\n    });\n  }\n  async onConnectHandler(params) {\n    if (!this.connector || !this.wcProvider) throw WalletInitializationError.notReady(\"Wallet adapter is not ready yet\");\n    if (!this.chainConfig) throw WalletInitializationError.invalidParams(\"Chain config is not set\");\n    const {\n      chainId\n    } = params;\n    log.debug(\"connected chainId in hex\");\n    // This is to check if the connected wallet can return chainId\n    // in string or a number format.\n    let isDifferentChain = false;\n    if (typeof chainId === \"string\") {\n      isDifferentChain = chainId !== this.chainConfig.chainId;\n    } else if (typeof chainId === \"number\") {\n      isDifferentChain = chainId !== parseInt(this.chainConfig.chainId, 16);\n    }\n    if (isDifferentChain) {\n      var _this$adapterOptions$6, _this$adapterOptions2, _this$adapterOptions3;\n      const connectedChainConfig = getChainConfig(CHAIN_NAMESPACES.EIP155, chainId) || {\n        chainId: typeof chainId === \"number\" ? `0x${chainId.toString(16)}` : chainId,\n        displayName: \"Unknown Network\"\n      };\n      const isCustomUi = (_this$adapterOptions$6 = this.adapterOptions.adapterSettings) === null || _this$adapterOptions$6 === void 0 ? void 0 : _this$adapterOptions$6.qrcodeModal;\n      // skipping network is not allowed in default ui. We are use network switching modal for default ui.\n      if (!isCustomUi || isCustomUi && !((_this$adapterOptions2 = this.adapterOptions) !== null && _this$adapterOptions2 !== void 0 && (_this$adapterOptions3 = _this$adapterOptions2.adapterSettings) !== null && _this$adapterOptions3 !== void 0 && _this$adapterOptions3.skipNetworkSwitching)) {\n        try {\n          await this.addChain(this.chainConfig, true);\n          await this._switchChain(connectedChainConfig, this.chainConfig);\n          this.connector = this.getWalletConnectInstance();\n        } catch (error) {\n          log.error(\"error while chain switching\", error);\n          // we need to create a new session since old session is already used and\n          // user needs to login again with correct chain with new qr code.\n          await this.createNewSession({\n            forceNewSession: true\n          });\n          this.emit(ADAPTER_EVENTS.ERRORED, WalletInitializationError.fromCode(5000, `Not connected to correct network. Expected: ${this.chainConfig.displayName}, Current: ${(connectedChainConfig === null || connectedChainConfig === void 0 ? void 0 : connectedChainConfig.displayName) || chainId}, Please switch to correct network from wallet`));\n          this.status = ADAPTER_STATUS.READY;\n          this.rehydrated = true;\n          return;\n        }\n      }\n    }\n    await this.wcProvider.setupProvider(this.connector);\n    this.subscribeEvents(this.connector);\n    this.status = ADAPTER_STATUS.CONNECTED;\n    this.emit(ADAPTER_EVENTS.CONNECTED, {\n      adapter: WALLET_ADAPTERS.WALLET_CONNECT_V1,\n      reconnected: this.rehydrated\n    });\n  }\n  subscribeEvents(connector) {\n    connector.on(\"session_update\", async error => {\n      if (error) {\n        this.emit(ADAPTER_EVENTS.ERRORED, error);\n      }\n    });\n    connector.on(\"disconnect\", async (error, _) => {\n      if (error) {\n        this.emit(ADAPTER_EVENTS.ERRORED, error);\n      }\n      log.debug(\"disconnect event emitted by web3auth\");\n      await super.disconnect();\n      this.status = ADAPTER_EVENTS.READY;\n    });\n  }\n  getWalletConnectInstance() {\n    const walletConnectOptions = this.adapterOptions.adapterSettings || {};\n    walletConnectOptions.bridge = walletConnectOptions.bridge || \"https://bridge.walletconnect.org\";\n    // Create a connector\n    return new WalletConnect(walletConnectOptions);\n  }\n}\n\nexport { WalletConnectV1Adapter };\n//# sourceMappingURL=walletConnectV1Adapter.esm.js.map\n"]},"metadata":{},"sourceType":"module"}