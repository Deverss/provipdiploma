{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SHA2 = void 0;\n\nconst _assert_js_1 = require(\"./_assert.js\");\n\nconst utils_js_1 = require(\"./utils.js\"); // Polyfill for Safari 14\n\n\nfunction setBigUint64(view, byteOffset, value, isLE) {\n  if (typeof view.setBigUint64 === 'function') return view.setBigUint64(byteOffset, value, isLE);\n\n  const _32n = BigInt(32);\n\n  const _u32_max = BigInt(0xffffffff);\n\n  const wh = Number(value >> _32n & _u32_max);\n  const wl = Number(value & _u32_max);\n  const h = isLE ? 4 : 0;\n  const l = isLE ? 0 : 4;\n  view.setUint32(byteOffset + h, wh, isLE);\n  view.setUint32(byteOffset + l, wl, isLE);\n} // Base SHA2 class (RFC 6234)\n\n\nclass SHA2 extends utils_js_1.Hash {\n  constructor(blockLen, outputLen, padOffset, isLE) {\n    super();\n    this.blockLen = blockLen;\n    this.outputLen = outputLen;\n    this.padOffset = padOffset;\n    this.isLE = isLE;\n    this.finished = false;\n    this.length = 0;\n    this.pos = 0;\n    this.destroyed = false;\n    this.buffer = new Uint8Array(blockLen);\n    this.view = (0, utils_js_1.createView)(this.buffer);\n  }\n\n  update(data) {\n    _assert_js_1.default.exists(this);\n\n    const {\n      view,\n      buffer,\n      blockLen\n    } = this;\n    data = (0, utils_js_1.toBytes)(data);\n    const len = data.length;\n\n    for (let pos = 0; pos < len;) {\n      const take = Math.min(blockLen - this.pos, len - pos); // Fast path: we have at least one block in input, cast it to view and process\n\n      if (take === blockLen) {\n        const dataView = (0, utils_js_1.createView)(data);\n\n        for (; blockLen <= len - pos; pos += blockLen) this.process(dataView, pos);\n\n        continue;\n      }\n\n      buffer.set(data.subarray(pos, pos + take), this.pos);\n      this.pos += take;\n      pos += take;\n\n      if (this.pos === blockLen) {\n        this.process(view, 0);\n        this.pos = 0;\n      }\n    }\n\n    this.length += data.length;\n    this.roundClean();\n    return this;\n  }\n\n  digestInto(out) {\n    _assert_js_1.default.exists(this);\n\n    _assert_js_1.default.output(out, this);\n\n    this.finished = true; // Padding\n    // We can avoid allocation of buffer for padding completely if it\n    // was previously not allocated here. But it won't change performance.\n\n    const {\n      buffer,\n      view,\n      blockLen,\n      isLE\n    } = this;\n    let {\n      pos\n    } = this; // append the bit '1' to the message\n\n    buffer[pos++] = 0b10000000;\n    this.buffer.subarray(pos).fill(0); // we have less than padOffset left in buffer, so we cannot put length in current block, need process it and pad again\n\n    if (this.padOffset > blockLen - pos) {\n      this.process(view, 0);\n      pos = 0;\n    } // Pad until full block byte with zeros\n\n\n    for (let i = pos; i < blockLen; i++) buffer[i] = 0; // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n    // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n    // So we just write lowest 64 bits of that value.\n\n\n    setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\n    this.process(view, 0);\n    const oview = (0, utils_js_1.createView)(out);\n    const len = this.outputLen; // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT\n\n    if (len % 4) throw new Error('_sha2: outputLen should be aligned to 32bit');\n    const outLen = len / 4;\n    const state = this.get();\n    if (outLen > state.length) throw new Error('_sha2: outputLen bigger than state');\n\n    for (let i = 0; i < outLen; i++) oview.setUint32(4 * i, state[i], isLE);\n  }\n\n  digest() {\n    const {\n      buffer,\n      outputLen\n    } = this;\n    this.digestInto(buffer);\n    const res = buffer.slice(0, outputLen);\n    this.destroy();\n    return res;\n  }\n\n  _cloneInto(to) {\n    to || (to = new this.constructor());\n    to.set(...this.get());\n    const {\n      blockLen,\n      buffer,\n      length,\n      finished,\n      destroyed,\n      pos\n    } = this;\n    to.length = length;\n    to.pos = pos;\n    to.finished = finished;\n    to.destroyed = destroyed;\n    if (length % blockLen) to.buffer.set(buffer);\n    return to;\n  }\n\n}\n\nexports.SHA2 = SHA2;","map":{"version":3,"sources":["src/_sha2.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SHA2 = void 0;\nconst _assert_js_1 = require(\"./_assert.js\");\nconst utils_js_1 = require(\"./utils.js\");\n// Polyfill for Safari 14\nfunction setBigUint64(view, byteOffset, value, isLE) {\n    if (typeof view.setBigUint64 === 'function')\n        return view.setBigUint64(byteOffset, value, isLE);\n    const _32n = BigInt(32);\n    const _u32_max = BigInt(0xffffffff);\n    const wh = Number((value >> _32n) & _u32_max);\n    const wl = Number(value & _u32_max);\n    const h = isLE ? 4 : 0;\n    const l = isLE ? 0 : 4;\n    view.setUint32(byteOffset + h, wh, isLE);\n    view.setUint32(byteOffset + l, wl, isLE);\n}\n// Base SHA2 class (RFC 6234)\nclass SHA2 extends utils_js_1.Hash {\n    constructor(blockLen, outputLen, padOffset, isLE) {\n        super();\n        this.blockLen = blockLen;\n        this.outputLen = outputLen;\n        this.padOffset = padOffset;\n        this.isLE = isLE;\n        this.finished = false;\n        this.length = 0;\n        this.pos = 0;\n        this.destroyed = false;\n        this.buffer = new Uint8Array(blockLen);\n        this.view = (0, utils_js_1.createView)(this.buffer);\n    }\n    update(data) {\n        _assert_js_1.default.exists(this);\n        const { view, buffer, blockLen } = this;\n        data = (0, utils_js_1.toBytes)(data);\n        const len = data.length;\n        for (let pos = 0; pos < len;) {\n            const take = Math.min(blockLen - this.pos, len - pos);\n            // Fast path: we have at least one block in input, cast it to view and process\n            if (take === blockLen) {\n                const dataView = (0, utils_js_1.createView)(data);\n                for (; blockLen <= len - pos; pos += blockLen)\n                    this.process(dataView, pos);\n                continue;\n            }\n            buffer.set(data.subarray(pos, pos + take), this.pos);\n            this.pos += take;\n            pos += take;\n            if (this.pos === blockLen) {\n                this.process(view, 0);\n                this.pos = 0;\n            }\n        }\n        this.length += data.length;\n        this.roundClean();\n        return this;\n    }\n    digestInto(out) {\n        _assert_js_1.default.exists(this);\n        _assert_js_1.default.output(out, this);\n        this.finished = true;\n        // Padding\n        // We can avoid allocation of buffer for padding completely if it\n        // was previously not allocated here. But it won't change performance.\n        const { buffer, view, blockLen, isLE } = this;\n        let { pos } = this;\n        // append the bit '1' to the message\n        buffer[pos++] = 0b10000000;\n        this.buffer.subarray(pos).fill(0);\n        // we have less than padOffset left in buffer, so we cannot put length in current block, need process it and pad again\n        if (this.padOffset > blockLen - pos) {\n            this.process(view, 0);\n            pos = 0;\n        }\n        // Pad until full block byte with zeros\n        for (let i = pos; i < blockLen; i++)\n            buffer[i] = 0;\n        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n        // So we just write lowest 64 bits of that value.\n        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\n        this.process(view, 0);\n        const oview = (0, utils_js_1.createView)(out);\n        const len = this.outputLen;\n        // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT\n        if (len % 4)\n            throw new Error('_sha2: outputLen should be aligned to 32bit');\n        const outLen = len / 4;\n        const state = this.get();\n        if (outLen > state.length)\n            throw new Error('_sha2: outputLen bigger than state');\n        for (let i = 0; i < outLen; i++)\n            oview.setUint32(4 * i, state[i], isLE);\n    }\n    digest() {\n        const { buffer, outputLen } = this;\n        this.digestInto(buffer);\n        const res = buffer.slice(0, outputLen);\n        this.destroy();\n        return res;\n    }\n    _cloneInto(to) {\n        to || (to = new this.constructor());\n        to.set(...this.get());\n        const { blockLen, buffer, length, finished, destroyed, pos } = this;\n        to.length = length;\n        to.pos = pos;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        if (length % blockLen)\n            to.buffer.set(buffer);\n        return to;\n    }\n}\nexports.SHA2 = SHA2;\n//# sourceMappingURL=_sha2.js.map"]},"metadata":{},"sourceType":"script"}