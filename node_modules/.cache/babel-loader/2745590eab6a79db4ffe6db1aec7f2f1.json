{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.BitVectorType = void 0;\n\nconst persistent_merkle_tree_1 = require(\"@chainsafe/persistent-merkle-tree\");\n\nconst merkleize_1 = require(\"../util/merkleize\");\n\nconst named_1 = require(\"../util/named\");\n\nconst bitArray_1 = require(\"../value/bitArray\");\n\nconst bitArray_2 = require(\"./bitArray\");\n/**\n * BitVector: ordered fixed-length collection of boolean values, with N bits\n * - Notation: `Bitvector[N]`\n * - Value: `BitArray`, @see BitArray for a justification of its memory efficiency and performance\n * - View: `BitArrayTreeView`\n * - ViewDU: `BitArrayTreeViewDU`\n */\n\n\nclass BitVectorType extends bitArray_2.BitArrayType {\n  constructor(lengthBits, opts) {\n    super();\n    this.lengthBits = lengthBits;\n    this.isList = false;\n    if (lengthBits === 0) throw Error(\"Vector length must be > 0\");\n    this.typeName = (opts === null || opts === void 0 ? void 0 : opts.typeName) ?? `BitVector[${lengthBits}]`;\n    this.chunkCount = Math.ceil(this.lengthBits / 8 / 32);\n    this.maxChunkCount = this.chunkCount;\n    this.depth = merkleize_1.maxChunksToDepth(this.chunkCount);\n    this.fixedSize = Math.ceil(this.lengthBits / 8);\n    this.minSize = this.fixedSize;\n    this.maxSize = this.fixedSize; // To cache mask for trailing zero bits validation\n\n    this.zeroBitsMask = lengthBits % 8 === 0 ? 0 : 0xff & 0xff << lengthBits % 8;\n  }\n\n  static named(limitBits, opts) {\n    return new (named_1.namedClass(BitVectorType, opts.typeName))(limitBits, opts);\n  }\n\n  defaultValue() {\n    return bitArray_1.BitArray.fromBitLen(this.lengthBits);\n  } // Views: inherited from BitArrayType\n  // Serialization + deserialization\n\n\n  value_serializedSize() {\n    return this.fixedSize;\n  }\n\n  value_serializeToBytes(output, offset, value) {\n    output.uint8Array.set(value.uint8Array, offset);\n    return offset + this.fixedSize;\n  }\n\n  value_deserializeFromBytes(data, start, end) {\n    this.assertValidLength(data.uint8Array, start, end); // Buffer.prototype.slice does not copy memory, Enforce Uint8Array usage https://github.com/nodejs/node/issues/28087\n\n    return new bitArray_1.BitArray(Uint8Array.prototype.slice.call(data.uint8Array, start, end), this.lengthBits);\n  }\n\n  tree_serializedSize() {\n    return this.fixedSize;\n  }\n\n  tree_serializeToBytes(output, offset, node) {\n    const nodes = persistent_merkle_tree_1.getNodesAtDepth(node, this.depth, 0, this.chunkCount);\n    persistent_merkle_tree_1.packedNodeRootsToBytes(output.dataView, offset, this.fixedSize, nodes);\n    return offset + this.fixedSize;\n  }\n\n  tree_deserializeFromBytes(data, start, end) {\n    this.assertValidLength(data.uint8Array, start, end);\n    return persistent_merkle_tree_1.packedRootsBytesToNode(this.depth, data.dataView, start, end);\n  }\n\n  tree_getByteLen() {\n    return this.fixedSize;\n  } // Merkleization: inherited from BitArrayType\n  // Proofs: inherited from BitArrayType\n  // JSON: inherited from BitArrayType\n  // Deserializer helpers\n\n\n  assertValidLength(data, start, end) {\n    const size = end - start;\n\n    if (end - start !== this.fixedSize) {\n      throw Error(`Invalid BitVector size ${size} != ${this.fixedSize}`);\n    } // If lengthBits is not aligned to bytes, ensure trailing bits are zeroed\n\n\n    if ( // If zeroBitsMask == 0, then the BitVector uses full bytes only\n    this.zeroBitsMask > 0 && // if the last byte is partial, retrieve it and use the cached mask to check if trailing bits are zeroed\n    (data[end - 1] & this.zeroBitsMask) > 0) {\n      throw Error(\"BitVector: nonzero bits past length\");\n    }\n  }\n\n}\n\nexports.BitVectorType = BitVectorType;","map":{"version":3,"sources":["../../src/type/bitVector.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BitVectorType = void 0;\nconst persistent_merkle_tree_1 = require(\"@chainsafe/persistent-merkle-tree\");\nconst merkleize_1 = require(\"../util/merkleize\");\nconst named_1 = require(\"../util/named\");\nconst bitArray_1 = require(\"../value/bitArray\");\nconst bitArray_2 = require(\"./bitArray\");\n/**\n * BitVector: ordered fixed-length collection of boolean values, with N bits\n * - Notation: `Bitvector[N]`\n * - Value: `BitArray`, @see BitArray for a justification of its memory efficiency and performance\n * - View: `BitArrayTreeView`\n * - ViewDU: `BitArrayTreeViewDU`\n */\nclass BitVectorType extends bitArray_2.BitArrayType {\n    constructor(lengthBits, opts) {\n        super();\n        this.lengthBits = lengthBits;\n        this.isList = false;\n        if (lengthBits === 0)\n            throw Error(\"Vector length must be > 0\");\n        this.typeName = opts?.typeName ?? `BitVector[${lengthBits}]`;\n        this.chunkCount = Math.ceil(this.lengthBits / 8 / 32);\n        this.maxChunkCount = this.chunkCount;\n        this.depth = merkleize_1.maxChunksToDepth(this.chunkCount);\n        this.fixedSize = Math.ceil(this.lengthBits / 8);\n        this.minSize = this.fixedSize;\n        this.maxSize = this.fixedSize;\n        // To cache mask for trailing zero bits validation\n        this.zeroBitsMask = lengthBits % 8 === 0 ? 0 : 0xff & (0xff << lengthBits % 8);\n    }\n    static named(limitBits, opts) {\n        return new (named_1.namedClass(BitVectorType, opts.typeName))(limitBits, opts);\n    }\n    defaultValue() {\n        return bitArray_1.BitArray.fromBitLen(this.lengthBits);\n    }\n    // Views: inherited from BitArrayType\n    // Serialization + deserialization\n    value_serializedSize() {\n        return this.fixedSize;\n    }\n    value_serializeToBytes(output, offset, value) {\n        output.uint8Array.set(value.uint8Array, offset);\n        return offset + this.fixedSize;\n    }\n    value_deserializeFromBytes(data, start, end) {\n        this.assertValidLength(data.uint8Array, start, end);\n        // Buffer.prototype.slice does not copy memory, Enforce Uint8Array usage https://github.com/nodejs/node/issues/28087\n        return new bitArray_1.BitArray(Uint8Array.prototype.slice.call(data.uint8Array, start, end), this.lengthBits);\n    }\n    tree_serializedSize() {\n        return this.fixedSize;\n    }\n    tree_serializeToBytes(output, offset, node) {\n        const nodes = persistent_merkle_tree_1.getNodesAtDepth(node, this.depth, 0, this.chunkCount);\n        persistent_merkle_tree_1.packedNodeRootsToBytes(output.dataView, offset, this.fixedSize, nodes);\n        return offset + this.fixedSize;\n    }\n    tree_deserializeFromBytes(data, start, end) {\n        this.assertValidLength(data.uint8Array, start, end);\n        return persistent_merkle_tree_1.packedRootsBytesToNode(this.depth, data.dataView, start, end);\n    }\n    tree_getByteLen() {\n        return this.fixedSize;\n    }\n    // Merkleization: inherited from BitArrayType\n    // Proofs: inherited from BitArrayType\n    // JSON: inherited from BitArrayType\n    // Deserializer helpers\n    assertValidLength(data, start, end) {\n        const size = end - start;\n        if (end - start !== this.fixedSize) {\n            throw Error(`Invalid BitVector size ${size} != ${this.fixedSize}`);\n        }\n        // If lengthBits is not aligned to bytes, ensure trailing bits are zeroed\n        if (\n        // If zeroBitsMask == 0, then the BitVector uses full bytes only\n        this.zeroBitsMask > 0 &&\n            // if the last byte is partial, retrieve it and use the cached mask to check if trailing bits are zeroed\n            (data[end - 1] & this.zeroBitsMask) > 0) {\n            throw Error(\"BitVector: nonzero bits past length\");\n        }\n    }\n}\nexports.BitVectorType = BitVectorType;\n//# sourceMappingURL=bitVector.js.map"]},"metadata":{},"sourceType":"script"}