{"ast":null,"code":"import _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport { WALLET_ADAPTERS, ADAPTER_NAMESPACES, CHAIN_NAMESPACES, ADAPTER_CATEGORY, ADAPTER_STATUS, ADAPTER_EVENTS, WalletInitializationError, log, Web3AuthError, WalletLoginError } from '@web3auth/base';\nimport { BaseSolanaAdapter } from '@web3auth/base-solana-adapter';\nimport { PhantomInjectedProvider } from '@web3auth/solana-provider';\n\nfunction poll(callback, interval, count) {\n  return new Promise((resolve, reject) => {\n    if (count > 0) {\n      setTimeout(async () => {\n        const done = await callback();\n        if (done) resolve(done);\n        if (!done) poll(callback, interval, count - 1).then(res => {\n          resolve(res);\n          return res;\n        }).catch(err => reject(err));\n      }, interval);\n    } else {\n      resolve(false);\n    }\n  });\n}\n\nconst detectProvider = async function () {\n  var _window$solana;\n\n  let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n    interval: 1000,\n    count: 3\n  };\n  const isPhantomAvailable = typeof window !== \"undefined\" && !!((_window$solana = window.solana) !== null && _window$solana !== void 0 && _window$solana.isPhantom);\n\n  if (isPhantomAvailable) {\n    return window.solana;\n  }\n\n  const isAvailable = await poll(() => {\n    var _window$solana2;\n\n    return (_window$solana2 = window.solana) === null || _window$solana2 === void 0 ? void 0 : _window$solana2.isPhantom;\n  }, options.interval, options.count);\n  if (isAvailable) return window.solana;\n  return null;\n};\n\nclass PhantomAdapter extends BaseSolanaAdapter {\n  constructor() {\n    super(...arguments);\n\n    _defineProperty(this, \"name\", WALLET_ADAPTERS.PHANTOM);\n\n    _defineProperty(this, \"adapterNamespace\", ADAPTER_NAMESPACES.SOLANA);\n\n    _defineProperty(this, \"currentChainNamespace\", CHAIN_NAMESPACES.SOLANA);\n\n    _defineProperty(this, \"type\", ADAPTER_CATEGORY.EXTERNAL);\n\n    _defineProperty(this, \"status\", ADAPTER_STATUS.NOT_READY);\n\n    _defineProperty(this, \"_wallet\", null);\n\n    _defineProperty(this, \"phantomProvider\", null);\n\n    _defineProperty(this, \"_onDisconnect\", () => {\n      if (this._wallet) {\n        this._wallet.off(\"disconnect\", this._onDisconnect);\n\n        this.rehydrated = false; // ready to be connected again only if it was previously connected and not cleaned up\n\n        this.status = this.status === ADAPTER_STATUS.CONNECTED ? ADAPTER_STATUS.READY : ADAPTER_STATUS.NOT_READY;\n        this.emit(ADAPTER_EVENTS.DISCONNECTED);\n      }\n    });\n  }\n\n  get isWalletConnected() {\n    var _this$_wallet;\n\n    return !!((_this$_wallet = this._wallet) !== null && _this$_wallet !== void 0 && _this$_wallet.isConnected && this.status === ADAPTER_STATUS.CONNECTED);\n  }\n\n  get provider() {\n    var _this$phantomProvider;\n\n    return ((_this$phantomProvider = this.phantomProvider) === null || _this$phantomProvider === void 0 ? void 0 : _this$phantomProvider.provider) || null;\n  }\n\n  set provider(_) {\n    throw new Error(\"Not implemented\");\n  }\n\n  async init() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    await super.init(options);\n    super.checkInitializationRequirements();\n    this._wallet = await detectProvider({\n      interval: 500,\n      count: 3\n    });\n    if (!this._wallet) throw WalletInitializationError.notInstalled();\n    this.phantomProvider = new PhantomInjectedProvider({\n      config: {\n        chainConfig: this.chainConfig\n      }\n    });\n    this.status = ADAPTER_STATUS.READY;\n    this.emit(ADAPTER_EVENTS.READY, WALLET_ADAPTERS.PHANTOM);\n\n    try {\n      log.debug(\"initializing phantom adapter\");\n\n      if (options.autoConnect) {\n        this.rehydrated = true;\n        await this.connect();\n      }\n    } catch (error) {\n      log.error(\"Failed to connect with cached phantom provider\", error);\n      this.emit(\"ERRORED\", error);\n    }\n  }\n\n  async connect() {\n    var _this = this;\n\n    try {\n      super.checkConnectionRequirements();\n      this.status = ADAPTER_STATUS.CONNECTING;\n      this.emit(ADAPTER_EVENTS.CONNECTING, {\n        adapter: WALLET_ADAPTERS.PHANTOM\n      });\n      if (!this._wallet) throw WalletInitializationError.notInstalled();\n\n      if (!this._wallet.isConnected) {\n        const handleDisconnect = this._wallet._handleDisconnect;\n\n        try {\n          await new Promise((resolve, reject) => {\n            const connect = async () => {\n              await this.connectWithProvider(this._wallet);\n              resolve(this.provider);\n            };\n\n            if (!this._wallet) {\n              reject(WalletInitializationError.notInstalled());\n              return;\n            }\n\n            this._wallet.once(\"connect\", connect); // Raise an issue on phantom that if window is closed, disconnect event is not fired\n\n\n            this._wallet._handleDisconnect = function () {\n              reject(WalletInitializationError.windowClosed());\n\n              for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n                args[_key] = arguments[_key];\n              }\n\n              return handleDisconnect.apply(_this._wallet, args);\n            };\n\n            this._wallet.connect().catch(reason => {\n              reject(reason);\n            });\n          });\n        } catch (error) {\n          if (error instanceof Web3AuthError) throw error;\n          throw WalletLoginError.connectionError(error === null || error === void 0 ? void 0 : error.message);\n        } finally {\n          this._wallet._handleDisconnect = handleDisconnect;\n        }\n      } else {\n        await this.connectWithProvider(this._wallet);\n      }\n\n      if (!this._wallet.publicKey) throw WalletLoginError.connectionError();\n\n      this._wallet.on(\"disconnect\", this._onDisconnect);\n\n      return this.provider;\n    } catch (error) {\n      // ready again to be connected\n      this.status = ADAPTER_STATUS.READY;\n      this.rehydrated = false;\n      this.emit(ADAPTER_EVENTS.ERRORED, error);\n      throw error;\n    }\n  }\n\n  async disconnect() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n      cleanup: false\n    };\n    await super.disconnectSession();\n\n    try {\n      var _this$_wallet2;\n\n      await ((_this$_wallet2 = this._wallet) === null || _this$_wallet2 === void 0 ? void 0 : _this$_wallet2.disconnect());\n\n      if (options.cleanup) {\n        this.status = ADAPTER_STATUS.NOT_READY;\n        this.phantomProvider = null;\n        this._wallet = null;\n      }\n\n      await super.disconnect();\n    } catch (error) {\n      this.emit(ADAPTER_EVENTS.ERRORED, WalletLoginError.disconnectionError(error === null || error === void 0 ? void 0 : error.message));\n    }\n  }\n\n  async getUserInfo() {\n    if (!this.isWalletConnected) throw WalletLoginError.notConnectedError(\"Not connected with wallet, Please login/connect first\");\n    return {};\n  }\n\n  async addChain(chainConfig) {\n    var _this$phantomProvider2;\n\n    let init = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    super.checkAddChainRequirements(init);\n    (_this$phantomProvider2 = this.phantomProvider) === null || _this$phantomProvider2 === void 0 ? void 0 : _this$phantomProvider2.addChain(chainConfig);\n    this.addChainConfig(chainConfig);\n  }\n\n  async switchChain(params) {\n    var _this$phantomProvider3;\n\n    let init = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    super.checkSwitchChainRequirements(params, init);\n    await ((_this$phantomProvider3 = this.phantomProvider) === null || _this$phantomProvider3 === void 0 ? void 0 : _this$phantomProvider3.switchChain(params));\n    this.setAdapterSettings({\n      chainConfig: this.getChainConfig(params.chainId)\n    });\n  }\n\n  async connectWithProvider(injectedProvider) {\n    if (!this.phantomProvider) throw WalletLoginError.connectionError(\"No phantom provider\");\n    await this.phantomProvider.setupProvider(injectedProvider);\n    this.status = ADAPTER_STATUS.CONNECTED;\n    this.emit(ADAPTER_EVENTS.CONNECTED, {\n      adapter: WALLET_ADAPTERS.PHANTOM,\n      reconnected: this.rehydrated\n    });\n    return this.provider;\n  }\n\n}\n\nexport { PhantomAdapter };","map":{"version":3,"sources":["../src/utils.ts","../src/phantomAdapter.ts"],"names":["poll","callback","interval","count","Promise","resolve","reject","setTimeout","done","then","res","catch","err","detectProvider","options","isPhantomAvailable","window","solana","isPhantom","isAvailable","PhantomAdapter","BaseSolanaAdapter","WALLET_ADAPTERS","PHANTOM","_defineProperty","ADAPTER_NAMESPACES","SOLANA","CHAIN_NAMESPACES","ADAPTER_CATEGORY","EXTERNAL","ADAPTER_STATUS","NOT_READY","isWalletConnected","_wallet","isConnected","status","CONNECTED","provider","phantomProvider","_","Error","init","checkInitializationRequirements","WalletInitializationError","notInstalled","PhantomInjectedProvider","config","chainConfig","READY","emit","ADAPTER_EVENTS","log","debug","autoConnect","rehydrated","connect","error","checkConnectionRequirements","CONNECTING","adapter","handleDisconnect","_handleDisconnect","connectWithProvider","once","args","windowClosed","apply","_this","reason","Web3AuthError","WalletLoginError","connectionError","message","publicKey","on","_onDisconnect","ERRORED","disconnect","cleanup","disconnectSession","disconnectionError","getUserInfo","notConnectedError","addChain","checkAddChainRequirements","addChainConfig","switchChain","params","checkSwitchChainRequirements","setAdapterSettings","getChainConfig","chainId","injectedProvider","setupProvider","reconnected","off","DISCONNECTED"],"mappings":"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","sourcesContent":["import _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport { WALLET_ADAPTERS, ADAPTER_NAMESPACES, CHAIN_NAMESPACES, ADAPTER_CATEGORY, ADAPTER_STATUS, ADAPTER_EVENTS, WalletInitializationError, log, Web3AuthError, WalletLoginError } from '@web3auth/base';\nimport { BaseSolanaAdapter } from '@web3auth/base-solana-adapter';\nimport { PhantomInjectedProvider } from '@web3auth/solana-provider';\n\nfunction poll(callback, interval, count) {\n  return new Promise((resolve, reject) => {\n    if (count > 0) {\n      setTimeout(async () => {\n        const done = await callback();\n        if (done) resolve(done);\n        if (!done) poll(callback, interval, count - 1).then(res => {\n          resolve(res);\n          return res;\n        }).catch(err => reject(err));\n      }, interval);\n    } else {\n      resolve(false);\n    }\n  });\n}\nconst detectProvider = async function () {\n  var _window$solana;\n  let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n    interval: 1000,\n    count: 3\n  };\n  const isPhantomAvailable = typeof window !== \"undefined\" && !!((_window$solana = window.solana) !== null && _window$solana !== void 0 && _window$solana.isPhantom);\n  if (isPhantomAvailable) {\n    return window.solana;\n  }\n  const isAvailable = await poll(() => {\n    var _window$solana2;\n    return (_window$solana2 = window.solana) === null || _window$solana2 === void 0 ? void 0 : _window$solana2.isPhantom;\n  }, options.interval, options.count);\n  if (isAvailable) return window.solana;\n  return null;\n};\n\nclass PhantomAdapter extends BaseSolanaAdapter {\n  constructor() {\n    super(...arguments);\n    _defineProperty(this, \"name\", WALLET_ADAPTERS.PHANTOM);\n    _defineProperty(this, \"adapterNamespace\", ADAPTER_NAMESPACES.SOLANA);\n    _defineProperty(this, \"currentChainNamespace\", CHAIN_NAMESPACES.SOLANA);\n    _defineProperty(this, \"type\", ADAPTER_CATEGORY.EXTERNAL);\n    _defineProperty(this, \"status\", ADAPTER_STATUS.NOT_READY);\n    _defineProperty(this, \"_wallet\", null);\n    _defineProperty(this, \"phantomProvider\", null);\n    _defineProperty(this, \"_onDisconnect\", () => {\n      if (this._wallet) {\n        this._wallet.off(\"disconnect\", this._onDisconnect);\n        this.rehydrated = false;\n        // ready to be connected again only if it was previously connected and not cleaned up\n        this.status = this.status === ADAPTER_STATUS.CONNECTED ? ADAPTER_STATUS.READY : ADAPTER_STATUS.NOT_READY;\n        this.emit(ADAPTER_EVENTS.DISCONNECTED);\n      }\n    });\n  }\n  get isWalletConnected() {\n    var _this$_wallet;\n    return !!((_this$_wallet = this._wallet) !== null && _this$_wallet !== void 0 && _this$_wallet.isConnected && this.status === ADAPTER_STATUS.CONNECTED);\n  }\n  get provider() {\n    var _this$phantomProvider;\n    return ((_this$phantomProvider = this.phantomProvider) === null || _this$phantomProvider === void 0 ? void 0 : _this$phantomProvider.provider) || null;\n  }\n  set provider(_) {\n    throw new Error(\"Not implemented\");\n  }\n  async init() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    await super.init(options);\n    super.checkInitializationRequirements();\n    this._wallet = await detectProvider({\n      interval: 500,\n      count: 3\n    });\n    if (!this._wallet) throw WalletInitializationError.notInstalled();\n    this.phantomProvider = new PhantomInjectedProvider({\n      config: {\n        chainConfig: this.chainConfig\n      }\n    });\n    this.status = ADAPTER_STATUS.READY;\n    this.emit(ADAPTER_EVENTS.READY, WALLET_ADAPTERS.PHANTOM);\n    try {\n      log.debug(\"initializing phantom adapter\");\n      if (options.autoConnect) {\n        this.rehydrated = true;\n        await this.connect();\n      }\n    } catch (error) {\n      log.error(\"Failed to connect with cached phantom provider\", error);\n      this.emit(\"ERRORED\", error);\n    }\n  }\n  async connect() {\n    var _this = this;\n    try {\n      super.checkConnectionRequirements();\n      this.status = ADAPTER_STATUS.CONNECTING;\n      this.emit(ADAPTER_EVENTS.CONNECTING, {\n        adapter: WALLET_ADAPTERS.PHANTOM\n      });\n      if (!this._wallet) throw WalletInitializationError.notInstalled();\n      if (!this._wallet.isConnected) {\n        const handleDisconnect = this._wallet._handleDisconnect;\n        try {\n          await new Promise((resolve, reject) => {\n            const connect = async () => {\n              await this.connectWithProvider(this._wallet);\n              resolve(this.provider);\n            };\n            if (!this._wallet) {\n              reject(WalletInitializationError.notInstalled());\n              return;\n            }\n            this._wallet.once(\"connect\", connect);\n            // Raise an issue on phantom that if window is closed, disconnect event is not fired\n            this._wallet._handleDisconnect = function () {\n              reject(WalletInitializationError.windowClosed());\n              for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n                args[_key] = arguments[_key];\n              }\n              return handleDisconnect.apply(_this._wallet, args);\n            };\n            this._wallet.connect().catch(reason => {\n              reject(reason);\n            });\n          });\n        } catch (error) {\n          if (error instanceof Web3AuthError) throw error;\n          throw WalletLoginError.connectionError(error === null || error === void 0 ? void 0 : error.message);\n        } finally {\n          this._wallet._handleDisconnect = handleDisconnect;\n        }\n      } else {\n        await this.connectWithProvider(this._wallet);\n      }\n      if (!this._wallet.publicKey) throw WalletLoginError.connectionError();\n      this._wallet.on(\"disconnect\", this._onDisconnect);\n      return this.provider;\n    } catch (error) {\n      // ready again to be connected\n      this.status = ADAPTER_STATUS.READY;\n      this.rehydrated = false;\n      this.emit(ADAPTER_EVENTS.ERRORED, error);\n      throw error;\n    }\n  }\n  async disconnect() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n      cleanup: false\n    };\n    await super.disconnectSession();\n    try {\n      var _this$_wallet2;\n      await ((_this$_wallet2 = this._wallet) === null || _this$_wallet2 === void 0 ? void 0 : _this$_wallet2.disconnect());\n      if (options.cleanup) {\n        this.status = ADAPTER_STATUS.NOT_READY;\n        this.phantomProvider = null;\n        this._wallet = null;\n      }\n      await super.disconnect();\n    } catch (error) {\n      this.emit(ADAPTER_EVENTS.ERRORED, WalletLoginError.disconnectionError(error === null || error === void 0 ? void 0 : error.message));\n    }\n  }\n  async getUserInfo() {\n    if (!this.isWalletConnected) throw WalletLoginError.notConnectedError(\"Not connected with wallet, Please login/connect first\");\n    return {};\n  }\n  async addChain(chainConfig) {\n    var _this$phantomProvider2;\n    let init = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    super.checkAddChainRequirements(init);\n    (_this$phantomProvider2 = this.phantomProvider) === null || _this$phantomProvider2 === void 0 ? void 0 : _this$phantomProvider2.addChain(chainConfig);\n    this.addChainConfig(chainConfig);\n  }\n  async switchChain(params) {\n    var _this$phantomProvider3;\n    let init = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    super.checkSwitchChainRequirements(params, init);\n    await ((_this$phantomProvider3 = this.phantomProvider) === null || _this$phantomProvider3 === void 0 ? void 0 : _this$phantomProvider3.switchChain(params));\n    this.setAdapterSettings({\n      chainConfig: this.getChainConfig(params.chainId)\n    });\n  }\n  async connectWithProvider(injectedProvider) {\n    if (!this.phantomProvider) throw WalletLoginError.connectionError(\"No phantom provider\");\n    await this.phantomProvider.setupProvider(injectedProvider);\n    this.status = ADAPTER_STATUS.CONNECTED;\n    this.emit(ADAPTER_EVENTS.CONNECTED, {\n      adapter: WALLET_ADAPTERS.PHANTOM,\n      reconnected: this.rehydrated\n    });\n    return this.provider;\n  }\n}\n\nexport { PhantomAdapter };\n//# sourceMappingURL=phantomAdapter.esm.js.map\n"]},"metadata":{},"sourceType":"module"}