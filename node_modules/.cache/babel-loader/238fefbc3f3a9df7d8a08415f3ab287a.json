{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ArrayType = void 0;\n\nconst persistent_merkle_tree_1 = require(\"@chainsafe/persistent-merkle-tree\");\n\nconst composite_1 = require(\"./composite\");\n\nconst arrayBasic_1 = require(\"./arrayBasic\");\n/* eslint-disable @typescript-eslint/member-ordering */\n\n/**\n * Array: ordered homogeneous collection\n */\n\n\nclass ArrayType extends composite_1.CompositeType {\n  constructor(elementType) {\n    super();\n    this.elementType = elementType;\n  }\n\n  defaultValue() {\n    return arrayBasic_1.value_defaultValueArray(this.elementType, this.defaultLen);\n  } // Proofs\n\n\n  getPropertyType() {\n    return this.elementType;\n  }\n\n  getPropertyGindex(prop) {\n    if (typeof prop !== \"number\") {\n      throw Error(`Invalid array index: ${prop}`);\n    }\n\n    const chunkIdx = Math.floor(prop / this.itemsPerChunk);\n    return persistent_merkle_tree_1.toGindex(this.depth, BigInt(chunkIdx));\n  }\n\n  getIndexProperty(index) {\n    return index;\n  }\n\n  tree_getLeafGindices(rootGindex, rootNode) {\n    let length;\n\n    if (this.isList) {\n      if (!rootNode) {\n        throw new Error(\"List type requires tree argument to get leaves\");\n      }\n\n      length = this.tree_getLength(rootNode);\n    } else {\n      // Vectors don't need a rootNode to return length\n      length = this.tree_getLength(null);\n    }\n\n    const gindices = [];\n\n    if (composite_1.isCompositeType(this.elementType)) {\n      // Underlying elements exist one per chunk\n      // Iterate through chunk gindices, recursively fetching leaf gindices from each chunk\n      const startIndex = persistent_merkle_tree_1.toGindex(this.depth, BigInt(0));\n      const endGindex = startIndex + BigInt(length);\n      const extendedStartIndex = persistent_merkle_tree_1.concatGindices([rootGindex, startIndex]);\n\n      if (this.elementType.fixedSize === null) {\n        if (!rootNode) {\n          /* istanbul ignore next - unreachable code */\n          throw new Error(\"Array of variable size requires tree argument to get leaves\");\n        } // variable-length elements must pass the underlying subtrees to determine the length\n\n\n        for (let gindex = startIndex, extendedGindex = extendedStartIndex; gindex < endGindex; gindex++, extendedGindex++) {\n          gindices.push(...this.elementType.tree_getLeafGindices(extendedGindex, persistent_merkle_tree_1.getNode(rootNode, gindex)));\n        }\n      } else {\n        for (let i = 0, extendedGindex = extendedStartIndex; i < length; i++, extendedGindex++) {\n          gindices.push(...this.elementType.tree_getLeafGindices(extendedGindex));\n        }\n      }\n    } // Basic\n    else {\n        const chunkCount = Math.ceil(length / this.itemsPerChunk);\n        const startIndex = persistent_merkle_tree_1.concatGindices([rootGindex, persistent_merkle_tree_1.toGindex(this.depth, BigInt(0))]);\n        const endGindex = startIndex + BigInt(chunkCount);\n\n        for (let gindex = startIndex; gindex < endGindex; gindex++) {\n          gindices.push(gindex);\n        }\n      } // include the length chunk\n\n\n    if (this.isList) {\n      gindices.push(persistent_merkle_tree_1.concatGindices([rootGindex, composite_1.LENGTH_GINDEX]));\n    }\n\n    return gindices;\n  } // JSON\n\n\n  fromJson(json) {\n    // TODO: Do a better typesafe approach, all final classes of ArrayType implement ArrayProps\n    // There are multiple tests that cover this path for all clases\n    return arrayBasic_1.value_fromJsonArray(this.elementType, json, this);\n  }\n\n  toJson(value) {\n    return arrayBasic_1.value_toJsonArray(this.elementType, value, this);\n  }\n\n  clone(value) {\n    return arrayBasic_1.value_cloneArray(this.elementType, value);\n  }\n\n  equals(a, b) {\n    return arrayBasic_1.value_equals(this.elementType, a, b);\n  }\n\n}\n\nexports.ArrayType = ArrayType;","map":{"version":3,"sources":["../../src/type/array.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ArrayType = void 0;\nconst persistent_merkle_tree_1 = require(\"@chainsafe/persistent-merkle-tree\");\nconst composite_1 = require(\"./composite\");\nconst arrayBasic_1 = require(\"./arrayBasic\");\n/* eslint-disable @typescript-eslint/member-ordering */\n/**\n * Array: ordered homogeneous collection\n */\nclass ArrayType extends composite_1.CompositeType {\n    constructor(elementType) {\n        super();\n        this.elementType = elementType;\n    }\n    defaultValue() {\n        return arrayBasic_1.value_defaultValueArray(this.elementType, this.defaultLen);\n    }\n    // Proofs\n    getPropertyType() {\n        return this.elementType;\n    }\n    getPropertyGindex(prop) {\n        if (typeof prop !== \"number\") {\n            throw Error(`Invalid array index: ${prop}`);\n        }\n        const chunkIdx = Math.floor(prop / this.itemsPerChunk);\n        return persistent_merkle_tree_1.toGindex(this.depth, BigInt(chunkIdx));\n    }\n    getIndexProperty(index) {\n        return index;\n    }\n    tree_getLeafGindices(rootGindex, rootNode) {\n        let length;\n        if (this.isList) {\n            if (!rootNode) {\n                throw new Error(\"List type requires tree argument to get leaves\");\n            }\n            length = this.tree_getLength(rootNode);\n        }\n        else {\n            // Vectors don't need a rootNode to return length\n            length = this.tree_getLength(null);\n        }\n        const gindices = [];\n        if (composite_1.isCompositeType(this.elementType)) {\n            // Underlying elements exist one per chunk\n            // Iterate through chunk gindices, recursively fetching leaf gindices from each chunk\n            const startIndex = persistent_merkle_tree_1.toGindex(this.depth, BigInt(0));\n            const endGindex = startIndex + BigInt(length);\n            const extendedStartIndex = persistent_merkle_tree_1.concatGindices([rootGindex, startIndex]);\n            if (this.elementType.fixedSize === null) {\n                if (!rootNode) {\n                    /* istanbul ignore next - unreachable code */\n                    throw new Error(\"Array of variable size requires tree argument to get leaves\");\n                }\n                // variable-length elements must pass the underlying subtrees to determine the length\n                for (let gindex = startIndex, extendedGindex = extendedStartIndex; gindex < endGindex; gindex++, extendedGindex++) {\n                    gindices.push(...this.elementType.tree_getLeafGindices(extendedGindex, persistent_merkle_tree_1.getNode(rootNode, gindex)));\n                }\n            }\n            else {\n                for (let i = 0, extendedGindex = extendedStartIndex; i < length; i++, extendedGindex++) {\n                    gindices.push(...this.elementType.tree_getLeafGindices(extendedGindex));\n                }\n            }\n        }\n        // Basic\n        else {\n            const chunkCount = Math.ceil(length / this.itemsPerChunk);\n            const startIndex = persistent_merkle_tree_1.concatGindices([rootGindex, persistent_merkle_tree_1.toGindex(this.depth, BigInt(0))]);\n            const endGindex = startIndex + BigInt(chunkCount);\n            for (let gindex = startIndex; gindex < endGindex; gindex++) {\n                gindices.push(gindex);\n            }\n        }\n        // include the length chunk\n        if (this.isList) {\n            gindices.push(persistent_merkle_tree_1.concatGindices([rootGindex, composite_1.LENGTH_GINDEX]));\n        }\n        return gindices;\n    }\n    // JSON\n    fromJson(json) {\n        // TODO: Do a better typesafe approach, all final classes of ArrayType implement ArrayProps\n        // There are multiple tests that cover this path for all clases\n        return arrayBasic_1.value_fromJsonArray(this.elementType, json, this);\n    }\n    toJson(value) {\n        return arrayBasic_1.value_toJsonArray(this.elementType, value, this);\n    }\n    clone(value) {\n        return arrayBasic_1.value_cloneArray(this.elementType, value);\n    }\n    equals(a, b) {\n        return arrayBasic_1.value_equals(this.elementType, a, b);\n    }\n}\nexports.ArrayType = ArrayType;\n//# sourceMappingURL=array.js.map"]},"metadata":{},"sourceType":"script"}