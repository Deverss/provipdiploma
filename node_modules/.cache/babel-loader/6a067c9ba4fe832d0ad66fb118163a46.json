{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.hashPersonalMessage = exports.isValidSignature = exports.fromRpcSig = exports.toCompactSig = exports.toRpcSig = exports.ecrecover = exports.ecsign = void 0;\n\nconst keccak_1 = require(\"ethereum-cryptography/keccak\");\n\nconst secp256k1_1 = require(\"ethereum-cryptography/secp256k1\");\n\nconst bytes_1 = require(\"./bytes\");\n\nconst constants_1 = require(\"./constants\");\n\nconst helpers_1 = require(\"./helpers\");\n/**\n * Returns the ECDSA signature of a message hash.\n *\n * If `chainId` is provided assume an EIP-155-style signature and calculate the `v` value\n * accordingly, otherwise return a \"static\" `v` just derived from the `recovery` bit\n */\n\n\nfunction ecsign(msgHash, privateKey, chainId) {\n  const [signature, recovery] = (0, secp256k1_1.signSync)(msgHash, privateKey, {\n    recovered: true,\n    der: false\n  });\n  const r = Buffer.from(signature.slice(0, 32));\n  const s = Buffer.from(signature.slice(32, 64));\n  const v = chainId === undefined ? BigInt(recovery + 27) : BigInt(recovery + 35) + BigInt(chainId) * BigInt(2);\n  return {\n    r,\n    s,\n    v\n  };\n}\n\nexports.ecsign = ecsign;\n\nfunction calculateSigRecovery(v, chainId) {\n  if (v === BigInt(0) || v === BigInt(1)) return v;\n\n  if (chainId === undefined) {\n    return v - BigInt(27);\n  }\n\n  return v - (chainId * BigInt(2) + BigInt(35));\n}\n\nfunction isValidSigRecovery(recovery) {\n  return recovery === BigInt(0) || recovery === BigInt(1);\n}\n/**\n * ECDSA public key recovery from signature.\n * NOTE: Accepts `v === 0 | v === 1` for EIP1559 transactions\n * @returns Recovered public key\n */\n\n\nconst ecrecover = function (msgHash, v, r, s, chainId) {\n  const signature = Buffer.concat([(0, bytes_1.setLengthLeft)(r, 32), (0, bytes_1.setLengthLeft)(s, 32)], 64);\n  const recovery = calculateSigRecovery(v, chainId);\n\n  if (!isValidSigRecovery(recovery)) {\n    throw new Error('Invalid signature v value');\n  }\n\n  const senderPubKey = (0, secp256k1_1.recoverPublicKey)(msgHash, signature, Number(recovery));\n  return Buffer.from(senderPubKey.slice(1));\n};\n\nexports.ecrecover = ecrecover;\n/**\n * Convert signature parameters into the format of `eth_sign` RPC method.\n * NOTE: Accepts `v === 0 | v === 1` for EIP1559 transactions\n * @returns Signature\n */\n\nconst toRpcSig = function (v, r, s, chainId) {\n  const recovery = calculateSigRecovery(v, chainId);\n\n  if (!isValidSigRecovery(recovery)) {\n    throw new Error('Invalid signature v value');\n  } // geth (and the RPC eth_sign method) uses the 65 byte format used by Bitcoin\n\n\n  return (0, bytes_1.bufferToHex)(Buffer.concat([(0, bytes_1.setLengthLeft)(r, 32), (0, bytes_1.setLengthLeft)(s, 32), (0, bytes_1.toBuffer)(v)]));\n};\n\nexports.toRpcSig = toRpcSig;\n/**\n * Convert signature parameters into the format of Compact Signature Representation (EIP-2098).\n * NOTE: Accepts `v === 0 | v === 1` for EIP1559 transactions\n * @returns Signature\n */\n\nconst toCompactSig = function (v, r, s, chainId) {\n  const recovery = calculateSigRecovery(v, chainId);\n\n  if (!isValidSigRecovery(recovery)) {\n    throw new Error('Invalid signature v value');\n  }\n\n  let ss = s;\n\n  if (v > BigInt(28) && v % BigInt(2) === BigInt(1) || v === BigInt(1) || v === BigInt(28)) {\n    ss = Buffer.from(s);\n    ss[0] |= 0x80;\n  }\n\n  return (0, bytes_1.bufferToHex)(Buffer.concat([(0, bytes_1.setLengthLeft)(r, 32), (0, bytes_1.setLengthLeft)(ss, 32)]));\n};\n\nexports.toCompactSig = toCompactSig;\n/**\n * Convert signature format of the `eth_sign` RPC method to signature parameters\n *\n * NOTE: For an extracted `v` value < 27 (see Geth bug https://github.com/ethereum/go-ethereum/issues/2053)\n * `v + 27` is returned for the `v` value\n * NOTE: After EIP1559, `v` could be `0` or `1` but this function assumes\n * it's a signed message (EIP-191 or EIP-712) adding `27` at the end. Remove if needed.\n */\n\nconst fromRpcSig = function (sig) {\n  const buf = (0, bytes_1.toBuffer)(sig);\n  let r;\n  let s;\n  let v;\n\n  if (buf.length >= 65) {\n    r = buf.slice(0, 32);\n    s = buf.slice(32, 64);\n    v = (0, bytes_1.bufferToBigInt)(buf.slice(64));\n  } else if (buf.length === 64) {\n    // Compact Signature Representation (https://eips.ethereum.org/EIPS/eip-2098)\n    r = buf.slice(0, 32);\n    s = buf.slice(32, 64);\n    v = BigInt((0, bytes_1.bufferToInt)(buf.slice(32, 33)) >> 7);\n    s[0] &= 0x7f;\n  } else {\n    throw new Error('Invalid signature length');\n  } // support both versions of `eth_sign` responses\n\n\n  if (v < 27) {\n    v = v + BigInt(27);\n  }\n\n  return {\n    v,\n    r,\n    s\n  };\n};\n\nexports.fromRpcSig = fromRpcSig;\n/**\n * Validate a ECDSA signature.\n * NOTE: Accepts `v === 0 | v === 1` for EIP1559 transactions\n * @param homesteadOrLater Indicates whether this is being used on either the homestead hardfork or a later one\n */\n\nconst isValidSignature = function (v, r, s, homesteadOrLater = true, chainId) {\n  if (r.length !== 32 || s.length !== 32) {\n    return false;\n  }\n\n  if (!isValidSigRecovery(calculateSigRecovery(v, chainId))) {\n    return false;\n  }\n\n  const rBigInt = (0, bytes_1.bufferToBigInt)(r);\n  const sBigInt = (0, bytes_1.bufferToBigInt)(s);\n\n  if (rBigInt === BigInt(0) || rBigInt >= constants_1.SECP256K1_ORDER || sBigInt === BigInt(0) || sBigInt >= constants_1.SECP256K1_ORDER) {\n    return false;\n  }\n\n  if (homesteadOrLater && sBigInt >= constants_1.SECP256K1_ORDER_DIV_2) {\n    return false;\n  }\n\n  return true;\n};\n\nexports.isValidSignature = isValidSignature;\n/**\n * Returns the keccak-256 hash of `message`, prefixed with the header used by the `eth_sign` RPC call.\n * The output of this function can be fed into `ecsign` to produce the same signature as the `eth_sign`\n * call for a given `message`, or fed to `ecrecover` along with a signature to recover the public key\n * used to produce the signature.\n */\n\nconst hashPersonalMessage = function (message) {\n  (0, helpers_1.assertIsBuffer)(message);\n  const prefix = Buffer.from(`\\u0019Ethereum Signed Message:\\n${message.length}`, 'utf-8');\n  return Buffer.from((0, keccak_1.keccak256)(Buffer.concat([prefix, message])));\n};\n\nexports.hashPersonalMessage = hashPersonalMessage;","map":{"version":3,"sources":["../src/signature.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.hashPersonalMessage = exports.isValidSignature = exports.fromRpcSig = exports.toCompactSig = exports.toRpcSig = exports.ecrecover = exports.ecsign = void 0;\nconst keccak_1 = require(\"ethereum-cryptography/keccak\");\nconst secp256k1_1 = require(\"ethereum-cryptography/secp256k1\");\nconst bytes_1 = require(\"./bytes\");\nconst constants_1 = require(\"./constants\");\nconst helpers_1 = require(\"./helpers\");\n/**\n * Returns the ECDSA signature of a message hash.\n *\n * If `chainId` is provided assume an EIP-155-style signature and calculate the `v` value\n * accordingly, otherwise return a \"static\" `v` just derived from the `recovery` bit\n */\nfunction ecsign(msgHash, privateKey, chainId) {\n    const [signature, recovery] = (0, secp256k1_1.signSync)(msgHash, privateKey, { recovered: true, der: false });\n    const r = Buffer.from(signature.slice(0, 32));\n    const s = Buffer.from(signature.slice(32, 64));\n    const v = chainId === undefined\n        ? BigInt(recovery + 27)\n        : BigInt(recovery + 35) + BigInt(chainId) * BigInt(2);\n    return { r, s, v };\n}\nexports.ecsign = ecsign;\nfunction calculateSigRecovery(v, chainId) {\n    if (v === BigInt(0) || v === BigInt(1))\n        return v;\n    if (chainId === undefined) {\n        return v - BigInt(27);\n    }\n    return v - (chainId * BigInt(2) + BigInt(35));\n}\nfunction isValidSigRecovery(recovery) {\n    return recovery === BigInt(0) || recovery === BigInt(1);\n}\n/**\n * ECDSA public key recovery from signature.\n * NOTE: Accepts `v === 0 | v === 1` for EIP1559 transactions\n * @returns Recovered public key\n */\nconst ecrecover = function (msgHash, v, r, s, chainId) {\n    const signature = Buffer.concat([(0, bytes_1.setLengthLeft)(r, 32), (0, bytes_1.setLengthLeft)(s, 32)], 64);\n    const recovery = calculateSigRecovery(v, chainId);\n    if (!isValidSigRecovery(recovery)) {\n        throw new Error('Invalid signature v value');\n    }\n    const senderPubKey = (0, secp256k1_1.recoverPublicKey)(msgHash, signature, Number(recovery));\n    return Buffer.from(senderPubKey.slice(1));\n};\nexports.ecrecover = ecrecover;\n/**\n * Convert signature parameters into the format of `eth_sign` RPC method.\n * NOTE: Accepts `v === 0 | v === 1` for EIP1559 transactions\n * @returns Signature\n */\nconst toRpcSig = function (v, r, s, chainId) {\n    const recovery = calculateSigRecovery(v, chainId);\n    if (!isValidSigRecovery(recovery)) {\n        throw new Error('Invalid signature v value');\n    }\n    // geth (and the RPC eth_sign method) uses the 65 byte format used by Bitcoin\n    return (0, bytes_1.bufferToHex)(Buffer.concat([(0, bytes_1.setLengthLeft)(r, 32), (0, bytes_1.setLengthLeft)(s, 32), (0, bytes_1.toBuffer)(v)]));\n};\nexports.toRpcSig = toRpcSig;\n/**\n * Convert signature parameters into the format of Compact Signature Representation (EIP-2098).\n * NOTE: Accepts `v === 0 | v === 1` for EIP1559 transactions\n * @returns Signature\n */\nconst toCompactSig = function (v, r, s, chainId) {\n    const recovery = calculateSigRecovery(v, chainId);\n    if (!isValidSigRecovery(recovery)) {\n        throw new Error('Invalid signature v value');\n    }\n    let ss = s;\n    if ((v > BigInt(28) && v % BigInt(2) === BigInt(1)) || v === BigInt(1) || v === BigInt(28)) {\n        ss = Buffer.from(s);\n        ss[0] |= 0x80;\n    }\n    return (0, bytes_1.bufferToHex)(Buffer.concat([(0, bytes_1.setLengthLeft)(r, 32), (0, bytes_1.setLengthLeft)(ss, 32)]));\n};\nexports.toCompactSig = toCompactSig;\n/**\n * Convert signature format of the `eth_sign` RPC method to signature parameters\n *\n * NOTE: For an extracted `v` value < 27 (see Geth bug https://github.com/ethereum/go-ethereum/issues/2053)\n * `v + 27` is returned for the `v` value\n * NOTE: After EIP1559, `v` could be `0` or `1` but this function assumes\n * it's a signed message (EIP-191 or EIP-712) adding `27` at the end. Remove if needed.\n */\nconst fromRpcSig = function (sig) {\n    const buf = (0, bytes_1.toBuffer)(sig);\n    let r;\n    let s;\n    let v;\n    if (buf.length >= 65) {\n        r = buf.slice(0, 32);\n        s = buf.slice(32, 64);\n        v = (0, bytes_1.bufferToBigInt)(buf.slice(64));\n    }\n    else if (buf.length === 64) {\n        // Compact Signature Representation (https://eips.ethereum.org/EIPS/eip-2098)\n        r = buf.slice(0, 32);\n        s = buf.slice(32, 64);\n        v = BigInt((0, bytes_1.bufferToInt)(buf.slice(32, 33)) >> 7);\n        s[0] &= 0x7f;\n    }\n    else {\n        throw new Error('Invalid signature length');\n    }\n    // support both versions of `eth_sign` responses\n    if (v < 27) {\n        v = v + BigInt(27);\n    }\n    return {\n        v,\n        r,\n        s,\n    };\n};\nexports.fromRpcSig = fromRpcSig;\n/**\n * Validate a ECDSA signature.\n * NOTE: Accepts `v === 0 | v === 1` for EIP1559 transactions\n * @param homesteadOrLater Indicates whether this is being used on either the homestead hardfork or a later one\n */\nconst isValidSignature = function (v, r, s, homesteadOrLater = true, chainId) {\n    if (r.length !== 32 || s.length !== 32) {\n        return false;\n    }\n    if (!isValidSigRecovery(calculateSigRecovery(v, chainId))) {\n        return false;\n    }\n    const rBigInt = (0, bytes_1.bufferToBigInt)(r);\n    const sBigInt = (0, bytes_1.bufferToBigInt)(s);\n    if (rBigInt === BigInt(0) ||\n        rBigInt >= constants_1.SECP256K1_ORDER ||\n        sBigInt === BigInt(0) ||\n        sBigInt >= constants_1.SECP256K1_ORDER) {\n        return false;\n    }\n    if (homesteadOrLater && sBigInt >= constants_1.SECP256K1_ORDER_DIV_2) {\n        return false;\n    }\n    return true;\n};\nexports.isValidSignature = isValidSignature;\n/**\n * Returns the keccak-256 hash of `message`, prefixed with the header used by the `eth_sign` RPC call.\n * The output of this function can be fed into `ecsign` to produce the same signature as the `eth_sign`\n * call for a given `message`, or fed to `ecrecover` along with a signature to recover the public key\n * used to produce the signature.\n */\nconst hashPersonalMessage = function (message) {\n    (0, helpers_1.assertIsBuffer)(message);\n    const prefix = Buffer.from(`\\u0019Ethereum Signed Message:\\n${message.length}`, 'utf-8');\n    return Buffer.from((0, keccak_1.keccak256)(Buffer.concat([prefix, message])));\n};\nexports.hashPersonalMessage = hashPersonalMessage;\n//# sourceMappingURL=signature.js.map"]},"metadata":{},"sourceType":"script"}