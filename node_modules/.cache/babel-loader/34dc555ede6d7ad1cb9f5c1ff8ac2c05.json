{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.renderContainerTypeName = exports.precomputeJsonKey = exports.ContainerType = void 0;\n\nconst persistent_merkle_tree_1 = require(\"@chainsafe/persistent-merkle-tree\");\n\nconst case_1 = __importDefault(require(\"case\"));\n\nconst merkleize_1 = require(\"../util/merkleize\");\n\nconst named_1 = require(\"../util/named\");\n\nconst composite_1 = require(\"./composite\");\n\nconst container_1 = require(\"../view/container\");\n\nconst container_2 = require(\"../viewDU/container\");\n/**\n * Container: ordered heterogeneous collection of values\n * - Notation: Custom name per instance\n */\n\n\nclass ContainerType extends composite_1.CompositeType {\n  constructor(fields, opts) {\n    var _opts$getContainerTre, _opts$getContainerTre2;\n\n    super(opts === null || opts === void 0 ? void 0 : opts.cachePermanentRootStruct);\n    this.fields = fields;\n    this.opts = opts;\n    this.isList = false;\n    this.isViewMutable = true; // Render detailed typeName. Consumers should overwrite since it can get long\n\n    this.typeName = (opts === null || opts === void 0 ? void 0 : opts.typeName) ?? renderContainerTypeName(fields);\n    this.maxChunkCount = Object.keys(fields).length;\n    this.depth = merkleize_1.maxChunksToDepth(this.maxChunkCount); // Precalculated data for faster serdes\n\n    this.fieldsEntries = [];\n\n    for (const fieldName of Object.keys(fields)) {\n      this.fieldsEntries.push({\n        fieldName,\n        fieldType: this.fields[fieldName],\n        jsonKey: precomputeJsonKey(fieldName, opts === null || opts === void 0 ? void 0 : opts.casingMap, opts === null || opts === void 0 ? void 0 : opts.jsonCase),\n        gindex: persistent_merkle_tree_1.toGindex(this.depth, BigInt(this.fieldsEntries.length))\n      });\n    }\n\n    if (this.fieldsEntries.length === 0) {\n      throw Error(\"Container must have > 0 fields\");\n    } // Precalculate for Proofs API\n\n\n    this.fieldsGindex = {};\n\n    for (let i = 0; i < this.fieldsEntries.length; i++) {\n      this.fieldsGindex[this.fieldsEntries[i].fieldName] = persistent_merkle_tree_1.toGindex(this.depth, BigInt(i));\n    } // To resolve JSON paths in fieldName notation and jsonKey notation\n\n\n    this.jsonKeyToFieldName = {};\n\n    for (const {\n      fieldName,\n      jsonKey\n    } of this.fieldsEntries) {\n      this.jsonKeyToFieldName[jsonKey] = fieldName;\n    }\n\n    const {\n      minLen,\n      maxLen,\n      fixedSize\n    } = precomputeSizes(fields);\n    this.minSize = minLen;\n    this.maxSize = maxLen;\n    this.fixedSize = fixedSize;\n    const {\n      isFixedLen,\n      fieldRangesFixedLen,\n      variableOffsetsPosition,\n      fixedEnd\n    } = precomputeSerdesData(fields);\n    this.isFixedLen = isFixedLen;\n    this.fieldRangesFixedLen = fieldRangesFixedLen;\n    this.variableOffsetsPosition = variableOffsetsPosition;\n    this.fixedEnd = fixedEnd; // TODO: This options are necessary for ContainerNodeStruct to override this.\n    // Refactor this constructor to allow customization without pollutin the options\n\n    this.TreeView = (opts === null || opts === void 0 ? void 0 : (_opts$getContainerTre = opts.getContainerTreeViewClass) === null || _opts$getContainerTre === void 0 ? void 0 : _opts$getContainerTre.call(opts, this)) ?? container_1.getContainerTreeViewClass(this);\n    this.TreeViewDU = (opts === null || opts === void 0 ? void 0 : (_opts$getContainerTre2 = opts.getContainerTreeViewDUClass) === null || _opts$getContainerTre2 === void 0 ? void 0 : _opts$getContainerTre2.call(opts, this)) ?? container_2.getContainerTreeViewDUClass(this);\n  }\n\n  static named(fields, opts) {\n    return new (named_1.namedClass(ContainerType, opts.typeName))(fields, opts);\n  }\n\n  defaultValue() {\n    const value = {};\n\n    for (const {\n      fieldName,\n      fieldType\n    } of this.fieldsEntries) {\n      value[fieldName] = fieldType.defaultValue();\n    }\n\n    return value;\n  }\n\n  getView(tree) {\n    return new this.TreeView(this, tree);\n  }\n\n  getViewDU(node, cache) {\n    return new this.TreeViewDU(this, node, cache);\n  }\n\n  cacheOfViewDU(view) {\n    return view.cache;\n  }\n\n  commitView(view) {\n    return view.node;\n  }\n\n  commitViewDU(view) {\n    view.commit();\n    return view.node;\n  } // Serialization + deserialization\n  // -------------------------------\n  // Containers can mix fixed length and variable length data.\n  //\n  // Fixed part                         Variable part\n  // [field1 offset][field2 data       ][field1 data               ]\n  // [0x000000c]    [0xaabbaabbaabbaabb][0xffffffffffffffffffffffff]\n\n\n  value_serializedSize(value) {\n    let totalSize = 0;\n\n    for (let i = 0; i < this.fieldsEntries.length; i++) {\n      const {\n        fieldName,\n        fieldType\n      } = this.fieldsEntries[i]; // Offset (4 bytes) + size\n\n      totalSize += fieldType.fixedSize === null ? 4 + fieldType.value_serializedSize(value[fieldName]) : fieldType.fixedSize;\n    }\n\n    return totalSize;\n  }\n\n  value_serializeToBytes(output, offset, value) {\n    let fixedIndex = offset;\n    let variableIndex = offset + this.fixedEnd;\n\n    for (let i = 0; i < this.fieldsEntries.length; i++) {\n      const {\n        fieldName,\n        fieldType\n      } = this.fieldsEntries[i];\n\n      if (fieldType.fixedSize === null) {\n        // write offset\n        output.dataView.setUint32(fixedIndex, variableIndex - offset, true);\n        fixedIndex += 4; // write serialized element to variable section\n\n        variableIndex = fieldType.value_serializeToBytes(output, variableIndex, value[fieldName]);\n      } else {\n        fixedIndex = fieldType.value_serializeToBytes(output, fixedIndex, value[fieldName]);\n      }\n    }\n\n    return variableIndex;\n  }\n\n  value_deserializeFromBytes(data, start, end) {\n    const fieldRanges = this.getFieldRanges(data.dataView, start, end);\n    const value = {};\n\n    for (let i = 0; i < this.fieldsEntries.length; i++) {\n      const {\n        fieldName,\n        fieldType\n      } = this.fieldsEntries[i];\n      const fieldRange = fieldRanges[i];\n      value[fieldName] = fieldType.value_deserializeFromBytes(data, start + fieldRange.start, start + fieldRange.end);\n    }\n\n    return value;\n  }\n\n  tree_serializedSize(node) {\n    let totalSize = 0;\n    const nodes = persistent_merkle_tree_1.getNodesAtDepth(node, this.depth, 0, this.fieldsEntries.length);\n\n    for (let i = 0; i < this.fieldsEntries.length; i++) {\n      const {\n        fieldType\n      } = this.fieldsEntries[i];\n      const node = nodes[i]; // Offset (4 bytes) + size\n\n      totalSize += fieldType.fixedSize === null ? 4 + fieldType.tree_serializedSize(node) : fieldType.fixedSize;\n    }\n\n    return totalSize;\n  }\n\n  tree_serializeToBytes(output, offset, node) {\n    let fixedIndex = offset;\n    let variableIndex = offset + this.fixedEnd;\n    const nodes = persistent_merkle_tree_1.getNodesAtDepth(node, this.depth, 0, this.fieldsEntries.length);\n\n    for (let i = 0; i < this.fieldsEntries.length; i++) {\n      const {\n        fieldType\n      } = this.fieldsEntries[i];\n      const node = nodes[i];\n\n      if (fieldType.fixedSize === null) {\n        // write offset\n        output.dataView.setUint32(fixedIndex, variableIndex - offset, true);\n        fixedIndex += 4; // write serialized element to variable section\n\n        variableIndex = fieldType.tree_serializeToBytes(output, variableIndex, node);\n      } else {\n        fixedIndex = fieldType.tree_serializeToBytes(output, fixedIndex, node);\n      }\n    }\n\n    return variableIndex;\n  }\n\n  tree_deserializeFromBytes(data, start, end) {\n    const fieldRanges = this.getFieldRanges(data.dataView, start, end);\n    const nodes = new Array(this.fieldsEntries.length);\n\n    for (let i = 0; i < this.fieldsEntries.length; i++) {\n      const {\n        fieldType\n      } = this.fieldsEntries[i];\n      const fieldRange = fieldRanges[i];\n      nodes[i] = fieldType.tree_deserializeFromBytes(data, start + fieldRange.start, start + fieldRange.end);\n    }\n\n    return persistent_merkle_tree_1.subtreeFillToContents(nodes, this.depth);\n  } // Merkleization\n\n\n  getRoots(struct) {\n    const roots = new Array(this.fieldsEntries.length);\n\n    for (let i = 0; i < this.fieldsEntries.length; i++) {\n      const {\n        fieldName,\n        fieldType\n      } = this.fieldsEntries[i];\n      roots[i] = fieldType.hashTreeRoot(struct[fieldName]);\n    }\n\n    return roots;\n  } // Proofs\n  // getPropertyGindex\n  // getPropertyType\n  // tree_getLeafGindices\n\n\n  getPropertyGindex(prop) {\n    const gindex = this.fieldsGindex[prop] ?? this.fieldsGindex[this.jsonKeyToFieldName[prop]];\n    if (gindex === undefined) throw Error(`Unknown container property ${prop}`);\n    return gindex;\n  }\n\n  getPropertyType(prop) {\n    const type = this.fields[prop] ?? this.fields[this.jsonKeyToFieldName[prop]];\n    if (type === undefined) throw Error(`Unknown container property ${prop}`);\n    return type;\n  }\n\n  getIndexProperty(index) {\n    if (index >= this.fieldsEntries.length) {\n      return null;\n    }\n\n    return this.fieldsEntries[index].fieldName;\n  }\n\n  tree_getLeafGindices(rootGindex, rootNode) {\n    const gindices = [];\n\n    for (let i = 0; i < this.fieldsEntries.length; i++) {\n      const {\n        fieldName,\n        fieldType\n      } = this.fieldsEntries[i];\n      const fieldGindex = this.fieldsGindex[fieldName];\n      const fieldGindexFromRoot = persistent_merkle_tree_1.concatGindices([rootGindex, fieldGindex]);\n\n      if (fieldType.isBasic) {\n        gindices.push(fieldGindexFromRoot);\n      } else {\n        const compositeType = fieldType;\n\n        if (fieldType.fixedSize === null) {\n          if (!rootNode) {\n            throw new Error(\"variable type requires tree argument to get leaves\");\n          }\n\n          gindices.push(...compositeType.tree_getLeafGindices(fieldGindexFromRoot, persistent_merkle_tree_1.getNode(rootNode, fieldGindex)));\n        } else {\n          gindices.push(...compositeType.tree_getLeafGindices(fieldGindexFromRoot));\n        }\n      }\n    }\n\n    return gindices;\n  } // JSON\n\n\n  fromJson(json) {\n    if (typeof json !== \"object\") {\n      throw Error(\"JSON must be of type object\");\n    }\n\n    if (json === null) {\n      throw Error(\"JSON must not be null\");\n    }\n\n    const value = {};\n\n    for (let i = 0; i < this.fieldsEntries.length; i++) {\n      const {\n        fieldName,\n        fieldType,\n        jsonKey\n      } = this.fieldsEntries[i];\n      const jsonValue = json[jsonKey];\n\n      if (jsonValue === undefined) {\n        throw Error(`JSON expected key ${jsonKey} is undefined`);\n      }\n\n      value[fieldName] = fieldType.fromJson(jsonValue);\n    }\n\n    return value;\n  }\n\n  toJson(value) {\n    const json = {};\n\n    for (let i = 0; i < this.fieldsEntries.length; i++) {\n      const {\n        fieldName,\n        fieldType,\n        jsonKey\n      } = this.fieldsEntries[i];\n      json[jsonKey] = fieldType.toJson(value[fieldName]);\n    }\n\n    return json;\n  }\n\n  clone(value) {\n    const newValue = {};\n\n    for (let i = 0; i < this.fieldsEntries.length; i++) {\n      const {\n        fieldName,\n        fieldType\n      } = this.fieldsEntries[i];\n      newValue[fieldName] = fieldType.clone(value[fieldName]);\n    }\n\n    return newValue;\n  }\n\n  equals(a, b) {\n    for (let i = 0; i < this.fieldsEntries.length; i++) {\n      const {\n        fieldName,\n        fieldType\n      } = this.fieldsEntries[i];\n\n      if (!fieldType.equals(a[fieldName], b[fieldName])) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n  /**\n   * Deserializer helper: Returns the bytes ranges of all fields, both variable and fixed size.\n   * Fields may not be contiguous in the serialized bytes, so the returned ranges are [start, end].\n   * - For fixed size fields re-uses the pre-computed values this.fieldRangesFixedLen\n   * - For variable size fields does a first pass over the fixed section to read offsets\n   */\n\n\n  getFieldRanges(data, start, end) {\n    if (this.variableOffsetsPosition.length === 0) {\n      // Validate fixed length container\n      const size = end - start;\n\n      if (size !== this.fixedEnd) {\n        throw Error(`${this.typeName} size ${size} not equal fixed size ${this.fixedEnd}`);\n      }\n\n      return this.fieldRangesFixedLen;\n    } // Read offsets in one pass\n\n\n    const offsets = readVariableOffsets(data, start, end, this.fixedEnd, this.variableOffsetsPosition);\n    offsets.push(end - start); // The offsets are relative to the start\n    // Merge fieldRangesFixedLen + offsets in one array\n\n    let variableIdx = 0;\n    let fixedIdx = 0;\n    const fieldRanges = new Array(this.isFixedLen.length);\n\n    for (let i = 0; i < this.isFixedLen.length; i++) {\n      if (this.isFixedLen[i]) {\n        // push from fixLen ranges ++\n        fieldRanges[i] = this.fieldRangesFixedLen[fixedIdx++];\n      } else {\n        // push from varLen ranges ++\n        fieldRanges[i] = {\n          start: offsets[variableIdx],\n          end: offsets[variableIdx + 1]\n        };\n        variableIdx++;\n      }\n    }\n\n    return fieldRanges;\n  }\n\n}\n\nexports.ContainerType = ContainerType;\n/**\n * Returns the byte ranges of all variable size fields.\n */\n\nfunction readVariableOffsets(data, start, end, fixedEnd, variableOffsetsPosition) {\n  // Since variable-sized values can be interspersed with fixed-sized values, we precalculate\n  // the offset indices so we can more easily deserialize the fields in once pass first we get the fixed sizes\n  // Note: `fixedSizes[i] = null` if that field has variable length\n  const size = end - start; // with the fixed sizes, we can read the offsets, and store for our single pass\n\n  const offsets = new Array(variableOffsetsPosition.length);\n\n  for (let i = 0; i < variableOffsetsPosition.length; i++) {\n    const offset = data.getUint32(start + variableOffsetsPosition[i], true); // Validate offsets. If the list is empty the offset points to the end of the buffer, offset == size\n\n    if (offset > size) {\n      throw new Error(`Offset out of bounds ${offset} > ${size}`);\n    }\n\n    if (i === 0) {\n      if (offset !== fixedEnd) {\n        throw new Error(`First offset must equal to fixedEnd ${offset} != ${fixedEnd}`);\n      }\n    } else {\n      if (offset < offsets[i - 1]) {\n        throw new Error(`Offsets must be increasing ${offset} < ${offsets[i - 1]}`);\n      }\n    }\n\n    offsets[i] = offset;\n  }\n\n  return offsets;\n}\n/**\n * Precompute fixed and variable offsets position for faster deserialization.\n * @returns Does a single pass over all fields and returns:\n * - isFixedLen: If field index [i] is fixed length\n * - fieldRangesFixedLen: For fields with fixed length, their range of bytes\n * - variableOffsetsPosition: Position of the 4 bytes offset for variable size fields\n * - fixedEnd: End of the fixed size range\n * -\n */\n\n\nfunction precomputeSerdesData(fields) {\n  const isFixedLen = [];\n  const fieldRangesFixedLen = [];\n  const variableOffsetsPosition = [];\n  let pointerFixed = 0;\n\n  for (const fieldType of Object.values(fields)) {\n    isFixedLen.push(fieldType.fixedSize !== null);\n\n    if (fieldType.fixedSize === null) {\n      // Variable length\n      variableOffsetsPosition.push(pointerFixed);\n      pointerFixed += 4;\n    } else {\n      fieldRangesFixedLen.push({\n        start: pointerFixed,\n        end: pointerFixed + fieldType.fixedSize\n      });\n      pointerFixed += fieldType.fixedSize;\n    }\n  }\n\n  return {\n    isFixedLen,\n    fieldRangesFixedLen,\n    variableOffsetsPosition,\n    fixedEnd: pointerFixed\n  };\n}\n/**\n * Precompute sizes of the Container doing one pass over fields\n */\n\n\nfunction precomputeSizes(fields) {\n  let minLen = 0;\n  let maxLen = 0;\n  let fixedSize = 0;\n\n  for (const fieldType of Object.values(fields)) {\n    minLen += fieldType.minSize;\n    maxLen += fieldType.maxSize;\n\n    if (fieldType.fixedSize === null) {\n      // +4 for the offset\n      minLen += 4;\n      maxLen += 4;\n      fixedSize = null;\n    } else if (fixedSize !== null) {\n      fixedSize += fieldType.fixedSize;\n    }\n  }\n\n  return {\n    minLen,\n    maxLen,\n    fixedSize\n  };\n}\n/**\n * Compute the JSON key for each fieldName. There will exist a single JSON representation for each type.\n * To transform JSON payloads to a casing that is different from the type's defined use external tooling.\n */\n\n\nfunction precomputeJsonKey(fieldName, casingMap, jsonCase) {\n  if (casingMap) {\n    const keyFromCaseMap = casingMap[fieldName];\n\n    if (keyFromCaseMap === undefined) {\n      throw Error(`casingMap[${fieldName}] not defined`);\n    }\n\n    return keyFromCaseMap;\n  } else if (jsonCase) {\n    if (jsonCase === \"eth2\") {\n      const snake = case_1.default.snake(fieldName);\n      return snake.replace(/(\\d)$/, \"_$1\");\n    } else {\n      return case_1.default[jsonCase](fieldName);\n    }\n  } else {\n    return fieldName;\n  }\n}\n\nexports.precomputeJsonKey = precomputeJsonKey;\n/**\n * Render field typeNames for a detailed typeName of this Container\n */\n\nfunction renderContainerTypeName(fields, prefix = \"Container\") {\n  const fieldNames = Object.keys(fields);\n  const fieldTypeNames = fieldNames.map(fieldName => `${fieldName}: ${fields[fieldName].typeName}`).join(\", \");\n  return `${prefix}({${fieldTypeNames}})`;\n}\n\nexports.renderContainerTypeName = renderContainerTypeName;","map":{"version":3,"sources":["../../src/type/container.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.renderContainerTypeName = exports.precomputeJsonKey = exports.ContainerType = void 0;\nconst persistent_merkle_tree_1 = require(\"@chainsafe/persistent-merkle-tree\");\nconst case_1 = __importDefault(require(\"case\"));\nconst merkleize_1 = require(\"../util/merkleize\");\nconst named_1 = require(\"../util/named\");\nconst composite_1 = require(\"./composite\");\nconst container_1 = require(\"../view/container\");\nconst container_2 = require(\"../viewDU/container\");\n/**\n * Container: ordered heterogeneous collection of values\n * - Notation: Custom name per instance\n */\nclass ContainerType extends composite_1.CompositeType {\n    constructor(fields, opts) {\n        super(opts?.cachePermanentRootStruct);\n        this.fields = fields;\n        this.opts = opts;\n        this.isList = false;\n        this.isViewMutable = true;\n        // Render detailed typeName. Consumers should overwrite since it can get long\n        this.typeName = opts?.typeName ?? renderContainerTypeName(fields);\n        this.maxChunkCount = Object.keys(fields).length;\n        this.depth = merkleize_1.maxChunksToDepth(this.maxChunkCount);\n        // Precalculated data for faster serdes\n        this.fieldsEntries = [];\n        for (const fieldName of Object.keys(fields)) {\n            this.fieldsEntries.push({\n                fieldName,\n                fieldType: this.fields[fieldName],\n                jsonKey: precomputeJsonKey(fieldName, opts?.casingMap, opts?.jsonCase),\n                gindex: persistent_merkle_tree_1.toGindex(this.depth, BigInt(this.fieldsEntries.length)),\n            });\n        }\n        if (this.fieldsEntries.length === 0) {\n            throw Error(\"Container must have > 0 fields\");\n        }\n        // Precalculate for Proofs API\n        this.fieldsGindex = {};\n        for (let i = 0; i < this.fieldsEntries.length; i++) {\n            this.fieldsGindex[this.fieldsEntries[i].fieldName] = persistent_merkle_tree_1.toGindex(this.depth, BigInt(i));\n        }\n        // To resolve JSON paths in fieldName notation and jsonKey notation\n        this.jsonKeyToFieldName = {};\n        for (const { fieldName, jsonKey } of this.fieldsEntries) {\n            this.jsonKeyToFieldName[jsonKey] = fieldName;\n        }\n        const { minLen, maxLen, fixedSize } = precomputeSizes(fields);\n        this.minSize = minLen;\n        this.maxSize = maxLen;\n        this.fixedSize = fixedSize;\n        const { isFixedLen, fieldRangesFixedLen, variableOffsetsPosition, fixedEnd } = precomputeSerdesData(fields);\n        this.isFixedLen = isFixedLen;\n        this.fieldRangesFixedLen = fieldRangesFixedLen;\n        this.variableOffsetsPosition = variableOffsetsPosition;\n        this.fixedEnd = fixedEnd;\n        // TODO: This options are necessary for ContainerNodeStruct to override this.\n        // Refactor this constructor to allow customization without pollutin the options\n        this.TreeView = opts?.getContainerTreeViewClass?.(this) ?? container_1.getContainerTreeViewClass(this);\n        this.TreeViewDU = opts?.getContainerTreeViewDUClass?.(this) ?? container_2.getContainerTreeViewDUClass(this);\n    }\n    static named(fields, opts) {\n        return new (named_1.namedClass(ContainerType, opts.typeName))(fields, opts);\n    }\n    defaultValue() {\n        const value = {};\n        for (const { fieldName, fieldType } of this.fieldsEntries) {\n            value[fieldName] = fieldType.defaultValue();\n        }\n        return value;\n    }\n    getView(tree) {\n        return new this.TreeView(this, tree);\n    }\n    getViewDU(node, cache) {\n        return new this.TreeViewDU(this, node, cache);\n    }\n    cacheOfViewDU(view) {\n        return view.cache;\n    }\n    commitView(view) {\n        return view.node;\n    }\n    commitViewDU(view) {\n        view.commit();\n        return view.node;\n    }\n    // Serialization + deserialization\n    // -------------------------------\n    // Containers can mix fixed length and variable length data.\n    //\n    // Fixed part                         Variable part\n    // [field1 offset][field2 data       ][field1 data               ]\n    // [0x000000c]    [0xaabbaabbaabbaabb][0xffffffffffffffffffffffff]\n    value_serializedSize(value) {\n        let totalSize = 0;\n        for (let i = 0; i < this.fieldsEntries.length; i++) {\n            const { fieldName, fieldType } = this.fieldsEntries[i];\n            // Offset (4 bytes) + size\n            totalSize +=\n                fieldType.fixedSize === null ? 4 + fieldType.value_serializedSize(value[fieldName]) : fieldType.fixedSize;\n        }\n        return totalSize;\n    }\n    value_serializeToBytes(output, offset, value) {\n        let fixedIndex = offset;\n        let variableIndex = offset + this.fixedEnd;\n        for (let i = 0; i < this.fieldsEntries.length; i++) {\n            const { fieldName, fieldType } = this.fieldsEntries[i];\n            if (fieldType.fixedSize === null) {\n                // write offset\n                output.dataView.setUint32(fixedIndex, variableIndex - offset, true);\n                fixedIndex += 4;\n                // write serialized element to variable section\n                variableIndex = fieldType.value_serializeToBytes(output, variableIndex, value[fieldName]);\n            }\n            else {\n                fixedIndex = fieldType.value_serializeToBytes(output, fixedIndex, value[fieldName]);\n            }\n        }\n        return variableIndex;\n    }\n    value_deserializeFromBytes(data, start, end) {\n        const fieldRanges = this.getFieldRanges(data.dataView, start, end);\n        const value = {};\n        for (let i = 0; i < this.fieldsEntries.length; i++) {\n            const { fieldName, fieldType } = this.fieldsEntries[i];\n            const fieldRange = fieldRanges[i];\n            value[fieldName] = fieldType.value_deserializeFromBytes(data, start + fieldRange.start, start + fieldRange.end);\n        }\n        return value;\n    }\n    tree_serializedSize(node) {\n        let totalSize = 0;\n        const nodes = persistent_merkle_tree_1.getNodesAtDepth(node, this.depth, 0, this.fieldsEntries.length);\n        for (let i = 0; i < this.fieldsEntries.length; i++) {\n            const { fieldType } = this.fieldsEntries[i];\n            const node = nodes[i];\n            // Offset (4 bytes) + size\n            totalSize += fieldType.fixedSize === null ? 4 + fieldType.tree_serializedSize(node) : fieldType.fixedSize;\n        }\n        return totalSize;\n    }\n    tree_serializeToBytes(output, offset, node) {\n        let fixedIndex = offset;\n        let variableIndex = offset + this.fixedEnd;\n        const nodes = persistent_merkle_tree_1.getNodesAtDepth(node, this.depth, 0, this.fieldsEntries.length);\n        for (let i = 0; i < this.fieldsEntries.length; i++) {\n            const { fieldType } = this.fieldsEntries[i];\n            const node = nodes[i];\n            if (fieldType.fixedSize === null) {\n                // write offset\n                output.dataView.setUint32(fixedIndex, variableIndex - offset, true);\n                fixedIndex += 4;\n                // write serialized element to variable section\n                variableIndex = fieldType.tree_serializeToBytes(output, variableIndex, node);\n            }\n            else {\n                fixedIndex = fieldType.tree_serializeToBytes(output, fixedIndex, node);\n            }\n        }\n        return variableIndex;\n    }\n    tree_deserializeFromBytes(data, start, end) {\n        const fieldRanges = this.getFieldRanges(data.dataView, start, end);\n        const nodes = new Array(this.fieldsEntries.length);\n        for (let i = 0; i < this.fieldsEntries.length; i++) {\n            const { fieldType } = this.fieldsEntries[i];\n            const fieldRange = fieldRanges[i];\n            nodes[i] = fieldType.tree_deserializeFromBytes(data, start + fieldRange.start, start + fieldRange.end);\n        }\n        return persistent_merkle_tree_1.subtreeFillToContents(nodes, this.depth);\n    }\n    // Merkleization\n    getRoots(struct) {\n        const roots = new Array(this.fieldsEntries.length);\n        for (let i = 0; i < this.fieldsEntries.length; i++) {\n            const { fieldName, fieldType } = this.fieldsEntries[i];\n            roots[i] = fieldType.hashTreeRoot(struct[fieldName]);\n        }\n        return roots;\n    }\n    // Proofs\n    // getPropertyGindex\n    // getPropertyType\n    // tree_getLeafGindices\n    getPropertyGindex(prop) {\n        const gindex = this.fieldsGindex[prop] ?? this.fieldsGindex[this.jsonKeyToFieldName[prop]];\n        if (gindex === undefined)\n            throw Error(`Unknown container property ${prop}`);\n        return gindex;\n    }\n    getPropertyType(prop) {\n        const type = this.fields[prop] ?? this.fields[this.jsonKeyToFieldName[prop]];\n        if (type === undefined)\n            throw Error(`Unknown container property ${prop}`);\n        return type;\n    }\n    getIndexProperty(index) {\n        if (index >= this.fieldsEntries.length) {\n            return null;\n        }\n        return this.fieldsEntries[index].fieldName;\n    }\n    tree_getLeafGindices(rootGindex, rootNode) {\n        const gindices = [];\n        for (let i = 0; i < this.fieldsEntries.length; i++) {\n            const { fieldName, fieldType } = this.fieldsEntries[i];\n            const fieldGindex = this.fieldsGindex[fieldName];\n            const fieldGindexFromRoot = persistent_merkle_tree_1.concatGindices([rootGindex, fieldGindex]);\n            if (fieldType.isBasic) {\n                gindices.push(fieldGindexFromRoot);\n            }\n            else {\n                const compositeType = fieldType;\n                if (fieldType.fixedSize === null) {\n                    if (!rootNode) {\n                        throw new Error(\"variable type requires tree argument to get leaves\");\n                    }\n                    gindices.push(...compositeType.tree_getLeafGindices(fieldGindexFromRoot, persistent_merkle_tree_1.getNode(rootNode, fieldGindex)));\n                }\n                else {\n                    gindices.push(...compositeType.tree_getLeafGindices(fieldGindexFromRoot));\n                }\n            }\n        }\n        return gindices;\n    }\n    // JSON\n    fromJson(json) {\n        if (typeof json !== \"object\") {\n            throw Error(\"JSON must be of type object\");\n        }\n        if (json === null) {\n            throw Error(\"JSON must not be null\");\n        }\n        const value = {};\n        for (let i = 0; i < this.fieldsEntries.length; i++) {\n            const { fieldName, fieldType, jsonKey } = this.fieldsEntries[i];\n            const jsonValue = json[jsonKey];\n            if (jsonValue === undefined) {\n                throw Error(`JSON expected key ${jsonKey} is undefined`);\n            }\n            value[fieldName] = fieldType.fromJson(jsonValue);\n        }\n        return value;\n    }\n    toJson(value) {\n        const json = {};\n        for (let i = 0; i < this.fieldsEntries.length; i++) {\n            const { fieldName, fieldType, jsonKey } = this.fieldsEntries[i];\n            json[jsonKey] = fieldType.toJson(value[fieldName]);\n        }\n        return json;\n    }\n    clone(value) {\n        const newValue = {};\n        for (let i = 0; i < this.fieldsEntries.length; i++) {\n            const { fieldName, fieldType } = this.fieldsEntries[i];\n            newValue[fieldName] = fieldType.clone(value[fieldName]);\n        }\n        return newValue;\n    }\n    equals(a, b) {\n        for (let i = 0; i < this.fieldsEntries.length; i++) {\n            const { fieldName, fieldType } = this.fieldsEntries[i];\n            if (!fieldType.equals(a[fieldName], b[fieldName])) {\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * Deserializer helper: Returns the bytes ranges of all fields, both variable and fixed size.\n     * Fields may not be contiguous in the serialized bytes, so the returned ranges are [start, end].\n     * - For fixed size fields re-uses the pre-computed values this.fieldRangesFixedLen\n     * - For variable size fields does a first pass over the fixed section to read offsets\n     */\n    getFieldRanges(data, start, end) {\n        if (this.variableOffsetsPosition.length === 0) {\n            // Validate fixed length container\n            const size = end - start;\n            if (size !== this.fixedEnd) {\n                throw Error(`${this.typeName} size ${size} not equal fixed size ${this.fixedEnd}`);\n            }\n            return this.fieldRangesFixedLen;\n        }\n        // Read offsets in one pass\n        const offsets = readVariableOffsets(data, start, end, this.fixedEnd, this.variableOffsetsPosition);\n        offsets.push(end - start); // The offsets are relative to the start\n        // Merge fieldRangesFixedLen + offsets in one array\n        let variableIdx = 0;\n        let fixedIdx = 0;\n        const fieldRanges = new Array(this.isFixedLen.length);\n        for (let i = 0; i < this.isFixedLen.length; i++) {\n            if (this.isFixedLen[i]) {\n                // push from fixLen ranges ++\n                fieldRanges[i] = this.fieldRangesFixedLen[fixedIdx++];\n            }\n            else {\n                // push from varLen ranges ++\n                fieldRanges[i] = { start: offsets[variableIdx], end: offsets[variableIdx + 1] };\n                variableIdx++;\n            }\n        }\n        return fieldRanges;\n    }\n}\nexports.ContainerType = ContainerType;\n/**\n * Returns the byte ranges of all variable size fields.\n */\nfunction readVariableOffsets(data, start, end, fixedEnd, variableOffsetsPosition) {\n    // Since variable-sized values can be interspersed with fixed-sized values, we precalculate\n    // the offset indices so we can more easily deserialize the fields in once pass first we get the fixed sizes\n    // Note: `fixedSizes[i] = null` if that field has variable length\n    const size = end - start;\n    // with the fixed sizes, we can read the offsets, and store for our single pass\n    const offsets = new Array(variableOffsetsPosition.length);\n    for (let i = 0; i < variableOffsetsPosition.length; i++) {\n        const offset = data.getUint32(start + variableOffsetsPosition[i], true);\n        // Validate offsets. If the list is empty the offset points to the end of the buffer, offset == size\n        if (offset > size) {\n            throw new Error(`Offset out of bounds ${offset} > ${size}`);\n        }\n        if (i === 0) {\n            if (offset !== fixedEnd) {\n                throw new Error(`First offset must equal to fixedEnd ${offset} != ${fixedEnd}`);\n            }\n        }\n        else {\n            if (offset < offsets[i - 1]) {\n                throw new Error(`Offsets must be increasing ${offset} < ${offsets[i - 1]}`);\n            }\n        }\n        offsets[i] = offset;\n    }\n    return offsets;\n}\n/**\n * Precompute fixed and variable offsets position for faster deserialization.\n * @returns Does a single pass over all fields and returns:\n * - isFixedLen: If field index [i] is fixed length\n * - fieldRangesFixedLen: For fields with fixed length, their range of bytes\n * - variableOffsetsPosition: Position of the 4 bytes offset for variable size fields\n * - fixedEnd: End of the fixed size range\n * -\n */\nfunction precomputeSerdesData(fields) {\n    const isFixedLen = [];\n    const fieldRangesFixedLen = [];\n    const variableOffsetsPosition = [];\n    let pointerFixed = 0;\n    for (const fieldType of Object.values(fields)) {\n        isFixedLen.push(fieldType.fixedSize !== null);\n        if (fieldType.fixedSize === null) {\n            // Variable length\n            variableOffsetsPosition.push(pointerFixed);\n            pointerFixed += 4;\n        }\n        else {\n            fieldRangesFixedLen.push({ start: pointerFixed, end: pointerFixed + fieldType.fixedSize });\n            pointerFixed += fieldType.fixedSize;\n        }\n    }\n    return {\n        isFixedLen,\n        fieldRangesFixedLen,\n        variableOffsetsPosition,\n        fixedEnd: pointerFixed,\n    };\n}\n/**\n * Precompute sizes of the Container doing one pass over fields\n */\nfunction precomputeSizes(fields) {\n    let minLen = 0;\n    let maxLen = 0;\n    let fixedSize = 0;\n    for (const fieldType of Object.values(fields)) {\n        minLen += fieldType.minSize;\n        maxLen += fieldType.maxSize;\n        if (fieldType.fixedSize === null) {\n            // +4 for the offset\n            minLen += 4;\n            maxLen += 4;\n            fixedSize = null;\n        }\n        else if (fixedSize !== null) {\n            fixedSize += fieldType.fixedSize;\n        }\n    }\n    return { minLen, maxLen, fixedSize };\n}\n/**\n * Compute the JSON key for each fieldName. There will exist a single JSON representation for each type.\n * To transform JSON payloads to a casing that is different from the type's defined use external tooling.\n */\nfunction precomputeJsonKey(fieldName, casingMap, jsonCase) {\n    if (casingMap) {\n        const keyFromCaseMap = casingMap[fieldName];\n        if (keyFromCaseMap === undefined) {\n            throw Error(`casingMap[${fieldName}] not defined`);\n        }\n        return keyFromCaseMap;\n    }\n    else if (jsonCase) {\n        if (jsonCase === \"eth2\") {\n            const snake = case_1.default.snake(fieldName);\n            return snake.replace(/(\\d)$/, \"_$1\");\n        }\n        else {\n            return case_1.default[jsonCase](fieldName);\n        }\n    }\n    else {\n        return fieldName;\n    }\n}\nexports.precomputeJsonKey = precomputeJsonKey;\n/**\n * Render field typeNames for a detailed typeName of this Container\n */\nfunction renderContainerTypeName(fields, prefix = \"Container\") {\n    const fieldNames = Object.keys(fields);\n    const fieldTypeNames = fieldNames.map((fieldName) => `${fieldName}: ${fields[fieldName].typeName}`).join(\", \");\n    return `${prefix}({${fieldTypeNames}})`;\n}\nexports.renderContainerTypeName = renderContainerTypeName;\n//# sourceMappingURL=container.js.map"]},"metadata":{},"sourceType":"script"}