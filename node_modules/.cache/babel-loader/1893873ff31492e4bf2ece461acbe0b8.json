{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.MAX_WITHDRAWALS_PER_PAYLOAD = exports.RLP_EMPTY_STRING = exports.KECCAK256_RLP = exports.KECCAK256_RLP_S = exports.KECCAK256_RLP_ARRAY = exports.KECCAK256_RLP_ARRAY_S = exports.KECCAK256_NULL = exports.KECCAK256_NULL_S = exports.TWO_POW256 = exports.SECP256K1_ORDER_DIV_2 = exports.SECP256K1_ORDER = exports.MAX_INTEGER_BIGINT = exports.MAX_INTEGER = exports.MAX_UINT64 = void 0;\n\nconst buffer_1 = require(\"buffer\");\n\nconst secp256k1_1 = require(\"ethereum-cryptography/secp256k1\");\n/**\n * 2^64-1\n */\n\n\nexports.MAX_UINT64 = BigInt('0xffffffffffffffff');\n/**\n * The max integer that the evm can handle (2^256-1)\n */\n\nexports.MAX_INTEGER = BigInt('0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff');\n/**\n * The max integer that the evm can handle (2^256-1) as a bigint\n * 2^256-1 equals to 340282366920938463463374607431768211455\n * We use literal value instead of calculated value for compatibility issue.\n */\n\nexports.MAX_INTEGER_BIGINT = BigInt('115792089237316195423570985008687907853269984665640564039457584007913129639935');\nexports.SECP256K1_ORDER = secp256k1_1.CURVE.n;\nexports.SECP256K1_ORDER_DIV_2 = secp256k1_1.CURVE.n / BigInt(2);\n/**\n * 2^256\n */\n\nexports.TWO_POW256 = BigInt('0x10000000000000000000000000000000000000000000000000000000000000000');\n/**\n * Keccak-256 hash of null\n */\n\nexports.KECCAK256_NULL_S = 'c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470';\n/**\n * Keccak-256 hash of null\n */\n\nexports.KECCAK256_NULL = buffer_1.Buffer.from(exports.KECCAK256_NULL_S, 'hex');\n/**\n * Keccak-256 of an RLP of an empty array\n */\n\nexports.KECCAK256_RLP_ARRAY_S = '1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347';\n/**\n * Keccak-256 of an RLP of an empty array\n */\n\nexports.KECCAK256_RLP_ARRAY = buffer_1.Buffer.from(exports.KECCAK256_RLP_ARRAY_S, 'hex');\n/**\n * Keccak-256 hash of the RLP of null\n */\n\nexports.KECCAK256_RLP_S = '56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421';\n/**\n * Keccak-256 hash of the RLP of null\n */\n\nexports.KECCAK256_RLP = buffer_1.Buffer.from(exports.KECCAK256_RLP_S, 'hex');\n/**\n *  RLP encoded empty string\n */\n\nexports.RLP_EMPTY_STRING = buffer_1.Buffer.from([0x80]);\nexports.MAX_WITHDRAWALS_PER_PAYLOAD = 16;","map":{"version":3,"sources":["../src/constants.ts"],"names":[],"mappings":";;;;;;;AAAA,MAAA,QAAA,GAAA,OAAA,CAAA,QAAA,CAAA;;AACA,MAAA,WAAA,GAAA,OAAA,CAAA,iCAAA,CAAA;AAEA;;AAEG;;;AACU,OAAA,CAAA,UAAA,GAAa,MAAM,CAAC,oBAAD,CAAnB;AAEb;;AAEG;;AACU,OAAA,CAAA,WAAA,GAAc,MAAM,CAC/B,oEAD+B,CAApB;AAIb;;;;AAIG;;AACU,OAAA,CAAA,kBAAA,GAAqB,MAAM,CACtC,gFADsC,CAA3B;AAIA,OAAA,CAAA,eAAA,GAAkB,WAAA,CAAA,KAAA,CAAM,CAAxB;AACA,OAAA,CAAA,qBAAA,GAAwB,WAAA,CAAA,KAAA,CAAM,CAAN,GAAU,MAAM,CAAC,CAAD,CAAxC;AAEb;;AAEG;;AACU,OAAA,CAAA,UAAA,GAAa,MAAM,CAC9B,qEAD8B,CAAnB;AAIb;;AAEG;;AACU,OAAA,CAAA,gBAAA,GAAmB,kEAAnB;AAEb;;AAEG;;AACU,OAAA,CAAA,cAAA,GAAiB,QAAA,CAAA,MAAA,CAAO,IAAP,CAAY,OAAA,CAAA,gBAAZ,EAA8B,KAA9B,CAAjB;AAEb;;AAEG;;AACU,OAAA,CAAA,qBAAA,GACX,kEADW;AAGb;;AAEG;;AACU,OAAA,CAAA,mBAAA,GAAsB,QAAA,CAAA,MAAA,CAAO,IAAP,CAAY,OAAA,CAAA,qBAAZ,EAAmC,KAAnC,CAAtB;AAEb;;AAEG;;AACU,OAAA,CAAA,eAAA,GAAkB,kEAAlB;AAEb;;AAEG;;AACU,OAAA,CAAA,aAAA,GAAgB,QAAA,CAAA,MAAA,CAAO,IAAP,CAAY,OAAA,CAAA,eAAZ,EAA6B,KAA7B,CAAhB;AAEb;;AAEG;;AACU,OAAA,CAAA,gBAAA,GAAmB,QAAA,CAAA,MAAA,CAAO,IAAP,CAAY,CAAC,IAAD,CAAZ,CAAnB;AAEA,OAAA,CAAA,2BAAA,GAA8B,EAA9B","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MAX_WITHDRAWALS_PER_PAYLOAD = exports.RLP_EMPTY_STRING = exports.KECCAK256_RLP = exports.KECCAK256_RLP_S = exports.KECCAK256_RLP_ARRAY = exports.KECCAK256_RLP_ARRAY_S = exports.KECCAK256_NULL = exports.KECCAK256_NULL_S = exports.TWO_POW256 = exports.SECP256K1_ORDER_DIV_2 = exports.SECP256K1_ORDER = exports.MAX_INTEGER_BIGINT = exports.MAX_INTEGER = exports.MAX_UINT64 = void 0;\nconst buffer_1 = require(\"buffer\");\nconst secp256k1_1 = require(\"ethereum-cryptography/secp256k1\");\n/**\n * 2^64-1\n */\nexports.MAX_UINT64 = BigInt('0xffffffffffffffff');\n/**\n * The max integer that the evm can handle (2^256-1)\n */\nexports.MAX_INTEGER = BigInt('0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff');\n/**\n * The max integer that the evm can handle (2^256-1) as a bigint\n * 2^256-1 equals to 340282366920938463463374607431768211455\n * We use literal value instead of calculated value for compatibility issue.\n */\nexports.MAX_INTEGER_BIGINT = BigInt('115792089237316195423570985008687907853269984665640564039457584007913129639935');\nexports.SECP256K1_ORDER = secp256k1_1.CURVE.n;\nexports.SECP256K1_ORDER_DIV_2 = secp256k1_1.CURVE.n / BigInt(2);\n/**\n * 2^256\n */\nexports.TWO_POW256 = BigInt('0x10000000000000000000000000000000000000000000000000000000000000000');\n/**\n * Keccak-256 hash of null\n */\nexports.KECCAK256_NULL_S = 'c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470';\n/**\n * Keccak-256 hash of null\n */\nexports.KECCAK256_NULL = buffer_1.Buffer.from(exports.KECCAK256_NULL_S, 'hex');\n/**\n * Keccak-256 of an RLP of an empty array\n */\nexports.KECCAK256_RLP_ARRAY_S = '1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347';\n/**\n * Keccak-256 of an RLP of an empty array\n */\nexports.KECCAK256_RLP_ARRAY = buffer_1.Buffer.from(exports.KECCAK256_RLP_ARRAY_S, 'hex');\n/**\n * Keccak-256 hash of the RLP of null\n */\nexports.KECCAK256_RLP_S = '56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421';\n/**\n * Keccak-256 hash of the RLP of null\n */\nexports.KECCAK256_RLP = buffer_1.Buffer.from(exports.KECCAK256_RLP_S, 'hex');\n/**\n *  RLP encoded empty string\n */\nexports.RLP_EMPTY_STRING = buffer_1.Buffer.from([0x80]);\nexports.MAX_WITHDRAWALS_PER_PAYLOAD = 16;\n//# sourceMappingURL=constants.js.map"]},"metadata":{},"sourceType":"script"}