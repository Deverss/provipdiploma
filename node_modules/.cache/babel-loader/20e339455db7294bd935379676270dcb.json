{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.computeMultiProofBitstrings = exports.SortOrder = exports.filterParentBitstrings = exports.sortDecreasingBitstrings = exports.sortInOrderBitstrings = exports.computeProofBitstrings = exports.computeProofGindices = void 0;\n\nconst gindex_1 = require(\"../gindex\"); // Not currently in use, but simpler implementation useful for testing\n\n/**\n * Compute both the path and branch indices\n *\n * Path indices are parent indices upwards toward the root\n * Branch indices are witnesses required for a merkle proof\n */\n\n\nfunction computeProofGindices(gindex) {\n  const path = new Set();\n  const branch = new Set();\n  let g = gindex;\n\n  while (g > 1) {\n    path.add(g);\n    branch.add(gindex_1.gindexSibling(g));\n    g = gindex_1.gindexParent(g);\n  }\n\n  return {\n    path,\n    branch\n  };\n}\n\nexports.computeProofGindices = computeProofGindices;\n/**\n * Compute both the path and branch indices\n *\n * Path indices are parent indices upwards toward the root\n * Branch indices are witnesses required for a merkle proof\n */\n\nfunction computeProofBitstrings(gindex) {\n  const path = new Set();\n  const branch = new Set();\n  let g = gindex;\n\n  while (g.length > 1) {\n    path.add(g);\n    const lastBit = g[g.length - 1];\n    const parent = g.substring(0, g.length - 1);\n    branch.add(parent + (Number(lastBit) ^ 1));\n    g = parent;\n  }\n\n  return {\n    path,\n    branch\n  };\n}\n\nexports.computeProofBitstrings = computeProofBitstrings;\n/**\n * Sort generalized indices in-order\n * @param bitLength maximum bit length of generalized indices to sort\n */\n\nfunction sortInOrderBitstrings(gindices, bitLength) {\n  if (!gindices.length) {\n    return [];\n  }\n\n  return gindices.map(g => g.padEnd(bitLength)).sort().map(g => g.trim());\n}\n\nexports.sortInOrderBitstrings = sortInOrderBitstrings;\n/**\n * Sort generalized indices in decreasing order\n */\n\nfunction sortDecreasingBitstrings(gindices) {\n  if (!gindices.length) {\n    return [];\n  }\n\n  return gindices.sort((a, b) => {\n    if (a.length < b.length) {\n      return 1;\n    } else if (b.length < a.length) {\n      return -1;\n    }\n\n    let aPos0 = a.indexOf(\"0\");\n    let bPos0 = b.indexOf(\"0\"); // eslint-disable-next-line no-constant-condition\n\n    while (true) {\n      if (aPos0 === -1) {\n        return -1;\n      } else if (bPos0 === -1) {\n        return 1;\n      }\n\n      if (aPos0 < bPos0) {\n        return 1;\n      } else if (bPos0 < aPos0) {\n        return -1;\n      }\n\n      aPos0 = a.indexOf(\"0\", aPos0 + 1);\n      bPos0 = b.indexOf(\"0\", bPos0 + 1);\n    }\n  });\n}\n\nexports.sortDecreasingBitstrings = sortDecreasingBitstrings;\n/**\n * Filter out parent generalized indices\n */\n\nfunction filterParentBitstrings(gindices) {\n  const sortedBitstrings = gindices.slice().sort((a, b) => a.length - b.length);\n  const filtered = [];\n\n  outer: for (let i = 0; i < sortedBitstrings.length; i++) {\n    const bsA = sortedBitstrings[i];\n\n    for (let j = i + 1; j < sortedBitstrings.length; j++) {\n      const bsB = sortedBitstrings[j];\n\n      if (bsB.startsWith(bsA)) {\n        continue outer;\n      }\n    }\n\n    filtered.push(bsA);\n  }\n\n  return filtered;\n}\n\nexports.filterParentBitstrings = filterParentBitstrings;\nvar SortOrder;\n\n(function (SortOrder) {\n  SortOrder[SortOrder[\"InOrder\"] = 0] = \"InOrder\";\n  SortOrder[SortOrder[\"Decreasing\"] = 1] = \"Decreasing\";\n  SortOrder[SortOrder[\"Unsorted\"] = 2] = \"Unsorted\";\n})(SortOrder = exports.SortOrder || (exports.SortOrder = {}));\n/**\n * Return the set of generalized indices required for a multiproof\n * This may include all leaves and any necessary witnesses\n * @param gindices leaves to include in proof\n * @returns all generalized indices required for a multiproof (leaves and witnesses), deduplicated and sorted\n */\n\n\nfunction computeMultiProofBitstrings(gindices, includeLeaves = true, sortOrder = SortOrder.InOrder) {\n  const leaves = filterParentBitstrings(gindices); // Maybe initialize the proof indices with the leaves\n\n  const proof = new Set(includeLeaves ? leaves : []);\n  const paths = new Set();\n  const branches = new Set(); // Collect all path indices and all branch indices\n\n  let maxBitLength = 1;\n\n  for (const gindex of leaves) {\n    if (gindex.length > maxBitLength) maxBitLength = gindex.length;\n    const {\n      path,\n      branch\n    } = computeProofBitstrings(gindex);\n    path.forEach(g => paths.add(g));\n    branch.forEach(g => branches.add(g));\n  } // Remove all branches that are included in the paths\n\n\n  paths.forEach(g => branches.delete(g)); // Add all remaining branches to the leaves\n\n  branches.forEach(g => proof.add(g));\n\n  switch (sortOrder) {\n    case SortOrder.InOrder:\n      return sortInOrderBitstrings(Array.from(proof), maxBitLength);\n\n    case SortOrder.Decreasing:\n      return sortDecreasingBitstrings(Array.from(proof));\n\n    case SortOrder.Unsorted:\n      return Array.from(proof);\n  }\n}\n\nexports.computeMultiProofBitstrings = computeMultiProofBitstrings;","map":{"version":3,"sources":["/Users/dev3rs/provipdiploma/node_modules/@chainsafe/persistent-merkle-tree/lib/proof/util.js"],"names":["Object","defineProperty","exports","value","computeMultiProofBitstrings","SortOrder","filterParentBitstrings","sortDecreasingBitstrings","sortInOrderBitstrings","computeProofBitstrings","computeProofGindices","gindex_1","require","gindex","path","Set","branch","g","add","gindexSibling","gindexParent","length","lastBit","parent","substring","Number","gindices","bitLength","map","padEnd","sort","trim","a","b","aPos0","indexOf","bPos0","sortedBitstrings","slice","filtered","outer","i","bsA","j","bsB","startsWith","push","includeLeaves","sortOrder","InOrder","leaves","proof","paths","branches","maxBitLength","forEach","delete","Array","from","Decreasing","Unsorted"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.computeMultiProofBitstrings = exports.SortOrder = exports.filterParentBitstrings = exports.sortDecreasingBitstrings = exports.sortInOrderBitstrings = exports.computeProofBitstrings = exports.computeProofGindices = void 0;\nconst gindex_1 = require(\"../gindex\");\n// Not currently in use, but simpler implementation useful for testing\n/**\n * Compute both the path and branch indices\n *\n * Path indices are parent indices upwards toward the root\n * Branch indices are witnesses required for a merkle proof\n */\nfunction computeProofGindices(gindex) {\n    const path = new Set();\n    const branch = new Set();\n    let g = gindex;\n    while (g > 1) {\n        path.add(g);\n        branch.add(gindex_1.gindexSibling(g));\n        g = gindex_1.gindexParent(g);\n    }\n    return { path, branch };\n}\nexports.computeProofGindices = computeProofGindices;\n/**\n * Compute both the path and branch indices\n *\n * Path indices are parent indices upwards toward the root\n * Branch indices are witnesses required for a merkle proof\n */\nfunction computeProofBitstrings(gindex) {\n    const path = new Set();\n    const branch = new Set();\n    let g = gindex;\n    while (g.length > 1) {\n        path.add(g);\n        const lastBit = g[g.length - 1];\n        const parent = g.substring(0, g.length - 1);\n        branch.add(parent + (Number(lastBit) ^ 1));\n        g = parent;\n    }\n    return { path, branch };\n}\nexports.computeProofBitstrings = computeProofBitstrings;\n/**\n * Sort generalized indices in-order\n * @param bitLength maximum bit length of generalized indices to sort\n */\nfunction sortInOrderBitstrings(gindices, bitLength) {\n    if (!gindices.length) {\n        return [];\n    }\n    return gindices\n        .map((g) => g.padEnd(bitLength))\n        .sort()\n        .map((g) => g.trim());\n}\nexports.sortInOrderBitstrings = sortInOrderBitstrings;\n/**\n * Sort generalized indices in decreasing order\n */\nfunction sortDecreasingBitstrings(gindices) {\n    if (!gindices.length) {\n        return [];\n    }\n    return gindices.sort((a, b) => {\n        if (a.length < b.length) {\n            return 1;\n        }\n        else if (b.length < a.length) {\n            return -1;\n        }\n        let aPos0 = a.indexOf(\"0\");\n        let bPos0 = b.indexOf(\"0\");\n        // eslint-disable-next-line no-constant-condition\n        while (true) {\n            if (aPos0 === -1) {\n                return -1;\n            }\n            else if (bPos0 === -1) {\n                return 1;\n            }\n            if (aPos0 < bPos0) {\n                return 1;\n            }\n            else if (bPos0 < aPos0) {\n                return -1;\n            }\n            aPos0 = a.indexOf(\"0\", aPos0 + 1);\n            bPos0 = b.indexOf(\"0\", bPos0 + 1);\n        }\n    });\n}\nexports.sortDecreasingBitstrings = sortDecreasingBitstrings;\n/**\n * Filter out parent generalized indices\n */\nfunction filterParentBitstrings(gindices) {\n    const sortedBitstrings = gindices.slice().sort((a, b) => a.length - b.length);\n    const filtered = [];\n    outer: for (let i = 0; i < sortedBitstrings.length; i++) {\n        const bsA = sortedBitstrings[i];\n        for (let j = i + 1; j < sortedBitstrings.length; j++) {\n            const bsB = sortedBitstrings[j];\n            if (bsB.startsWith(bsA)) {\n                continue outer;\n            }\n        }\n        filtered.push(bsA);\n    }\n    return filtered;\n}\nexports.filterParentBitstrings = filterParentBitstrings;\nvar SortOrder;\n(function (SortOrder) {\n    SortOrder[SortOrder[\"InOrder\"] = 0] = \"InOrder\";\n    SortOrder[SortOrder[\"Decreasing\"] = 1] = \"Decreasing\";\n    SortOrder[SortOrder[\"Unsorted\"] = 2] = \"Unsorted\";\n})(SortOrder = exports.SortOrder || (exports.SortOrder = {}));\n/**\n * Return the set of generalized indices required for a multiproof\n * This may include all leaves and any necessary witnesses\n * @param gindices leaves to include in proof\n * @returns all generalized indices required for a multiproof (leaves and witnesses), deduplicated and sorted\n */\nfunction computeMultiProofBitstrings(gindices, includeLeaves = true, sortOrder = SortOrder.InOrder) {\n    const leaves = filterParentBitstrings(gindices);\n    // Maybe initialize the proof indices with the leaves\n    const proof = new Set(includeLeaves ? leaves : []);\n    const paths = new Set();\n    const branches = new Set();\n    // Collect all path indices and all branch indices\n    let maxBitLength = 1;\n    for (const gindex of leaves) {\n        if (gindex.length > maxBitLength)\n            maxBitLength = gindex.length;\n        const { path, branch } = computeProofBitstrings(gindex);\n        path.forEach((g) => paths.add(g));\n        branch.forEach((g) => branches.add(g));\n    }\n    // Remove all branches that are included in the paths\n    paths.forEach((g) => branches.delete(g));\n    // Add all remaining branches to the leaves\n    branches.forEach((g) => proof.add(g));\n    switch (sortOrder) {\n        case SortOrder.InOrder:\n            return sortInOrderBitstrings(Array.from(proof), maxBitLength);\n        case SortOrder.Decreasing:\n            return sortDecreasingBitstrings(Array.from(proof));\n        case SortOrder.Unsorted:\n            return Array.from(proof);\n    }\n}\nexports.computeMultiProofBitstrings = computeMultiProofBitstrings;\n"]},"metadata":{},"sourceType":"script"}