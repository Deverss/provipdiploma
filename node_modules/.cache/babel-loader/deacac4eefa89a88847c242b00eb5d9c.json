{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Lock = void 0; // Based on https://github.com/jsoendermann/semaphore-async-await/blob/master/src/Semaphore.ts\n\nclass Lock {\n  constructor() {\n    this.permits = 1;\n    this.promiseResolverQueue = [];\n  }\n  /**\n   * Returns a promise used to wait for a permit to become available. This method should be awaited on.\n   * @returns  A promise that gets resolved when execution is allowed to proceed.\n   */\n\n\n  async acquire() {\n    if (this.permits > 0) {\n      this.permits -= 1;\n      return Promise.resolve(true);\n    } // If there is no permit available, we return a promise that resolves once the semaphore gets\n    // signaled enough times that permits is equal to one.\n\n\n    return new Promise(resolver => this.promiseResolverQueue.push(resolver));\n  }\n  /**\n   * Increases the number of permits by one. If there are other functions waiting, one of them will\n   * continue to execute in a future iteration of the event loop.\n   */\n\n\n  release() {\n    this.permits += 1;\n\n    if (this.permits > 1 && this.promiseResolverQueue.length > 0) {\n      // eslint-disable-next-line no-console\n      console.warn('Lock.permits should never be > 0 when there is someone waiting.');\n    } else if (this.permits === 1 && this.promiseResolverQueue.length > 0) {\n      // If there is someone else waiting, immediately consume the permit that was released\n      // at the beginning of this function and let the waiting function resume.\n      this.permits -= 1;\n      const nextResolver = this.promiseResolverQueue.shift();\n\n      if (nextResolver) {\n        nextResolver(true);\n      }\n    }\n  }\n\n}\n\nexports.Lock = Lock;","map":{"version":3,"sources":["../src/lock.ts"],"names":[],"mappings":";;;;;uBAAA;;AACA,MAAa,IAAb,CAAiB;AAAjB,EAAA,WAAA,GAAA;AACU,SAAA,OAAA,GAAkB,CAAlB;AACA,SAAA,oBAAA,GAAoD,EAApD;AAsCT;AApCC;;;AAGG;;;AACiB,QAAP,OAAO,GAAA;AAClB,QAAI,KAAK,OAAL,GAAe,CAAnB,EAAsB;AACpB,WAAK,OAAL,IAAgB,CAAhB;AACA,aAAO,OAAO,CAAC,OAAR,CAAgB,IAAhB,CAAP;AACD,KAJiB,CAMlB;AACA;;;AACA,WAAO,IAAI,OAAJ,CAAsB,QAAD,IAAc,KAAK,oBAAL,CAA0B,IAA1B,CAA+B,QAA/B,CAAnC,CAAP;AACD;AAED;;;AAGG;;;AACI,EAAA,OAAO,GAAA;AACZ,SAAK,OAAL,IAAgB,CAAhB;;AAEA,QAAI,KAAK,OAAL,GAAe,CAAf,IAAoB,KAAK,oBAAL,CAA0B,MAA1B,GAAmC,CAA3D,EAA8D;AAC5D;AACA,MAAA,OAAO,CAAC,IAAR,CAAa,iEAAb;AACD,KAHD,MAGO,IAAI,KAAK,OAAL,KAAiB,CAAjB,IAAsB,KAAK,oBAAL,CAA0B,MAA1B,GAAmC,CAA7D,EAAgE;AACrE;AACA;AACA,WAAK,OAAL,IAAgB,CAAhB;AAEA,YAAM,YAAY,GAAG,KAAK,oBAAL,CAA0B,KAA1B,EAArB;;AACA,UAAI,YAAJ,EAAkB;AAChB,QAAA,YAAY,CAAC,IAAD,CAAZ;AACD;AACF;AACF;;AAvCc;;AAAjB,OAAA,CAAA,IAAA,GAAA,IAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Lock = void 0;\n// Based on https://github.com/jsoendermann/semaphore-async-await/blob/master/src/Semaphore.ts\nclass Lock {\n    constructor() {\n        this.permits = 1;\n        this.promiseResolverQueue = [];\n    }\n    /**\n     * Returns a promise used to wait for a permit to become available. This method should be awaited on.\n     * @returns  A promise that gets resolved when execution is allowed to proceed.\n     */\n    async acquire() {\n        if (this.permits > 0) {\n            this.permits -= 1;\n            return Promise.resolve(true);\n        }\n        // If there is no permit available, we return a promise that resolves once the semaphore gets\n        // signaled enough times that permits is equal to one.\n        return new Promise((resolver) => this.promiseResolverQueue.push(resolver));\n    }\n    /**\n     * Increases the number of permits by one. If there are other functions waiting, one of them will\n     * continue to execute in a future iteration of the event loop.\n     */\n    release() {\n        this.permits += 1;\n        if (this.permits > 1 && this.promiseResolverQueue.length > 0) {\n            // eslint-disable-next-line no-console\n            console.warn('Lock.permits should never be > 0 when there is someone waiting.');\n        }\n        else if (this.permits === 1 && this.promiseResolverQueue.length > 0) {\n            // If there is someone else waiting, immediately consume the permit that was released\n            // at the beginning of this function and let the waiting function resume.\n            this.permits -= 1;\n            const nextResolver = this.promiseResolverQueue.shift();\n            if (nextResolver) {\n                nextResolver(true);\n            }\n        }\n    }\n}\nexports.Lock = Lock;\n//# sourceMappingURL=lock.js.map"]},"metadata":{},"sourceType":"script"}