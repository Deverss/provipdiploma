{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.deserializeTreeOffsetProof = exports.serializeTreeOffsetProof = exports.computeTreeOffsetProofSerializedLength = exports.createNodeFromTreeOffsetProof = exports.createTreeOffsetProof = exports.treeOffsetProofToNode = exports.nodeToTreeOffsetProof = void 0;\n\nconst node_1 = require(\"../node\");\n\nconst util_1 = require(\"./util\");\n/**\n * Compute offsets and leaves of a tree-offset proof\n *\n * Recursive function\n *\n * See https://github.com/protolambda/eth-merkle-trees/blob/master/tree_offsets.md\n * @param node current node in the tree\n * @param gindex current generalized index in the tree\n * @param proofGindices generalized indices to left include in the proof - must be sorted in-order according to the tree\n */\n\n\nfunction nodeToTreeOffsetProof(node, gindex, proofGindices) {\n  if (!proofGindices.length || !proofGindices[0].startsWith(gindex)) {\n    // there are no proof indices left OR the current subtree contains no remaining proof indices\n    return [[], []];\n  } else if (gindex === proofGindices[0]) {\n    // the current node is at the next proof index\n    proofGindices.shift();\n    return [[], [node.root]];\n  } else {\n    // recursively compute offsets, leaves for the left and right subtree\n    const [leftOffsets, leftLeaves] = nodeToTreeOffsetProof(node.left, gindex + \"0\", proofGindices);\n    const [rightOffsets, rightLeaves] = nodeToTreeOffsetProof(node.right, gindex + \"1\", proofGindices); // the offset prepended to the list is # of leaves in the left subtree\n\n    const pivot = leftLeaves.length;\n    return [[pivot].concat(leftOffsets, rightOffsets), leftLeaves.concat(rightLeaves)];\n  }\n}\n\nexports.nodeToTreeOffsetProof = nodeToTreeOffsetProof;\n/**\n * Recreate a `Node` given offsets and leaves of a tree-offset proof\n *\n * Recursive definition\n *\n * See https://github.com/protolambda/eth-merkle-trees/blob/master/tree_offsets.md\n */\n\nfunction treeOffsetProofToNode(offsets, leaves) {\n  if (!leaves.length) {\n    throw new Error(\"Proof must contain gt 0 leaves\");\n  } else if (leaves.length === 1) {\n    return node_1.LeafNode.fromRoot(leaves[0]);\n  } else {\n    // the offset popped from the list is the # of leaves in the left subtree\n    const pivot = offsets[0];\n    return new node_1.BranchNode(treeOffsetProofToNode(offsets.slice(1, pivot), leaves.slice(0, pivot)), treeOffsetProofToNode(offsets.slice(pivot), leaves.slice(pivot)));\n  }\n}\n\nexports.treeOffsetProofToNode = treeOffsetProofToNode;\n/**\n * Create a tree-offset proof\n *\n * @param rootNode the root node of the tree\n * @param gindices generalized indices to include in the proof\n */\n\nfunction createTreeOffsetProof(rootNode, gindices) {\n  return nodeToTreeOffsetProof(rootNode, \"1\", util_1.computeMultiProofBitstrings(gindices.map(g => g.toString(2))));\n}\n\nexports.createTreeOffsetProof = createTreeOffsetProof;\n/**\n * Recreate a `Node` given a tree-offset proof\n *\n * @param offsets offsets of a tree-offset proof\n * @param leaves leaves of a tree-offset proof\n */\n\nfunction createNodeFromTreeOffsetProof(offsets, leaves) {\n  // TODO validation\n  return treeOffsetProofToNode(offsets, leaves);\n}\n\nexports.createNodeFromTreeOffsetProof = createNodeFromTreeOffsetProof;\n\nfunction computeTreeOffsetProofSerializedLength(offsets, leaves) {\n  // add 1 for # of leaves\n  return (offsets.length + 1) * 2 + leaves.length * 32;\n}\n\nexports.computeTreeOffsetProofSerializedLength = computeTreeOffsetProofSerializedLength; // Serialized tree offset proof structure:\n// # of leaves - 2 bytes\n// offsets - 2 bytes each\n// leaves - 32 bytes each\n\nfunction serializeTreeOffsetProof(output, byteOffset, offsets, leaves) {\n  const writer = new DataView(output.buffer, output.byteOffset, output.byteLength); // set # of leaves\n\n  writer.setUint16(byteOffset, leaves.length, true); // set offsets\n\n  const offsetsStartIndex = byteOffset + 2;\n\n  for (let i = 0; i < offsets.length; i++) {\n    writer.setUint16(i * 2 + offsetsStartIndex, offsets[i], true);\n  } // set leaves\n\n\n  const leavesStartIndex = offsetsStartIndex + offsets.length * 2;\n\n  for (let i = 0; i < leaves.length; i++) {\n    output.set(leaves[i], i * 32 + leavesStartIndex);\n  }\n}\n\nexports.serializeTreeOffsetProof = serializeTreeOffsetProof;\n\nfunction deserializeTreeOffsetProof(data, byteOffset) {\n  const reader = new DataView(data.buffer, data.byteOffset, data.byteLength); // get # of leaves\n\n  const leafCount = reader.getUint16(byteOffset, true);\n\n  if (data.length < (leafCount - 1) * 2 + leafCount * 32) {\n    throw new Error(\"Unable to deserialize tree offset proof: not enough bytes\");\n  } // get offsets\n\n\n  const offsetsStartIndex = byteOffset + 2;\n  const offsets = Array.from({\n    length: leafCount - 1\n  }, (_, i) => reader.getUint16(i * 2 + offsetsStartIndex, true)); // get leaves\n\n  const leavesStartIndex = offsetsStartIndex + offsets.length * 2;\n  const leaves = Array.from({\n    length: leafCount\n  }, (_, i) => data.subarray(i * 32 + leavesStartIndex, (i + 1) * 32 + leavesStartIndex));\n  return [offsets, leaves];\n}\n\nexports.deserializeTreeOffsetProof = deserializeTreeOffsetProof;","map":{"version":3,"sources":["/Users/dev3rs/provipdiploma/node_modules/@chainsafe/persistent-merkle-tree/lib/proof/treeOffset.js"],"names":["Object","defineProperty","exports","value","deserializeTreeOffsetProof","serializeTreeOffsetProof","computeTreeOffsetProofSerializedLength","createNodeFromTreeOffsetProof","createTreeOffsetProof","treeOffsetProofToNode","nodeToTreeOffsetProof","node_1","require","util_1","node","gindex","proofGindices","length","startsWith","shift","root","leftOffsets","leftLeaves","left","rightOffsets","rightLeaves","right","pivot","concat","offsets","leaves","Error","LeafNode","fromRoot","BranchNode","slice","rootNode","gindices","computeMultiProofBitstrings","map","g","toString","output","byteOffset","writer","DataView","buffer","byteLength","setUint16","offsetsStartIndex","i","leavesStartIndex","set","data","reader","leafCount","getUint16","Array","from","_","subarray"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.deserializeTreeOffsetProof = exports.serializeTreeOffsetProof = exports.computeTreeOffsetProofSerializedLength = exports.createNodeFromTreeOffsetProof = exports.createTreeOffsetProof = exports.treeOffsetProofToNode = exports.nodeToTreeOffsetProof = void 0;\nconst node_1 = require(\"../node\");\nconst util_1 = require(\"./util\");\n/**\n * Compute offsets and leaves of a tree-offset proof\n *\n * Recursive function\n *\n * See https://github.com/protolambda/eth-merkle-trees/blob/master/tree_offsets.md\n * @param node current node in the tree\n * @param gindex current generalized index in the tree\n * @param proofGindices generalized indices to left include in the proof - must be sorted in-order according to the tree\n */\nfunction nodeToTreeOffsetProof(node, gindex, proofGindices) {\n    if (!proofGindices.length || !proofGindices[0].startsWith(gindex)) {\n        // there are no proof indices left OR the current subtree contains no remaining proof indices\n        return [[], []];\n    }\n    else if (gindex === proofGindices[0]) {\n        // the current node is at the next proof index\n        proofGindices.shift();\n        return [[], [node.root]];\n    }\n    else {\n        // recursively compute offsets, leaves for the left and right subtree\n        const [leftOffsets, leftLeaves] = nodeToTreeOffsetProof(node.left, gindex + \"0\", proofGindices);\n        const [rightOffsets, rightLeaves] = nodeToTreeOffsetProof(node.right, gindex + \"1\", proofGindices);\n        // the offset prepended to the list is # of leaves in the left subtree\n        const pivot = leftLeaves.length;\n        return [[pivot].concat(leftOffsets, rightOffsets), leftLeaves.concat(rightLeaves)];\n    }\n}\nexports.nodeToTreeOffsetProof = nodeToTreeOffsetProof;\n/**\n * Recreate a `Node` given offsets and leaves of a tree-offset proof\n *\n * Recursive definition\n *\n * See https://github.com/protolambda/eth-merkle-trees/blob/master/tree_offsets.md\n */\nfunction treeOffsetProofToNode(offsets, leaves) {\n    if (!leaves.length) {\n        throw new Error(\"Proof must contain gt 0 leaves\");\n    }\n    else if (leaves.length === 1) {\n        return node_1.LeafNode.fromRoot(leaves[0]);\n    }\n    else {\n        // the offset popped from the list is the # of leaves in the left subtree\n        const pivot = offsets[0];\n        return new node_1.BranchNode(treeOffsetProofToNode(offsets.slice(1, pivot), leaves.slice(0, pivot)), treeOffsetProofToNode(offsets.slice(pivot), leaves.slice(pivot)));\n    }\n}\nexports.treeOffsetProofToNode = treeOffsetProofToNode;\n/**\n * Create a tree-offset proof\n *\n * @param rootNode the root node of the tree\n * @param gindices generalized indices to include in the proof\n */\nfunction createTreeOffsetProof(rootNode, gindices) {\n    return nodeToTreeOffsetProof(rootNode, \"1\", util_1.computeMultiProofBitstrings(gindices.map((g) => g.toString(2))));\n}\nexports.createTreeOffsetProof = createTreeOffsetProof;\n/**\n * Recreate a `Node` given a tree-offset proof\n *\n * @param offsets offsets of a tree-offset proof\n * @param leaves leaves of a tree-offset proof\n */\nfunction createNodeFromTreeOffsetProof(offsets, leaves) {\n    // TODO validation\n    return treeOffsetProofToNode(offsets, leaves);\n}\nexports.createNodeFromTreeOffsetProof = createNodeFromTreeOffsetProof;\nfunction computeTreeOffsetProofSerializedLength(offsets, leaves) {\n    // add 1 for # of leaves\n    return (offsets.length + 1) * 2 + leaves.length * 32;\n}\nexports.computeTreeOffsetProofSerializedLength = computeTreeOffsetProofSerializedLength;\n// Serialized tree offset proof structure:\n// # of leaves - 2 bytes\n// offsets - 2 bytes each\n// leaves - 32 bytes each\nfunction serializeTreeOffsetProof(output, byteOffset, offsets, leaves) {\n    const writer = new DataView(output.buffer, output.byteOffset, output.byteLength);\n    // set # of leaves\n    writer.setUint16(byteOffset, leaves.length, true);\n    // set offsets\n    const offsetsStartIndex = byteOffset + 2;\n    for (let i = 0; i < offsets.length; i++) {\n        writer.setUint16(i * 2 + offsetsStartIndex, offsets[i], true);\n    }\n    // set leaves\n    const leavesStartIndex = offsetsStartIndex + offsets.length * 2;\n    for (let i = 0; i < leaves.length; i++) {\n        output.set(leaves[i], i * 32 + leavesStartIndex);\n    }\n}\nexports.serializeTreeOffsetProof = serializeTreeOffsetProof;\nfunction deserializeTreeOffsetProof(data, byteOffset) {\n    const reader = new DataView(data.buffer, data.byteOffset, data.byteLength);\n    // get # of leaves\n    const leafCount = reader.getUint16(byteOffset, true);\n    if (data.length < (leafCount - 1) * 2 + leafCount * 32) {\n        throw new Error(\"Unable to deserialize tree offset proof: not enough bytes\");\n    }\n    // get offsets\n    const offsetsStartIndex = byteOffset + 2;\n    const offsets = Array.from({ length: leafCount - 1 }, (_, i) => reader.getUint16(i * 2 + offsetsStartIndex, true));\n    // get leaves\n    const leavesStartIndex = offsetsStartIndex + offsets.length * 2;\n    const leaves = Array.from({ length: leafCount }, (_, i) => data.subarray(i * 32 + leavesStartIndex, (i + 1) * 32 + leavesStartIndex));\n    return [offsets, leaves];\n}\nexports.deserializeTreeOffsetProof = deserializeTreeOffsetProof;\n"]},"metadata":{},"sourceType":"script"}